754250e3a40723ffa88c873577489e3a
var baseSetData = require('./_baseSetData'),
    createBind = require('./_createBind'),
    createCurry = require('./_createCurry'),
    createHybrid = require('./_createHybrid'),
    createPartial = require('./_createPartial'),
    getData = require('./_getData'),
    mergeData = require('./_mergeData'),
    setData = require('./_setData'),
    setWrapToString = require('./_setWrapToString'),
    toInteger = require('./toInteger');
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to compose bitmasks for function metadata. */

var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */

function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;

  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var length = partials ? partials.length : 0;

  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }

  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;
    partials = holders = undefined;
  }

  var data = isBindKey ? undefined : getData(func);
  var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

  if (data) {
    mergeData(newData, data);
  }

  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }

  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }

  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}

module.exports = createWrap;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIl9jcmVhdGVXcmFwLmpzIl0sIm5hbWVzIjpbImJhc2VTZXREYXRhIiwicmVxdWlyZSIsImNyZWF0ZUJpbmQiLCJjcmVhdGVDdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZVBhcnRpYWwiLCJnZXREYXRhIiwibWVyZ2VEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsInRvSW50ZWdlciIsIkZVTkNfRVJST1JfVEVYVCIsIldSQVBfQklORF9GTEFHIiwiV1JBUF9CSU5EX0tFWV9GTEFHIiwiV1JBUF9DVVJSWV9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9QQVJUSUFMX0ZMQUciLCJXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyIsIm5hdGl2ZU1heCIsIk1hdGgiLCJtYXgiLCJjcmVhdGVXcmFwIiwiZnVuYyIsImJpdG1hc2siLCJ0aGlzQXJnIiwicGFydGlhbHMiLCJob2xkZXJzIiwiYXJnUG9zIiwiYXJ5IiwiYXJpdHkiLCJpc0JpbmRLZXkiLCJUeXBlRXJyb3IiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiZGF0YSIsIm5ld0RhdGEiLCJyZXN1bHQiLCJhcHBseSIsInNldHRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFdBQVcsR0FBR0MsT0FBTyxDQUFDLGdCQUFELENBQXpCO0FBQUEsSUFDSUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsZUFBRCxDQUR4QjtBQUFBLElBRUlFLFdBQVcsR0FBR0YsT0FBTyxDQUFDLGdCQUFELENBRnpCO0FBQUEsSUFHSUcsWUFBWSxHQUFHSCxPQUFPLENBQUMsaUJBQUQsQ0FIMUI7QUFBQSxJQUlJSSxhQUFhLEdBQUdKLE9BQU8sQ0FBQyxrQkFBRCxDQUozQjtBQUFBLElBS0lLLE9BQU8sR0FBR0wsT0FBTyxDQUFDLFlBQUQsQ0FMckI7QUFBQSxJQU1JTSxTQUFTLEdBQUdOLE9BQU8sQ0FBQyxjQUFELENB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QUFsQztBQUNBLFNBQU9DLGVBQWUsQ0FBQytCLE1BQU0sQ0FBQ0YsTUFBRCxFQUFTRCxPQUFULENBQVAsRUFBMEJmLElBQTFCLEVBQWdDQyxPQUFoQyxDQUF0QjtBQUNEOztBQUVEa0IsTUFBTSxDQUFDQyxPQUFQLEdBQWlCckIsVUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZVNldERhdGEgPSByZXF1aXJlKCcuL19iYXNlU2V0RGF0YScpLFxuICAgIGNyZWF0ZUJpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVCaW5kJyksXG4gICAgY3JlYXRlQ3VycnkgPSByZXF1aXJlKCcuL19jcmVhdGVDdXJyeScpLFxuICAgIGNyZWF0ZUh5YnJpZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUh5YnJpZCcpLFxuICAgIGNyZWF0ZVBhcnRpYWwgPSByZXF1aXJlKCcuL19jcmVhdGVQYXJ0aWFsJyksXG4gICAgZ2V0RGF0YSA9IHJlcXVpcmUoJy4vX2dldERhdGEnKSxcbiAgICBtZXJnZURhdGEgPSByZXF1aXJlKCcuL19tZXJnZURhdGEnKSxcbiAgICBzZXREYXRhID0gcmVxdWlyZSgnLi9fc2V0RGF0YScpLFxuICAgIHNldFdyYXBUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFdyYXBUb1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAgIDEgLSBgXy5iaW5kYFxuICogICAgMiAtIGBfLmJpbmRLZXlgXG4gKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAqICAgIDggLSBgXy5jdXJyeWBcbiAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICogICAzMiAtIGBfLnBhcnRpYWxgXG4gKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICogIDEyOCAtIGBfLnJlYXJnYFxuICogIDI1NiAtIGBfLmFyeWBcbiAqICA1MTIgLSBgXy5mbGlwYFxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICB2YXIgbmV3RGF0YSA9IFtcbiAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICBdO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICB9XG4gIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICB9XG4gIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXcmFwO1xuIl19