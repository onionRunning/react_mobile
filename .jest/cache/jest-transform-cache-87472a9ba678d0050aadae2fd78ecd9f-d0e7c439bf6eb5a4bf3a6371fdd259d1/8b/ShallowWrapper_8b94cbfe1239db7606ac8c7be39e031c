b730027ddd54041f01f0e26324fa15a4
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function () {
  function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }

  return get;
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _arrayPrototype = require('array.prototype.flat');

var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _enzymeShallowEqual = require('enzyme-shallow-equal');

var _enzymeShallowEqual2 = _interopRequireDefault(_enzymeShallowEqual);

var _Utils = require('./Utils');

var _getAdapter = require('./getAdapter');

var _getAdapter2 = _interopRequireDefault(_getAdapter);

var _Debug = require('./Debug');

var _RSTTraversal = require('./RSTTraversal');

var _selectors = require('./selectors');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var NODE = (0, _Utils.sym)('__node__');
var NODES = (0, _Utils.sym)('__nodes__');
var RENDERER = (0, _Utils.sym)('__renderer__');
var UNRENDERED = (0, _Utils.sym)('__unrendered__');
var ROOT = (0, _Utils.sym)('__root__');
var OPTIONS = (0, _Utils.sym)('__options__');
var SET_STATE = (0, _Utils.sym)('__setState__');
var ROOT_NODES = (0, _Utils.sym)('__rootNodes__');
var CHILD_CONTEXT = (0, _Utils.sym)('__childContext__');
var WRAPPING_COMPONENT = (0, _Utils.sym)('__wrappingComponent__');
var PRIMARY_WRAPPER = (0, _Utils.sym)('__primaryWrapper__');
var ROOT_FINDER = (0, _Utils.sym)('__rootFinder__');
var PROVIDER_VALUES = (0, _Utils.sym)('__providerValues__');
/**
 * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate
 * function.
 *
 * @param {ShallowWrapper} wrapper
 * @param {Function} predicate
 * @param {Function} filter
 * @returns {ShallowWrapper}
 */

function findWhereUnwrapped(wrapper, predicate) {
  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _RSTTraversal.treeFilter;
  return wrapper.flatMap(function (n) {
    return filter(n.getNodeInternal(), predicate);
  });
}
/**
 * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
 * the provided predicate function.
 *
 * @param {ShallowWrapper} wrapper
 * @param {Function} predicate
 * @returns {ShallowWrapper}
 */


function filterWhereUnwrapped(wrapper, predicate) {
  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));
}
/**
 * Ensure options passed to ShallowWrapper are valid. Throws otherwise.
 * @param {Object} options
 */


function validateOptions(options) {
  var lifecycleExperimental = options.lifecycleExperimental,
      disableLifecycleMethods = options.disableLifecycleMethods,
      enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,
      supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate,
      lifecycles = options.lifecycles;

  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {
    throw new Error('lifecycleExperimental must be either true or false if provided');
  }

  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {
    throw new Error('disableLifecycleMethods must be either true or false if provided');
  }

  if (lifecycleExperimental != null && disableLifecycleMethods != null && lifecycleExperimental === disableLifecycleMethods) {
    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');
  }

  if (typeof enableComponentDidUpdateOnSetState !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState) {
    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');
  }

  if (typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate) {
    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');
  }
}

function getAdapterLifecycles(_ref) {
  var options = _ref.options;
  var _options$lifecycles = options.lifecycles,
      lifecycles = _options$lifecycles === undefined ? {} : _options$lifecycles,
      enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,
      supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate;
  var hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';
  var hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';
  var componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg ? (0, _object2['default'])({}, hasLegacySetStateArg && {
    onSetState: !!enableComponentDidUpdateOnSetState
  }, hasLegacyPrevContextArg && {
    prevContext: !!supportPrevContextArgumentOfComponentDidUpdate
  }) : null;
  var originalGDSFP = lifecycles.getDerivedStateFromProps;
  var getDerivedStateFromProps = originalGDSFP ? {
    hasShouldComponentUpdateBug: !!originalGDSFP.hasShouldComponentUpdateBug
  } : false;
  return (0, _object2['default'])({}, lifecycles, {
    setState: (0, _object2['default'])({}, lifecycles.setState),
    getChildContext: (0, _object2['default'])({
      calledByRenderer: true
    }, lifecycles.getChildContext)
  }, componentDidUpdate && {
    componentDidUpdate: componentDidUpdate
  }, {
    getDerivedStateFromProps: getDerivedStateFromProps
  });
}

function getRootNode(node) {
  if (node.nodeType === 'host') {
    return node;
  }

  return node.rendered;
}

function getRootNodeInternal(wrapper) {
  if (wrapper[ROOT].length !== 1) {
    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');
  }

  if (wrapper[ROOT] !== wrapper) {
    return wrapper[ROOT_NODES][0];
  }

  return wrapper[ROOT][NODE];
}

function nodeParents(wrapper, node) {
  return (0, _RSTTraversal.parentsOfNode)(node, getRootNodeInternal(wrapper));
}

function privateSetNodes(wrapper, nodes) {
  if (!Array.isArray(nodes)) {
    (0, _Utils.privateSet)(wrapper, NODE, nodes);
    (0, _Utils.privateSet)(wrapper, NODES, [nodes]);
  } else {
    (0, _Utils.privateSet)(wrapper, NODE, nodes[0]);
    (0, _Utils.privateSet)(wrapper, NODES, nodes);
  }

  (0, _Utils.privateSet)(wrapper, 'length', wrapper[NODES].length);
}

function pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {
  return !(0, _enzymeShallowEqual2['default'])(prevProps, props) || !(0, _enzymeShallowEqual2['default'])(prevState, state);
}

function isPureComponent(instance) {
  return instance && instance.isPureReactComponent;
}

function getChildContext(node, hierarchy, renderer) {
  var instance = node.instance,
      Component = node.type;
  var componentName = (0, _Utils.displayNameOfNode)(node); // Warn like react if childContextTypes is not defined:
  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L639-L646

  if (_typeof(Component.childContextTypes) !== 'object') {
    // eslint-disable-next-line no-console
    console.warn(String(componentName) + '.getChildContext(): childContextTypes must be defined in order to use getChildContext().');
    return {};
  } // Check childContextTypes like react:
  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L630-L637


  var childContext = instance.getChildContext();
  Object.keys(childContext).forEach(function (key) {
    if (!(key in Component.childContextTypes)) {
      throw new Error(String(componentName) + '.getChildContext(): key "' + String(key) + '" is not defined in childContextTypes.');
    }
  });

  if (typeof renderer.checkPropTypes === 'function') {
    renderer.checkPropTypes(Component.childContextTypes, childContext, 'child context', hierarchy);
  }

  return childContext;
}

function spyOnGetChildContextInitialRender(nodes, adapter) {
  if (!(0, _Utils.isCustomComponentElement)(nodes, adapter) || !nodes.type.prototype || typeof nodes.type.prototype.getChildContext !== 'function') {
    return null;
  }

  return (0, _Utils.spyMethod)(nodes.type.prototype, 'getChildContext');
}

function privateSetChildContext(adapter, wrapper, instance, renderedNode, getChildContextSpy) {
  var renderer = wrapper[RENDERER]; // We only support parent-based context.

  if (adapter.options.legacyContextMode !== 'parent') {
    return;
  }

  if (getChildContextSpy) {
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, getChildContextSpy.getLastReturnValue());
    getChildContextSpy.restore();
  } else if (typeof instance.getChildContext === 'function') {
    // If there's no spy but getChildContext is a function, that means our renderer
    // is not going to call it for us, so we need to call it ourselves.
    var nodeHierarchy = [wrapper[NODE]].concat(nodeParents(wrapper, wrapper[NODE]));
    var childContext = getChildContext(renderedNode, nodeHierarchy, renderer);
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, childContext);
  } else {
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, null);
  }
}

function mockSCUIfgDSFPReturnNonNull(node, state) {
  var getDerivedStateFromProps = node.type.getDerivedStateFromProps;

  if (typeof getDerivedStateFromProps === 'function') {
    // we try to fix a React shallow renderer bug here.
    // (facebook/react#14607, which has been fixed in react 16.8):
    // when gDSFP return derived state, it will set instance state in shallow renderer before SCU,
    // this will cause `this.state` in sCU be the updated state, which is wrong behavior.
    // so we have to wrap sCU to pass the old state to original sCU.
    var instance = node.instance;

    var _spyMethod = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate', function (originalSCU) {
      return function () {
        function shouldComponentUpdate() {
          instance.state = state;

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var sCUResult = originalSCU.apply(instance, args);
          var nextState = args[1];
          instance.state = nextState;
          restore();
          return sCUResult;
        }

        return shouldComponentUpdate;
      }();
    }),
        restore = _spyMethod.restore;
  }
}
/**
 * Recursively dive()s every custom component in a wrapper until
 * the target component is found.
 *
 * @param {ShallowWrapper} wrapper A ShallowWrapper to search
 * @param {ComponentType} target A react custom component that, when found, will end recursion
 * @param {Adapter} adapter An Enzyme adapter
 * @returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or
 *  undefined if it can't be found
 */


function deepRender(wrapper, target, adapter) {
  var node = wrapper[NODE];
  var element = node && adapter.nodeToElement(node);

  if (wrapper.type() === target) {
    return wrapper.dive();
  }

  if (element && (0, _Utils.isCustomComponentElement)(element, adapter)) {
    return deepRender(wrapper.dive(), target, adapter);
  }

  var children = wrapper.children();

  for (var i = 0; i < children.length; i += 1) {
    var found = deepRender(children.at(i), target, adapter);

    if (typeof found !== 'undefined') {
      return found;
    }
  }

  return undefined;
}
/**
 * Deep-renders the `wrappingComponent` and returns the context that should
 * be accessible to the primary wrapper.
 *
 * @param {WrappingComponentWrapper} wrapper The `WrappingComponentWrapper` for a
 *  `wrappingComponent`
 * @param {Adapter} adapter An Enzyme adapter
 * @returns {object} An object containing an object of legacy context values and a Map of
 *  `createContext()` Provider values.
 */


function getContextFromWrappingComponent(wrapper, adapter) {
  var rootFinder = deepRender(wrapper, wrapper[ROOT_FINDER], adapter);

  if (!rootFinder) {
    throw new Error('`wrappingComponent` must render its children!');
  }

  return {
    legacyContext: rootFinder[OPTIONS].context,
    providerValues: rootFinder[PROVIDER_VALUES]
  };
}
/**
 * Makes options specifically for `ShallowWrapper`. Most of the logic here is around rendering
 * a `wrappingComponent` (if one was provided) and adding the child context of that component
 * to `options.context`.
 *
 * @param {ReactElement} nodes the nodes passed to `ShallowWrapper`
 * @param {ShallowWrapper} root this `ShallowWrapper`'s parent. If this is passed, options are
 *  not transformed.
 * @param {*} passedOptions the options passed to `ShallowWrapper`.
 * @param {*} wrapper the `ShallowWrapper` itself
 * @returns {Object} the decorated and transformed options
 */


function makeShallowOptions(nodes, root, passedOptions, wrapper) {
  var options = (0, _Utils.makeOptions)(passedOptions);
  var adapter = (0, _getAdapter2['default'])(passedOptions);
  (0, _Utils.privateSet)(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);

  if (root || !(0, _Utils.isCustomComponent)(options.wrappingComponent, adapter)) {
    return options;
  }

  if (typeof adapter.wrapWithWrappingComponent !== 'function') {
    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');
  }

  var _adapter$wrapWithWrap = adapter.wrapWithWrappingComponent(nodes, options),
      wrappedNode = _adapter$wrapWithWrap.node,
      RootFinder = _adapter$wrapWithWrap.RootFinder; // eslint-disable-next-line no-use-before-define


  var wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);

  var _getContextFromWrappi = getContextFromWrappingComponent(wrappingComponent, adapter),
      wrappingComponentLegacyContext = _getContextFromWrappi.legacyContext,
      wrappingComponentProviderValues = _getContextFromWrappi.providerValues;

  (0, _Utils.privateSet)(wrapper, WRAPPING_COMPONENT, wrappingComponent);
  return (0, _object2['default'])({}, options, _defineProperty({
    context: (0, _object2['default'])({}, options.context, wrappingComponentLegacyContext)
  }, PROVIDER_VALUES, wrappingComponentProviderValues));
}

function makeInheritedChildOptions(wrapper) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var childOptions = (0, _object2['default'])({}, wrapper[OPTIONS], options, {
    context: options.context || (0, _object2['default'])({}, wrapper[OPTIONS].context, wrapper[ROOT][CHILD_CONTEXT])
  });
  (0, _Utils.privateSet)(childOptions, PROVIDER_VALUES, wrapper[ROOT][PROVIDER_VALUES]);
  return childOptions;
}
/**
 * @class ShallowWrapper
 */


var ShallowWrapper = function () {
  function ShallowWrapper(nodes, root) {
    var _this = this;

    var passedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ShallowWrapper);

    validateOptions(passedOptions);
    var options = makeShallowOptions(nodes, root, passedOptions, this);
    var adapter = (0, _getAdapter2['default'])(options);
    var lifecycles = getAdapterLifecycles(adapter); // mounting a ShallowRender component

    if (!root) {
      if (!adapter.isValidElement(nodes)) {
        throw new TypeError('ShallowWrapper can only wrap valid elements');
      }

      var getChildContextSpy = lifecycles.getChildContext.calledByRenderer ? spyOnGetChildContextInitialRender(nodes, adapter) : null;
      (0, _Utils.privateSet)(this, ROOT, this);
      (0, _Utils.privateSet)(this, UNRENDERED, nodes);
      var renderer = adapter.createRenderer((0, _object2['default'])({
        mode: 'shallow'
      }, options));
      (0, _Utils.privateSet)(this, RENDERER, renderer);
      var providerValues = new Map(options[PROVIDER_VALUES] || []);
      this[RENDERER].render(nodes, options.context, {
        providerValues: providerValues
      });
      var renderedNode = this[RENDERER].getNode();
      privateSetNodes(this, getRootNode(renderedNode));
      (0, _Utils.privateSet)(this, OPTIONS, options);
      (0, _Utils.privateSet)(this, PROVIDER_VALUES, providerValues);
      var instance = renderedNode.instance;

      if (instance && !options.disableLifecycleMethods) {
        // Ensure to call componentDidUpdate when instance.setState is called
        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {
          (0, _Utils.privateSet)(instance, SET_STATE, instance.setState);

          instance.setState = function (updater) {
            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
            return _this.setState.apply(_this, _toConsumableArray(callback == null ? [updater] : [updater, callback]));
          };
        }

        if (typeof instance.componentDidMount === 'function') {
          this[RENDERER].batchedUpdates(function () {
            instance.componentDidMount();
          });
        }

        privateSetChildContext(adapter, this, instance, renderedNode, getChildContextSpy);
      } // creating a child component through enzyme's ShallowWrapper APIs.

    } else {
      (0, _Utils.privateSet)(this, ROOT, root);
      (0, _Utils.privateSet)(this, UNRENDERED, null);
      (0, _Utils.privateSet)(this, RENDERER, root[RENDERER]);
      privateSetNodes(this, nodes);
      (0, _Utils.privateSet)(this, OPTIONS, root[OPTIONS]);
      (0, _Utils.privateSet)(this, ROOT_NODES, root[NODES]);
      (0, _Utils.privateSet)(this, PROVIDER_VALUES, null);
    }
  }
  /**
   * Returns the root wrapper
   *
   * @return {ShallowWrapper}
   */


  _createClass(ShallowWrapper, [{
    key: 'root',
    value: function () {
      function root() {
        return this[ROOT];
      }

      return root;
    }()
    /**
     * Returns the wrapped component.
     *
     * @return {ReactComponent}
     */

  }, {
    key: 'getNodeInternal',
    value: function () {
      function getNodeInternal() {
        if (this.length !== 1) {
          throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');
        }

        if (this[ROOT] === this) {
          this.update();
        }

        return this[NODE];
      }

      return getNodeInternal;
    }()
    /**
     * Returns the the wrapped components.
     *
     * @return {Array<ReactComponent>}
     */

  }, {
    key: 'getNodesInternal',
    value: function () {
      function getNodesInternal() {
        if (this[ROOT] === this && this.length === 1) {
          this.update();
        }

        return this[NODES];
      }

      return getNodesInternal;
    }()
    /**
     * Returns the wrapped ReactElement.
     *
     * @return {ReactElement}
     */

  }, {
    key: 'getElement',
    value: function () {
      function getElement() {
        var _this2 = this;

        return this.single('getElement', function (n) {
          return (0, _getAdapter2['default'])(_this2[OPTIONS]).nodeToElement(n);
        });
      }

      return getElement;
    }()
    /**
     * Returns the wrapped ReactElements.
     *
     * @return {Array<ReactElement>}
     */

  }, {
    key: 'getElements',
    value: function () {
      function getElements() {
        var _this3 = this;

        return this.getNodesInternal().map(function (n) {
          return (0, _getAdapter2['default'])(_this3[OPTIONS]).nodeToElement(n);
        });
      }

      return getElements;
    }() // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'getNode',
    value: function () {
      function getNode() {
        throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');
      }

      return getNode;
    }() // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'getNodes',
    value: function () {
      function getNodes() {
        throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');
      }

      return getNodes;
    }()
    /**
     * Gets the instance of the component being rendered as the root node passed into `shallow()`.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * const inst = wrapper.instance();
     * expect(inst).to.be.instanceOf(MyComponent);
     * ```
     * @returns {ReactComponent}
     */

  }, {
    key: 'instance',
    value: function () {
      function instance() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::instance() can only be called on the root');
        }

        return this[RENDERER].getNode().instance;
      }

      return instance;
    }()
    /**
     * If a `wrappingComponent` was passed in `options`, this methods returns a `ShallowWrapper`
     * around the rendered `wrappingComponent`. This `ShallowWrapper` can be used to update the
     * `wrappingComponent`'s props, state, etc.
     *
     * @returns ShallowWrapper
     */

  }, {
    key: 'getWrappingComponent',
    value: function () {
      function getWrappingComponent() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');
        }

        if (!this[OPTIONS].wrappingComponent) {
          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');
        }

        return this[WRAPPING_COMPONENT];
      }

      return getWrappingComponent;
    }()
    /**
     * Forces a re-render. Useful to run before checking the render output if something external
     * may be updating the state of the component somewhere.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'update',
    value: function () {
      function update() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::update() can only be called on the root');
        }

        if (this.length !== 1) {
          throw new Error('ShallowWrapper::update() can only be called when wrapping one node');
        }

        privateSetNodes(this, getRootNode(this[RENDERER].getNode()));
        return this;
      }

      return update;
    }()
    /**
     * A method that unmounts the component. This can be used to simulate a component going through
     * and unmount/mount lifecycle.
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'unmount',
    value: function () {
      function unmount() {
        this[RENDERER].unmount();

        if (this[ROOT][WRAPPING_COMPONENT]) {
          this[ROOT][WRAPPING_COMPONENT].unmount();
        }

        return this;
      }

      return unmount;
    }()
    /**
     * A method is for re-render with new props and context.
     * This calls componentDidUpdate method if disableLifecycleMethods is not enabled.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} props
     * @param {Object} context
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'rerender',
    value: function () {
      function rerender(props, context) {
        var _this4 = this;

        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        this.single('rerender', function () {
          (0, _Utils.withSetStateAllowed)(function () {
            // NOTE(lmr): In react 16, instances will be null for SFCs, but
            // rerendering with props/context is still a valid thing to do. In
            // this case, state will be undefined, but props/context will exist.
            var node = _this4[RENDERER].getNode();

            var instance = node.instance || {};
            var type = node.type || {};
            var state = instance.state;
            var prevProps = instance.props || _this4[UNRENDERED].props;
            var prevContext = instance.context || _this4[OPTIONS].context;
            var nextContext = context || prevContext;

            if (context) {
              _this4[OPTIONS] = (0, _object2['default'])({}, _this4[OPTIONS], {
                context: nextContext
              });
            }

            _this4[RENDERER].batchedUpdates(function () {
              // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.
              // so we spy shouldComponentUpdate to get the result.
              var lifecycles = getAdapterLifecycles(adapter);
              var shouldRender = true;
              var shouldComponentUpdateSpy = void 0;
              var getChildContextSpy = void 0;

              if (!_this4[OPTIONS].disableLifecycleMethods && instance) {
                if (typeof instance.shouldComponentUpdate === 'function') {
                  var gDSFP = lifecycles.getDerivedStateFromProps;

                  if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {
                    mockSCUIfgDSFPReturnNonNull(node, state);
                  }

                  shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');
                }

                if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {
                  getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');
                }
              }

              if (!shouldComponentUpdateSpy && isPureComponent(instance)) {
                shouldRender = pureComponentShouldComponentUpdate(prevProps, props, state, instance.state);
              }

              if (props) _this4[UNRENDERED] = (0, _Utils.cloneElement)(adapter, _this4[UNRENDERED], props);

              _this4[RENDERER].render(_this4[UNRENDERED], nextContext, {
                providerValues: _this4[PROVIDER_VALUES]
              });

              if (shouldComponentUpdateSpy) {
                shouldRender = shouldComponentUpdateSpy.getLastReturnValue();
                shouldComponentUpdateSpy.restore();
              }

              if (shouldRender && !_this4[OPTIONS].disableLifecycleMethods && instance) {
                privateSetChildContext(adapter, _this4, instance, node, getChildContextSpy);

                if (lifecycles.getSnapshotBeforeUpdate) {
                  var snapshot = void 0;

                  if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                    snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);
                  }

                  if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function' && (!state || (0, _enzymeShallowEqual2['default'])(state, _this4.instance().state) || typeof type.getDerivedStateFromProps === 'function')) {
                    instance.componentDidUpdate(prevProps, state, snapshot);
                  }
                } else if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function') {
                  if (lifecycles.componentDidUpdate.prevContext) {
                    instance.componentDidUpdate(prevProps, state, prevContext);
                  } else if (!state || (0, _enzymeShallowEqual2['default'])(_this4.instance().state, state)) {
                    instance.componentDidUpdate(prevProps, state);
                  }
                } // If it doesn't need to rerender, update only its props.

              } else if (!(0, _enzymeShallowEqual2['default'])(props, instance.props)) {
                instance.props = (Object.freeze || Object)((0, _object2['default'])({}, instance.props, props));
              }

              _this4.update();
            });
          });
        });
        return this;
      }

      return rerender;
    }()
    /**
     * A method that sets the props of the root component, and re-renders. Useful for when you are
     * wanting to test how the component behaves over time with changing props. Calling this, for
     * instance, will call the `componentWillReceiveProps` lifecycle method.
     *
     * Similar to `setState`, this method accepts a props object and will merge it in with the already
     * existing props.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} props object
     * @param {Function} cb - callback function
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'setProps',
    value: function () {
      function setProps(props) {
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setProps() can only be called on the root');
        }

        if (arguments.length > 1 && typeof callback !== 'function') {
          throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');
        }

        this.rerender(props);

        if (callback) {
          callback();
        }

        return this;
      }

      return setProps;
    }()
    /**
     * A method to invoke `setState` on the root component instance similar to how you might in the
     * definition of the component, and re-renders.  This method is useful for testing your component
     * in hard to achieve states, however should be used sparingly. If possible, you should utilize
     * your component's external API in order to get it into whatever state you want to test, in order
     * to be as accurate of a test as possible. This is not always practical, however.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} state to merge
     * @param {Function} cb - callback function
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'setState',
    value: function () {
      function setState(state) {
        var _this5 = this;

        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setState() can only be called on the root');
        }

        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
          throw new Error('ShallowWrapper::setState() can only be called on class components');
        }

        if (arguments.length > 1 && typeof callback !== 'function') {
          throw new TypeError('ReactWrapper::setState() expects a function as its second argument');
        }

        this.single('setState', function () {
          (0, _Utils.withSetStateAllowed)(function () {
            var adapter = (0, _getAdapter2['default'])(_this5[OPTIONS]);
            var lifecycles = getAdapterLifecycles(adapter);

            var node = _this5[RENDERER].getNode();

            var instance = node.instance;
            var prevProps = instance.props;
            var prevState = instance.state;
            var prevContext = instance.context;
            var statePayload = typeof state === 'function' ? state.call(instance, prevState, prevProps) : state; // returning null or undefined prevents the update in React 16+
            // https://github.com/facebook/react/pull/12756

            var maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish || statePayload != null; // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.
            // so we spy shouldComponentUpdate to get the result.

            var shouldComponentUpdateSpy = void 0;
            var getChildContextSpy = void 0;
            var shouldRender = true;

            if (!_this5[OPTIONS].disableLifecycleMethods && instance) {
              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState && typeof instance.shouldComponentUpdate === 'function') {
                var gDSFP = lifecycles.getDerivedStateFromProps;

                if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {
                  mockSCUIfgDSFPReturnNonNull(node, state);
                }

                shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');
              }

              if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {
                getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');
              }
            }

            if (!shouldComponentUpdateSpy && isPureComponent(instance)) {
              shouldRender = pureComponentShouldComponentUpdate(prevProps, instance.props, prevState, (0, _object2['default'])({}, prevState, statePayload));
            } // We don't pass the setState callback here
            // to guarantee to call the callback after finishing the render


            if (instance[SET_STATE]) {
              instance[SET_STATE](statePayload);
            } else {
              instance.setState(statePayload);
            }

            if (shouldComponentUpdateSpy) {
              shouldRender = shouldComponentUpdateSpy.getLastReturnValue();
              shouldComponentUpdateSpy.restore();
            }

            if (maybeHasUpdate && shouldRender && !_this5[OPTIONS].disableLifecycleMethods) {
              privateSetChildContext(adapter, _this5, instance, node, getChildContextSpy);

              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState) {
                if (lifecycles.getSnapshotBeforeUpdate && typeof instance.getSnapshotBeforeUpdate === 'function') {
                  var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);

                  if (typeof instance.componentDidUpdate === 'function') {
                    instance.componentDidUpdate(prevProps, prevState, snapshot);
                  }
                } else if (typeof instance.componentDidUpdate === 'function') {
                  if (lifecycles.componentDidUpdate.prevContext) {
                    instance.componentDidUpdate(prevProps, prevState, prevContext);
                  } else {
                    instance.componentDidUpdate(prevProps, prevState);
                  }
                }
              }
            }

            _this5.update(); // call the setState callback


            if (callback) {
              if (adapter.invokeSetStateCallback) {
                adapter.invokeSetStateCallback(instance, callback);
              } else {
                callback.call(instance);
              }
            }
          });
        });
        return this;
      }

      return setState;
    }()
    /**
     * A method that sets the context of the root component, and re-renders. Useful for when you are
     * wanting to test how the component behaves over time with changing contexts.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} context object
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'setContext',
    value: function () {
      function setContext(context) {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setContext() can only be called on the root');
        }

        if (!this[OPTIONS].context) {
          throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');
        }

        return this.rerender(null, context);
      }

      return setContext;
    }()
    /**
     * Whether or not a given react element exists in the shallow render tree.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.contains(<div className="foo bar" />)).to.equal(true);
     * ```
     *
     * @param {ReactElement|Array<ReactElement>} nodeOrNodes
     * @returns {Boolean}
     */

  }, {
    key: 'contains',
    value: function () {
      function contains(nodeOrNodes) {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);

        if (!(0, _Utils.isReactElementAlike)(nodeOrNodes, adapter)) {
          throw new Error('ShallowWrapper::contains() can only be called with a ReactElement (or an array of them), a string, or a number as an argument.');
        }

        var predicate = Array.isArray(nodeOrNodes) ? function (other) {
          return (0, _Utils.containsChildrenSubArray)(_Utils.nodeEqual, other, nodeOrNodes.map(function (node) {
            return adapter.elementToNode(node);
          }));
        } : function (other) {
          return (0, _Utils.nodeEqual)(adapter.elementToNode(nodeOrNodes), other);
        };
        return findWhereUnwrapped(this, predicate).length > 0;
      }

      return contains;
    }()
    /**
     * Whether or not a given react element exists in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * // MyComponent outputs <div><div class="foo">Hello</div></div>
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */

  }, {
    key: 'containsMatchingElement',
    value: function () {
      function containsMatchingElement(node) {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        var rstNode = adapter.elementToNode(node);

        var predicate = function () {
          function predicate(other) {
            return (0, _Utils.nodeMatches)(rstNode, other, function (a, b) {
              return a <= b;
            });
          }

          return predicate;
        }();

        return findWhereUnwrapped(this, predicate).length > 0;
      }

      return containsMatchingElement;
    }()
    /**
     * Whether or not all the given react elements exist in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsAllMatchingElements([
     *   <div>Hello</div>,
     *   <div>Goodbye</div>,
     * ])).to.equal(true);
     * ```
     *
     * @param {Array<ReactElement>} nodes
     * @returns {Boolean}
     */

  }, {
    key: 'containsAllMatchingElements',
    value: function () {
      function containsAllMatchingElements(nodes) {
        var _this6 = this;

        if (!Array.isArray(nodes)) {
          throw new TypeError('nodes should be an Array');
        }

        return nodes.every(function (node) {
          return _this6.containsMatchingElement(node);
        });
      }

      return containsAllMatchingElements;
    }()
    /**
     * Whether or not one of the given react elements exists in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsAnyMatchingElements([
     *   <div>Hello</div>,
     *   <div>Goodbye</div>,
     * ])).to.equal(true);
     * ```
     *
     * @param {Array<ReactElement>} nodes
     * @returns {Boolean}
     */

  }, {
    key: 'containsAnyMatchingElements',
    value: function () {
      function containsAnyMatchingElements(nodes) {
        var _this7 = this;

        return Array.isArray(nodes) && nodes.some(function (node) {
          return _this7.containsMatchingElement(node);
        });
      }

      return containsAnyMatchingElements;
    }()
    /**
     * Whether or not a given react element exists in the render tree.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.contains(<div className="foo bar" />)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */

  }, {
    key: 'equals',
    value: function () {
      function equals(node) {
        var _this8 = this;

        return this.single('equals', function () {
          return (0, _Utils.nodeEqual)(_this8.getNodeInternal(), node);
        });
      }

      return equals;
    }()
    /**
     * Whether or not a given react element matches the render tree.
     * Match is based on the expected element and not on wrapper root node.
     * It will determine if the wrapper root node "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrapper root node and equals to each other.
     *
     * Example:
     * ```
     * // MyComponent outputs <div class="foo">Hello</div>
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */

  }, {
    key: 'matchesElement',
    value: function () {
      function matchesElement(node) {
        var _this9 = this;

        return this.single('matchesElement', function () {
          var adapter = (0, _getAdapter2['default'])(_this9[OPTIONS]);
          var rstNode = adapter.elementToNode(node);
          return (0, _Utils.nodeMatches)(rstNode, _this9.getNodeInternal(), function (a, b) {
            return a <= b;
          });
        });
      }

      return matchesElement;
    }()
    /**
     * Finds every node in the render tree of the current wrapper that matches the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'find',
    value: function () {
      function find(selector) {
        return this.wrap((0, _selectors.reduceTreesBySelector)(selector, this.getNodesInternal()));
      }

      return find;
    }()
    /**
     * Returns whether or not current node matches a provided selector.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {EnzymeSelector} selector
     * @returns {boolean}
     */

  }, {
    key: 'is',
    value: function () {
      function is(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.single('is', function (n) {
          return predicate(n);
        });
      }

      return is;
    }()
    /**
     * Returns true if the component rendered nothing, i.e., null or false.
     *
     * @returns {boolean}
     */

  }, {
    key: 'isEmptyRender',
    value: function () {
      function isEmptyRender() {
        var nodes = this.getNodesInternal();
        return nodes.every(function (n) {
          return (0, _Utils.isEmptyValue)(n);
        });
      }

      return isEmptyRender;
    }()
    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
     * the provided predicate function. The predicate should receive a wrapped node as its first
     * argument.
     *
     * @param {Function} predicate
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'filterWhere',
    value: function () {
      function filterWhere(predicate) {
        var _this10 = this;

        return filterWhereUnwrapped(this, function (n) {
          return predicate(_this10.wrap(n));
        });
      }

      return filterWhere;
    }()
    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
     * the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'filter',
    value: function () {
      function filter(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return filterWhereUnwrapped(this, predicate);
      }

      return filter;
    }()
    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper that did not match
     * the provided selector. Essentially the inverse of `filter`.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'not',
    value: function () {
      function not(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return filterWhereUnwrapped(this, function (n) {
          return !predicate(n);
        });
      }

      return not;
    }()
    /**
     * Returns a string of the rendered text of the current render tree.  This function should be
     * looked at with skepticism if being used to test what the actual HTML output of the component
     * will be. If that is what you would like to test, use enzyme's `render` function instead.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {String}
     */

  }, {
    key: 'text',
    value: function () {
      function text() {
        return this.single('text', _RSTTraversal.getTextFromNode);
      }

      return text;
    }()
    /**
     * Returns the HTML of the node.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {String}
     */

  }, {
    key: 'html',
    value: function () {
      function html() {
        var _this11 = this;

        return this.single('html', function (n) {
          if (_this11.type() === null) return null;
          var adapter = (0, _getAdapter2['default'])(_this11[OPTIONS]);
          var renderer = adapter.createRenderer((0, _object2['default'])({}, _this11[OPTIONS], {
            mode: 'string'
          }));
          return renderer.render(adapter.nodeToElement(n));
        });
      }

      return html;
    }()
    /**
     * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {CheerioWrapper}
     */

  }, {
    key: 'render',
    value: function () {
      function render() {
        var html = this.html();
        return (0, _Utils.loadCheerioRoot)(html);
      }

      return render;
    }()
    /**
     * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of
     * testing events should be met with some skepticism.
     *
     * @param {String} event
     * @param {Array} args
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'simulate',
    value: function () {
      function simulate(event) {
        var _this12 = this;

        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return this.single('simulate', function (n) {
          var _RENDERER;

          (_RENDERER = _this12[RENDERER]).simulateEvent.apply(_RENDERER, [n, event].concat(args));

          _this12[ROOT].update();

          return _this12;
        });
      }

      return simulate;
    }()
    /**
     * Used to simulate throwing a rendering error. Pass an error to throw.
     *
     * @param {String} error
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'simulateError',
    value: function () {
      function simulateError(error) {
        var _this13 = this; // in shallow, the "root" is the "rendered" thing.


        return this.single('simulateError', function (thisNode) {
          if (thisNode.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');
          }

          var renderer = _this13[RENDERER];

          if (typeof renderer.simulateError !== 'function') {
            throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');
          }

          var rootNode = getRootNodeInternal(_this13);
          var nodeHierarchy = [thisNode].concat(nodeParents(_this13, thisNode));
          renderer.simulateError(nodeHierarchy, rootNode, error);
          return _this13;
        });
      }

      return simulateError;
    }()
    /**
     * Returns the props hash for the current node of the wrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {Object}
     */

  }, {
    key: 'props',
    value: function () {
      function props() {
        return this.single('props', _RSTTraversal.propsOfNode);
      }

      return props;
    }()
    /**
     * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it
     * will return just that value.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {String} name (optional)
     * @returns {*}
     */

  }, {
    key: 'state',
    value: function () {
      function state(name) {
        var _this14 = this;

        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::state() can only be called on the root');
        }

        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
          throw new Error('ShallowWrapper::state() can only be called on class components');
        }

        var _state = this.single('state', function () {
          return _this14.instance().state;
        });

        if (typeof name !== 'undefined') {
          if (_state == null) {
            throw new TypeError('ShallowWrapper::state("' + String(name) + '") requires that `state` not be `null` or `undefined`');
          }

          return _state[name];
        }

        return _state;
      }

      return state;
    }()
    /**
     * Returns the context hash for the root node of the wrapper.
     * Optionally pass in a prop name and it will return just that value.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {String} name (optional)
     * @returns {*}
     */

  }, {
    key: 'context',
    value: function () {
      function context(name) {
        var _this15 = this;

        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::context() can only be called on the root');
        }

        if (!this[OPTIONS].context) {
          throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');
        }

        if (this.instance() === null) {
          throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');
        }

        var _context = this.single('context', function () {
          return _this15.instance().context;
        });

        if (name) {
          return _context[name];
        }

        return _context;
      }

      return context;
    }()
    /**
     * Returns a new wrapper with all of the children of the current wrapper.
     *
     * @param {EnzymeSelector} [selector]
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'children',
    value: function () {
      function children(selector) {
        var allChildren = this.flatMap(function (n) {
          return (0, _RSTTraversal.childrenOfNode)(n.getNodeInternal());
        });
        return selector ? allChildren.filter(selector) : allChildren;
      }

      return children;
    }()
    /**
     * Returns a new wrapper with a specific child
     *
     * @param {Number} [index]
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'childAt',
    value: function () {
      function childAt(index) {
        var _this16 = this;

        return this.single('childAt', function () {
          return _this16.children().at(index);
        });
      }

      return childAt;
    }()
    /**
     * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node
     * in the current wrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {EnzymeSelector} [selector]
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'parents',
    value: function () {
      function parents(selector) {
        var _this17 = this;

        return this.single('parents', function (n) {
          var allParents = _this17.wrap(nodeParents(_this17, n));

          return selector ? allParents.filter(selector) : allParents;
        });
      }

      return parents;
    }()
    /**
     * Returns a wrapper around the immediate parent of the current node.
     *
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'parent',
    value: function () {
      function parent() {
        return this.flatMap(function (n) {
          return [n.parents().get(0)];
        });
      }

      return parent;
    }()
    /**
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'closest',
    value: function () {
      function closest(selector) {
        if (this.is(selector)) {
          return this;
        }

        var matchingAncestors = this.parents().filter(selector);
        return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(function () {
          return false;
        });
      }

      return closest;
    }()
    /**
     * Shallow renders the current node and returns a shallow wrapper around it.
     *
     * NOTE: can only be called on wrapper of a single node.
     *
     * @param {Object} options
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'shallow',
    value: function () {
      function shallow() {
        var _this18 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.single('shallow', function (n) {
          var childOptions = makeInheritedChildOptions(_this18, options);
          return _this18.wrap((0, _getAdapter2['default'])(_this18[OPTIONS]).nodeToElement(n), null, childOptions);
        });
      }

      return shallow;
    }()
    /**
     * Returns the value of prop with the given name of the current node.
     *
     * @param propName
     * @returns {*}
     */

  }, {
    key: 'prop',
    value: function () {
      function prop(propName) {
        return this.props()[propName];
      }

      return prop;
    }()
    /**
     * Used to invoke a function prop.
     * Will invoke an function prop and return its value.
     *
     * @param {String} propName
     * @returns {Any}
     */

  }, {
    key: 'invoke',
    value: function () {
      function invoke(propName) {
        var _this19 = this;

        return this.single('invoke', function () {
          var handler = _this19.prop(propName);

          if (typeof handler !== 'function') {
            throw new TypeError('ShallowWrapper::invoke() requires the name of a prop whose value is a function');
          }

          return function () {
            var response = handler.apply(undefined, arguments);

            _this19[ROOT].update();

            return response;
          };
        });
      }

      return invoke;
    }()
    /**
     * Returns a wrapper of the node rendered by the provided render prop.
     *
     * @param {String} propName
     * @returns {Function}
     */

  }, {
    key: 'renderProp',
    value: function () {
      function renderProp(propName) {
        var _this20 = this;

        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);

        if (typeof adapter.wrap !== 'function') {
          throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');
        }

        return this.single('renderProp', function (n) {
          if (n.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::renderProp() can only be called on custom components');
          }

          if (typeof propName !== 'string') {
            throw new TypeError('ShallowWrapper::renderProp(): `propName` must be a string');
          }

          var props = _this20.props();

          if (!(0, _has2['default'])(props, propName)) {
            throw new Error('ShallowWrapper::renderProp(): no prop called \u201C' + String(propName) + '\u201C found');
          }

          var propValue = props[propName];

          if (typeof propValue !== 'function') {
            throw new TypeError('ShallowWrapper::renderProp(): expected prop \u201C' + String(propName) + '\u201C to contain a function, but it holds \u201C' + (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) + '\u201C');
          }

          return function () {
            var element = propValue.apply(undefined, arguments);
            var wrapped = adapter.wrap(element);
            return _this20.wrap(wrapped, null, _this20[OPTIONS]);
          };
        });
      }

      return renderProp;
    }()
    /**
     * Returns the key assigned to the current node.
     *
     * @returns {String}
     */

  }, {
    key: 'key',
    value: function () {
      function key() {
        return this.single('key', function (n) {
          return n.key === undefined ? null : n.key;
        });
      }

      return key;
    }()
    /**
     * Returns the type of the current node of this wrapper. If it's a composite component, this will
     * be the component constructor. If it's a native DOM node, it will be a string of the tag name.
     * If it's null, it will be null.
     *
     * @returns {String|Function|null}
     */

  }, {
    key: 'type',
    value: function () {
      function type() {
        return this.single('type', function (n) {
          return (0, _Utils.typeOfNode)(n);
        });
      }

      return type;
    }()
    /**
     * Returns the name of the current node of this wrapper.
     *
     * In order of precedence => type.displayName -> type.name -> type.
     *
     * @returns {String}
     */

  }, {
    key: 'name',
    value: function () {
      function name() {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        return this.single('name', function (n) {
          return adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : (0, _Utils.displayNameOfNode)(n);
        });
      }

      return name;
    }()
    /**
     * Returns whether or not the current node has the given class name or not.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param className
     * @returns {Boolean}
     */

  }, {
    key: 'hasClass',
    value: function () {
      function hasClass(className) {
        if (typeof className === 'string' && className.indexOf('.') !== -1) {
          // eslint-disable-next-line no-console
          console.warn('It looks like you\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');
        }

        return this.single('hasClass', function (n) {
          return (0, _RSTTraversal.hasClassName)(n, className);
        });
      }

      return hasClass;
    }()
    /**
     * Iterates through each node of the current wrapper and executes the provided function with a
     * wrapper around the corresponding node passed in as the first argument.
     *
     * @param {Function} fn
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'forEach',
    value: function () {
      function forEach(fn) {
        var _this21 = this;

        this.getNodesInternal().forEach(function (n, i) {
          return fn.call(_this21, _this21.wrap(n), i);
        });
        return this;
      }

      return forEach;
    }()
    /**
     * Maps the current array of nodes to another array. Each node is passed in as a `ShallowWrapper`
     * to the map function.
     *
     * @param {Function} fn
     * @returns {Array}
     */

  }, {
    key: 'map',
    value: function () {
      function map(fn) {
        var _this22 = this;

        return this.getNodesInternal().map(function (n, i) {
          return fn.call(_this22, _this22.wrap(n), i);
        });
      }

      return map;
    }()
    /**
     * Reduces the current array of nodes to a value. Each node is passed in as a `ShallowWrapper`
     * to the reducer function.
     *
     * @param {Function} fn - the reducer function
     * @param {*} initialValue - the initial value
     * @returns {*}
     */

  }, {
    key: 'reduce',
    value: function () {
      function reduce(fn) {
        var _this23 = this;

        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (arguments.length > 1) {
          return this.getNodesInternal().reduce(function (accum, n, i) {
            return fn.call(_this23, accum, _this23.wrap(n), i);
          }, initialValue);
        }

        return this.getNodesInternal().reduce(function (accum, n, i) {
          return fn.call(_this23, i === 1 ? _this23.wrap(accum) : accum, _this23.wrap(n), i);
        });
      }

      return reduce;
    }()
    /**
     * Reduces the current array of nodes to another array, from right to left. Each node is passed
     * in as a `ShallowWrapper` to the reducer function.
     *
     * @param {Function} fn - the reducer function
     * @param {*} initialValue - the initial value
     * @returns {*}
     */

  }, {
    key: 'reduceRight',
    value: function () {
      function reduceRight(fn) {
        var _this24 = this;

        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (arguments.length > 1) {
          return this.getNodesInternal().reduceRight(function (accum, n, i) {
            return fn.call(_this24, accum, _this24.wrap(n), i);
          }, initialValue);
        }

        return this.getNodesInternal().reduceRight(function (accum, n, i) {
          return fn.call(_this24, i === 1 ? _this24.wrap(accum) : accum, _this24.wrap(n), i);
        });
      }

      return reduceRight;
    }()
    /**
     * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the
     * rules of `Array#slice`.
     *
     * @param {Number} begin
     * @param {Number} end
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'slice',
    value: function () {
      function slice(begin, end) {
        return this.wrap(this.getNodesInternal().slice(begin, end));
      }

      return slice;
    }()
    /**
     * Returns whether or not any of the nodes in the wrapper match the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {Boolean}
     */

  }, {
    key: 'some',
    value: function () {
      function some(selector) {
        if (this[ROOT] === this) {
          throw new Error('ShallowWrapper::some() can not be called on the root');
        }

        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.getNodesInternal().some(predicate);
      }

      return some;
    }()
    /**
     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
     *
     * @param {Function} predicate
     * @returns {Boolean}
     */

  }, {
    key: 'someWhere',
    value: function () {
      function someWhere(predicate) {
        var _this25 = this;

        return this.getNodesInternal().some(function (n, i) {
          return predicate.call(_this25, _this25.wrap(n), i);
        });
      }

      return someWhere;
    }()
    /**
     * Returns whether or not all of the nodes in the wrapper match the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {Boolean}
     */

  }, {
    key: 'every',
    value: function () {
      function every(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.getNodesInternal().every(predicate);
      }

      return every;
    }()
    /**
     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
     *
     * @param {Function} predicate
     * @returns {Boolean}
     */

  }, {
    key: 'everyWhere',
    value: function () {
      function everyWhere(predicate) {
        var _this26 = this;

        return this.getNodesInternal().every(function (n, i) {
          return predicate.call(_this26, _this26.wrap(n), i);
        });
      }

      return everyWhere;
    }()
    /**
     * Utility method used to create new wrappers with a mapping function that returns an array of
     * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around
     * all of the mapped nodes flattened (and de-duplicated).
     *
     * @param {Function} fn
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'flatMap',
    value: function () {
      function flatMap(fn) {
        var _this27 = this;

        var nodes = this.getNodesInternal().map(function (n, i) {
          return fn.call(_this27, _this27.wrap(n), i);
        });
        var flattened = (0, _arrayPrototype2['default'])(nodes, 1);
        return this.wrap(flattened.filter(Boolean));
      }

      return flatMap;
    }()
    /**
     * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate
     * function. The predicate function will receive the nodes inside a ShallowWrapper as its
     * first argument.
     *
     * @param {Function} predicate
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'findWhere',
    value: function () {
      function findWhere(predicate) {
        var _this28 = this;

        return findWhereUnwrapped(this, function (n) {
          var node = _this28.wrap(n);

          return node.length > 0 && predicate(node);
        });
      }

      return findWhere;
    }()
    /**
     * Returns the node at a given index of the current wrapper.
     *
     * @param index
     * @returns {ReactElement}
     */

  }, {
    key: 'get',
    value: function () {
      function get(index) {
        return this.getElements()[index];
      }

      return get;
    }()
    /**
     * Returns a wrapper around the node at a given index of the current wrapper.
     *
     * @param index
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'at',
    value: function () {
      function at(index) {
        var nodes = this.getNodesInternal();

        if (index < nodes.length) {
          return this.wrap(nodes[index]);
        }

        return this.wrap([]);
      }

      return at;
    }()
    /**
     * Returns a wrapper around the first node of the current wrapper.
     *
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'first',
    value: function () {
      function first() {
        return this.at(0);
      }

      return first;
    }()
    /**
     * Returns a wrapper around the last node of the current wrapper.
     *
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'last',
    value: function () {
      function last() {
        return this.at(this.length - 1);
      }

      return last;
    }()
    /**
     * Delegates to exists()
     *
     * @returns {boolean}
     */

  }, {
    key: 'isEmpty',
    value: function () {
      function isEmpty() {
        // eslint-disable-next-line no-console
        console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');
        return !this.exists();
      }

      return isEmpty;
    }()
    /**
     * Returns true if the current wrapper has nodes. False otherwise.
     * If called with a selector it returns `.find(selector).exists()` instead.
     *
     * @param {EnzymeSelector} selector (optional)
     * @returns {boolean}
     */

  }, {
    key: 'exists',
    value: function () {
      function exists() {
        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;
      }

      return exists;
    }()
    /**
     * Utility method that throws an error if the current instance has a length other than one.
     * This is primarily used to enforce that certain methods are only run on a wrapper when it is
     * wrapping a single node.
     *
     * @param fn
     * @returns {*}
     */

  }, {
    key: 'single',
    value: function () {
      function single(name, fn) {
        var fnName = typeof name === 'string' ? name : 'unknown';
        var callback = typeof fn === 'function' ? fn : name;

        if (this.length !== 1) {
          throw new Error('Method \u201C' + fnName + '\u201D is meant to be run on 1 node. ' + String(this.length) + ' found instead.');
        }

        return callback.call(this, this.getNodeInternal());
      }

      return single;
    }()
    /**
     * Helpful utility method to create a new wrapper with the same root as the current wrapper, with
     * any nodes passed in as the first parameter automatically wrapped.
     *
     * @param node
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'wrap',
    value: function () {
      function wrap(node) {
        var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[ROOT];

        if (node instanceof ShallowWrapper) {
          return node;
        }

        for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          args[_key3 - 2] = arguments[_key3];
        }

        return new (Function.prototype.bind.apply(ShallowWrapper, [null].concat([node, root], args)))();
      }

      return wrap;
    }()
    /**
     * Returns an HTML-like string of the shallow render for debugging purposes.
     *
     * @param {Object} [options] - Property bag of additional options.
     * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.
     * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.
     * @returns {String}
     */

  }, {
    key: 'debug',
    value: function () {
      function debug() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return (0, _Debug.debugNodes)(this.getNodesInternal(), options);
      }

      return debug;
    }()
    /**
     * Invokes intercepter and returns itself. intercepter is called with itself.
     * This is helpful when debugging nodes in method chains.
     * @param fn
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'tap',
    value: function () {
      function tap(intercepter) {
        intercepter(this);
        return this;
      }

      return tap;
    }()
    /**
     * Primarily useful for HOCs (higher-order components), this method may only be
     * run on a single, non-DOM node, and will return the node, shallow-rendered.
     *
     * @param {Object} options
     * @returns {ShallowWrapper}
     */

  }, {
    key: 'dive',
    value: function () {
      function dive() {
        var _this29 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        var name = 'dive';
        return this.single(name, function (n) {
          if (n && n.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::' + name + '() can not be called on Host Components');
          }

          var el = (0, _getAdapter2['default'])(_this29[OPTIONS]).nodeToElement(n);

          if (!(0, _Utils.isCustomComponentElement)(el, adapter)) {
            throw new TypeError('ShallowWrapper::' + name + '() can only be called on components');
          }

          var childOptions = makeInheritedChildOptions(_this29, options);
          return _this29.wrap(el, null, childOptions);
        });
      }

      return dive;
    }()
    /**
     * Strips out all the not host-nodes from the list of nodes
     *
     * This method is useful if you want to check for the presence of host nodes
     * (actually rendered HTML elements) ignoring the React nodes.
     */

  }, {
    key: 'hostNodes',
    value: function () {
      function hostNodes() {
        return this.filterWhere(function (n) {
          return typeof n.type() === 'string';
        });
      }

      return hostNodes;
    }()
  }]);

  return ShallowWrapper;
}();
/**
 * Updates the context of the primary wrapper when the
 * `wrappingComponent` re-renders.
 */


function updatePrimaryRootContext(wrappingComponent) {
  var adapter = (0, _getAdapter2['default'])(wrappingComponent[OPTIONS]);
  var primaryWrapper = wrappingComponent[PRIMARY_WRAPPER];
  var primaryRenderer = primaryWrapper[RENDERER];
  var primaryNode = primaryRenderer.getNode();

  var _getContextFromWrappi2 = getContextFromWrappingComponent(wrappingComponent, adapter),
      legacyContext = _getContextFromWrappi2.legacyContext,
      providerValues = _getContextFromWrappi2.providerValues;

  var prevProviderValues = primaryWrapper[PROVIDER_VALUES];
  primaryWrapper.setContext((0, _object2['default'])({}, wrappingComponent[PRIMARY_WRAPPER][OPTIONS].context, legacyContext));
  primaryWrapper[PROVIDER_VALUES] = new Map([].concat(_toConsumableArray(prevProviderValues), _toConsumableArray(providerValues)));

  if (typeof adapter.isContextConsumer === 'function' && adapter.isContextConsumer(primaryNode.type)) {
    var Consumer = primaryNode.type; // Adapters with an `isContextConsumer` method will definitely have a `getProviderFromConsumer`
    // method.

    var Provider = adapter.getProviderFromConsumer(Consumer);
    var newValue = providerValues.get(Provider);
    var oldValue = prevProviderValues.get(Provider); // Use referential comparison like React

    if (newValue !== oldValue) {
      primaryWrapper.rerender();
    }
  }
}
/**
 * A *special* "root" wrapper that represents the component passed as `wrappingComponent`.
 * It is linked to the primary root such that updates to it will update the primary.
 *
 * @class WrappingComponentWrapper
 */


var WrappingComponentWrapper = function (_ShallowWrapper) {
  _inherits(WrappingComponentWrapper, _ShallowWrapper);

  function WrappingComponentWrapper(nodes, root, RootFinder) {
    _classCallCheck(this, WrappingComponentWrapper);

    var _this30 = _possibleConstructorReturn(this, (WrappingComponentWrapper.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper)).call(this, nodes));

    (0, _Utils.privateSet)(_this30, PRIMARY_WRAPPER, root);
    (0, _Utils.privateSet)(_this30, ROOT_FINDER, RootFinder);
    return _this30;
  }
  /**
   * Like rerender() on ShallowWrapper, except it also does a "full render" of
   * itself and updates the primary ShallowWrapper's context.
   */


  _createClass(WrappingComponentWrapper, [{
    key: 'rerender',
    value: function () {
      function rerender() {
        var _get2;

        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        var result = (_get2 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'rerender', this)).call.apply(_get2, [this].concat(args));

        updatePrimaryRootContext(this);
        return result;
      }

      return rerender;
    }()
    /**
     * Like setState() on ShallowWrapper, except it also does a "full render" of
     * itself and updates the primary ShallowWrapper's context.
     */

  }, {
    key: 'setState',
    value: function () {
      function setState() {
        var _get3;

        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var result = (_get3 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'setState', this)).call.apply(_get3, [this].concat(args));

        updatePrimaryRootContext(this);
        return result;
      }

      return setState;
    }() // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'getWrappingComponent',
    value: function () {
      function getWrappingComponent() {
        throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');
      }

      return getWrappingComponent;
    }()
  }]);

  return WrappingComponentWrapper;
}(ShallowWrapper);

if (_Utils.ITERATOR_SYMBOL) {
  Object.defineProperty(ShallowWrapper.prototype, _Utils.ITERATOR_SYMBOL, {
    configurable: true,
    value: function () {
      function iterator() {
        var _ref2;

        var iter = this.getNodesInternal()[_Utils.ITERATOR_SYMBOL]();

        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        return _ref2 = {}, _defineProperty(_ref2, _Utils.ITERATOR_SYMBOL, function () {
          return this;
        }), _defineProperty(_ref2, 'next', function () {
          function next() {
            var next = iter.next();

            if (next.done) {
              return {
                done: true
              };
            }

            return {
              done: false,
              value: adapter.nodeToElement(next.value)
            };
          }

          return next;
        }()), _ref2;
      }

      return iterator;
    }()
  });
}

function privateWarning(prop, extraMessage) {
  Object.defineProperty(ShallowWrapper.prototype, prop, {
    get: function () {
      function get() {
        throw new Error('\n        Attempted to access ShallowWrapper::' + String(prop) + ', which was previously a private property on\n        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.\n        ' + String(extraMessage) + '\n      ');
      }

      return get;
    }(),
    enumerable: false,
    configurable: false
  });
}

privateWarning('node', 'Consider using the getElement() method instead.');
privateWarning('nodes', 'Consider using the getElements() method instead.');
privateWarning('renderer', '');
privateWarning('options', '');
privateWarning('complexSelector', '');
exports['default'] = ShallowWrapper; //# sourceMappingURL=ShallowWrapper.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TaGFsbG93V3JhcHBlci5qcyJdLCJuYW1lcyI6WyJOT0RFIiwiTk9ERVMiLCJSRU5ERVJFUiIsIlVOUkVOREVSRUQiLCJST09UIiwiT1BUSU9OUyIsIlNFVF9TVEFURSIsIlJPT1RfTk9ERVMiLCJDSElMRF9DT05URVhUIiwiV1JBUFBJTkdfQ09NUE9ORU5UIiwiUFJJTUFSWV9XUkFQUEVSIiwiUk9PVF9GSU5ERVIiLCJQUk9WSURFUl9WQUxVRVMiLCJmaWx0ZXIiLCJ0cmVlRmlsdGVyIiwibiIsIndyYXBwZXIiLCJsaWZlY3ljbGVFeHBlcmltZW50YWwiLCJkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyIsImVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUiLCJzdXBwb3J0UHJldkNvbnRleHRBcmd1bWVudE9mQ29tcG9uZW50RGlkVXBkYXRlIiwibGlmZWN5Y2xlcyIsIm9wdGlvbnMiLCJoYXNMZWdhY3lTZXRTdGF0ZUFyZyIsImhhc0xlZ2FjeVByZXZDb250ZXh0QXJnIiwiY29tcG9uZW50RGlkVXBkYXRlIiwib25TZXRTdGF0ZSIsInByZXZDb250ZXh0Iiwib3JpZ2luYWxHRFNGUCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyIsInNldFN0YXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsIm5vZGUiLCJnZXRSb290Tm9kZUludGVybmFsIiwiQXJyYXkiLCJub2RlcyIsImluc3RhbmNlIiwiQ29tcG9uZW50IiwiY29tcG9uZW50TmFtZSIsImNvbnNvbGUiLCJjaGlsZENvbnRleHQiLCJPYmplY3QiLCJrZXkiLCJyZW5kZXJlciIsImFkYXB0ZXIiLCJnZXRDaGlsZENvbnRleHRTcHkiLCJub2RlSGllcmFyY2h5Iiwibm9kZVBhcmVudHMiLCJyZXN0b3JlIiwiYXJncyIsInNDVVJlc3VsdCIsIm9yaWdpbmFsU0NVIiwibmV4dFN0YXRlIiwiZWxlbWVudCIsImRlZXBSZW5kZXIiLCJjaGlsZHJlbiIsImkiLCJmb3VuZCIsInJvb3RGaW5kZXIiLCJsZWdhY3lDb250ZXh0IiwicHJvdmlkZXJWYWx1ZXMiLCJwYXNzZWRPcHRpb25zIiwicm9vdCIsIndyYXBwZWROb2RlIiwiUm9vdEZpbmRlciIsIndyYXBwaW5nQ29tcG9uZW50Iiwid3JhcHBpbmdDb21wb25lbnRMZWdhY3lDb250ZXh0Iiwid3JhcHBpbmdDb21wb25lbnRQcm92aWRlclZhbHVlcyIsImdldENvbnRleHRGcm9tV3JhcHBpbmdDb21wb25lbnQiLCJjb250ZXh0IiwiU2hhbGxvd1dyYXBwZXIiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJtYWtlU2hhbGxvd09wdGlvbnMiLCJnZXRBZGFwdGVyTGlmZWN5Y2xlcyIsInNweU9uR2V0Q2hpbGRDb250ZXh0SW5pdGlhbFJlbmRlciIsIm1vZGUiLCJyZW5kZXJlZE5vZGUiLCJwcml2YXRlU2V0Tm9kZXMiLCJnZXRSb290Tm9kZSIsImNhbGxiYWNrIiwicHJpdmF0ZVNldENoaWxkQ29udGV4dCIsInByb3BzIiwidHlwZSIsInN0YXRlIiwicHJldlByb3BzIiwibmV4dENvbnRleHQiLCJzaG91bGRSZW5kZXIiLCJzaG91bGRDb21wb25lbnRVcGRhdGVTcHkiLCJnRFNGUCIsIm1vY2tTQ1VJZmdEU0ZQUmV0dXJuTm9uTnVsbCIsImlzUHVyZUNvbXBvbmVudCIsInB1cmVDb21wb25lbnRTaG91bGRDb21wb25lbnRVcGRhdGUiLCJzbmFwc2hvdCIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsInByZXZTdGF0ZSIsInN0YXRlUGF5bG9hZCIsIm1heWJlSGFzVXBkYXRlIiwibm9kZU9yTm9kZXMiLCJwcmVkaWNhdGUiLCJub2RlRXF1YWwiLCJmaW5kV2hlcmVVbndyYXBwZWQiLCJyc3ROb2RlIiwiYSIsInNlbGVjdG9yIiwiZmlsdGVyV2hlcmVVbndyYXBwZWQiLCJnZXRUZXh0RnJvbU5vZGUiLCJodG1sIiwiZXZlbnQiLCJlcnJvciIsInRoaXNOb2RlIiwicm9vdE5vZGUiLCJwcm9wc09mTm9kZSIsIm5hbWUiLCJfc3RhdGUiLCJfY29udGV4dCIsImFsbENoaWxkcmVuIiwiaW5kZXgiLCJhbGxQYXJlbnRzIiwibWF0Y2hpbmdBbmNlc3RvcnMiLCJjaGlsZE9wdGlvbnMiLCJtYWtlSW5oZXJpdGVkQ2hpbGRPcHRpb25zIiwicHJvcE5hbWUiLCJoYW5kbGVyIiwicmVzcG9uc2UiLCJwcm9wVmFsdWUiLCJ3cmFwcGVkIiwiY2xhc3NOYW1lIiwiZm4iLCJpbml0aWFsVmFsdWUiLCJiZWdpbiIsImVuZCIsImZsYXR0ZW5lZCIsImZuTmFtZSIsImludGVyY2VwdGVyIiwiZWwiLCJwcmltYXJ5V3JhcHBlciIsInByaW1hcnlSZW5kZXJlciIsInByaW1hcnlOb2RlIiwicHJldlByb3ZpZGVyVmFsdWVzIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXIiLCJyZXN1bHQiLCJ1cGRhdGVQcmltYXJ5Um9vdENvbnRleHQiLCJJVEVSQVRPUl9TWU1CT0wiLCJjb25maWd1cmFibGUiLCJ2YWx1ZSIsIml0ZXIiLCJuZXh0IiwiZG9uZSIsImdldCIsImVudW1lcmFibGUiLCJwcml2YXRlV2FybmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBQSxlQUFBLEdBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUE7Ozs7QUFDQSxJQUFBLElBQUEsR0FBQSxPQUFBLENBQUEsS0FBQSxDQUFBOzs7O0FBQ0EsSUFBQSxtQkFBQSxHQUFBLE9BQUEsQ0FBQSxzQkFBQSxDQUFBOzs7O0FBRUEsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFtQkEsSUFBQSxXQUFBLEdBQUEsT0FBQSxDQUFBLGNBQUEsQ0FBQTs7OztBQUNBLElBQUEsTUFBQSxHQUFBLE9BQUEsQ0FBQSxTQUFBLENBQUE7O0FBQ0EsSUFB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QUFBLEtBQUEsQ0FBQSxtREFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsa0pBQUEsR0FBQSxNQUFBLENBQUEsWUFBQSxDQUFBLEdBQU4sVUFBTSxDQUFOO0FBS0Q7O0FBUG1ELGFBQUEsR0FBQTtBQUFBLEtBQUEsRUFBQTtBQVFwREMsSUFBQUEsVUFBQUEsRUFSb0QsS0FBQTtBQVNwRE4sSUFBQUEsWUFBQUEsRUFBYztBQVRzQyxHQUF0RDNHO0FBV0Q7O0FBRURrSCxjQUFBQSxDQUFBQSxNQUFBQSxFQUFBQSxpREFBQUEsQ0FBQUE7QUFDQUEsY0FBQUEsQ0FBQUEsT0FBQUEsRUFBQUEsa0RBQUFBLENBQUFBO0FBQ0FBLGNBQUFBLENBQUFBLFVBQUFBLEVBQUFBLEVBQUFBLENBQUFBO0FBQ0FBLGNBQUFBLENBQUFBLFNBQUFBLEVBQUFBLEVBQUFBLENBQUFBO0FBQ0FBLGNBQUFBLENBQUFBLGlCQUFBQSxFQUFBQSxFQUFBQSxDQUFBQTtxQkFFZXJGLGMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmxhdCBmcm9tICdhcnJheS5wcm90b3R5cGUuZmxhdCc7XG5pbXBvcnQgaGFzIGZyb20gJ2hhcyc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ2VuenltZS1zaGFsbG93LWVxdWFsJztcblxuaW1wb3J0IHtcbiAgbm9kZUVxdWFsLFxuICBub2RlTWF0Y2hlcyxcbiAgY29udGFpbnNDaGlsZHJlblN1YkFycmF5LFxuICB3aXRoU2V0U3RhdGVBbGxvd2VkLFxuICB0eXBlT2ZOb2RlLFxuICBpc1JlYWN0RWxlbWVudEFsaWtlLFxuICBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgaXNDdXN0b21Db21wb25lbnQsXG4gIGlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudCxcbiAgSVRFUkFUT1JfU1lNQk9MLFxuICBtYWtlT3B0aW9ucyxcbiAgc3ltLFxuICBwcml2YXRlU2V0LFxuICBjbG9uZUVsZW1lbnQsXG4gIHNweU1ldGhvZCxcbiAgaXNFbXB0eVZhbHVlLFxuICBsb2FkQ2hlZXJpb1Jvb3QsXG59IGZyb20gJy4vVXRpbHMnO1xuaW1wb3J0IGdldEFkYXB0ZXIgZnJvbSAnLi9nZXRBZGFwdGVyJztcbmltcG9ydCB7IGRlYnVnTm9kZXMgfSBmcm9tICcuL0RlYnVnJztcbmltcG9ydCB7XG4gIHByb3BzT2ZOb2RlLFxuICBnZXRUZXh0RnJvbU5vZGUsXG4gIGhhc0NsYXNzTmFtZSxcbiAgY2hpbGRyZW5PZk5vZGUsXG4gIHBhcmVudHNPZk5vZGUsXG4gIHRyZWVGaWx0ZXIsXG59IGZyb20gJy4vUlNUVHJhdmVyc2FsJztcbmltcG9ydCB7IGJ1aWxkUHJlZGljYXRlLCByZWR1Y2VUcmVlc0J5U2VsZWN0b3IgfSBmcm9tICcuL3NlbGVjdG9ycyc7XG5cbmNvbnN0IE5PREUgPSBzeW0oJ19fbm9kZV9fJyk7XG5jb25zdCBOT0RFUyA9IHN5bSgnX19ub2Rlc19fJyk7XG5jb25zdCBSRU5ERVJFUiA9IHN5bSgnX19yZW5kZXJlcl9fJyk7XG5jb25zdCBVTlJFTkRFUkVEID0gc3ltKCdfX3VucmVuZGVyZWRfXycpO1xuY29uc3QgUk9PVCA9IHN5bSgnX19yb290X18nKTtcbmNvbnN0IE9QVElPTlMgPSBzeW0oJ19fb3B0aW9uc19fJyk7XG5jb25zdCBTRVRfU1RBVEUgPSBzeW0oJ19fc2V0U3RhdGVfXycpO1xuY29uc3QgUk9PVF9OT0RFUyA9IHN5bSgnX19yb290Tm9kZXNfXycpO1xuY29uc3QgQ0hJTERfQ09OVEVYVCA9IHN5bSgnX19jaGlsZENvbnRleHRfXycpO1xuY29uc3QgV1JBUFBJTkdfQ09NUE9ORU5UID0gc3ltKCdfX3dyYXBwaW5nQ29tcG9uZW50X18nKTtcbmNvbnN0IFBSSU1BUllfV1JBUFBFUiA9IHN5bSgnX19wcmltYXJ5V3JhcHBlcl9fJyk7XG5jb25zdCBST09UX0ZJTkRFUiA9IHN5bSgnX19yb290RmluZGVyX18nKTtcbmNvbnN0IFBST1ZJREVSX1ZBTFVFUyA9IHN5bSgnX19wcm92aWRlclZhbHVlc19fJyk7XG5cbi8qKlxuICogRmluZHMgYWxsIG5vZGVzIGluIHRoZSBjdXJyZW50IHdyYXBwZXIgbm9kZXMnIHJlbmRlciB0cmVlcyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U2hhbGxvd1dyYXBwZXJ9IHdyYXBwZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRXaGVyZVVud3JhcHBlZCh3cmFwcGVyLCBwcmVkaWNhdGUsIGZpbHRlciA9IHRyZWVGaWx0ZXIpIHtcbiAgcmV0dXJuIHdyYXBwZXIuZmxhdE1hcCgobikgPT4gZmlsdGVyKG4uZ2V0Tm9kZUludGVybmFsKCksIHByZWRpY2F0ZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBtYXRjaFxuICogdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1NoYWxsb3dXcmFwcGVyfSB3cmFwcGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyV2hlcmVVbndyYXBwZWQod3JhcHBlciwgcHJlZGljYXRlKSB7XG4gIHJldHVybiB3cmFwcGVyLndyYXAod3JhcHBlci5nZXROb2Rlc0ludGVybmFsKCkuZmlsdGVyKHByZWRpY2F0ZSkuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgb3B0aW9ucyBwYXNzZWQgdG8gU2hhbGxvd1dyYXBwZXIgYXJlIHZhbGlkLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGxpZmVjeWNsZUV4cGVyaW1lbnRhbCxcbiAgICBkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyxcbiAgICBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlLFxuICAgIHN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUsXG4gICAgbGlmZWN5Y2xlcyxcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgbGlmZWN5Y2xlRXhwZXJpbWVudGFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbGlmZWN5Y2xlRXhwZXJpbWVudGFsICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpZmVjeWNsZUV4cGVyaW1lbnRhbCBtdXN0IGJlIGVpdGhlciB0cnVlIG9yIGZhbHNlIGlmIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRpc2FibGVMaWZlY3ljbGVNZXRob2RzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMgbXVzdCBiZSBlaXRoZXIgdHJ1ZSBvciBmYWxzZSBpZiBwcm92aWRlZCcpO1xuICB9XG5cbiAgaWYgKFxuICAgIGxpZmVjeWNsZUV4cGVyaW1lbnRhbCAhPSBudWxsXG4gICAgJiYgZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMgIT0gbnVsbFxuICAgICYmIGxpZmVjeWNsZUV4cGVyaW1lbnRhbCA9PT0gZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHNcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsaWZlY3ljbGVFeHBlcmltZW50YWwgYW5kIGRpc2FibGVMaWZlY3ljbGVNZXRob2RzIGNhbm5vdCBiZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWUnKTtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2YgZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZVxuICAgICYmIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlLm9uU2V0U3RhdGUgIT09IGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGVcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhlIGxlZ2FjeSBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlIG9wdGlvbiBzaG91bGQgYmUgbWF0Y2hlZCBieSBgbGlmZWN5Y2xlczogeyBjb21wb25lbnREaWRVcGRhdGU6IHsgb25TZXRTdGF0ZTogdHJ1ZSB9IH1gLCBmb3IgY29tcGF0aWJpbGl0eScpO1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBzdXBwb3J0UHJldkNvbnRleHRBcmd1bWVudE9mQ29tcG9uZW50RGlkVXBkYXRlICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgJiYgbGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGUucHJldkNvbnRleHQgIT09IHN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGVcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhlIGxlZ2FjeSBzdXBwb3J0UHJldkNvbnRleHRBcmd1bWVudE9mQ29tcG9uZW50RGlkVXBkYXRlIG9wdGlvbiBzaG91bGQgYmUgbWF0Y2hlZCBieSBgbGlmZWN5Y2xlczogeyBjb21wb25lbnREaWRVcGRhdGU6IHsgcHJldkNvbnRleHQ6IHRydWUgfSB9YCwgZm9yIGNvbXBhdGliaWxpdHknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBZGFwdGVyTGlmZWN5Y2xlcyh7IG9wdGlvbnMgfSkge1xuICBjb25zdCB7XG4gICAgbGlmZWN5Y2xlcyA9IHt9LFxuICAgIGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUsXG4gICAgc3VwcG9ydFByZXZDb250ZXh0QXJndW1lbnRPZkNvbXBvbmVudERpZFVwZGF0ZSxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgaGFzTGVnYWN5U2V0U3RhdGVBcmcgPSB0eXBlb2YgZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIGNvbnN0IGhhc0xlZ2FjeVByZXZDb250ZXh0QXJnID0gdHlwZW9mIHN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUgIT09ICd1bmRlZmluZWQnO1xuICBjb25zdCBjb21wb25lbnREaWRVcGRhdGUgPSBoYXNMZWdhY3lTZXRTdGF0ZUFyZyB8fCBoYXNMZWdhY3lQcmV2Q29udGV4dEFyZ1xuICAgID8ge1xuICAgICAgLi4uKGhhc0xlZ2FjeVNldFN0YXRlQXJnICYmIHtcbiAgICAgICAgb25TZXRTdGF0ZTogISFlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlLFxuICAgICAgfSksXG4gICAgICAuLi4oaGFzTGVnYWN5UHJldkNvbnRleHRBcmcgJiYge1xuICAgICAgICBwcmV2Q29udGV4dDogISFzdXBwb3J0UHJldkNvbnRleHRBcmd1bWVudE9mQ29tcG9uZW50RGlkVXBkYXRlLFxuICAgICAgfSksXG4gICAgfVxuICAgIDogbnVsbDtcbiAgY29uc3QgeyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IG9yaWdpbmFsR0RTRlAgfSA9IGxpZmVjeWNsZXM7XG4gIGNvbnN0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IG9yaWdpbmFsR0RTRlAgPyB7XG4gICAgaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnOiAhIW9yaWdpbmFsR0RTRlAuaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnLFxuICB9IDogZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5saWZlY3ljbGVzLFxuICAgIHNldFN0YXRlOiB7XG4gICAgICAuLi5saWZlY3ljbGVzLnNldFN0YXRlLFxuICAgIH0sXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiB7XG4gICAgICBjYWxsZWRCeVJlbmRlcmVyOiB0cnVlLFxuICAgICAgLi4ubGlmZWN5Y2xlcy5nZXRDaGlsZENvbnRleHQsXG4gICAgfSxcbiAgICAuLi4oY29tcG9uZW50RGlkVXBkYXRlICYmIHsgY29tcG9uZW50RGlkVXBkYXRlIH0pLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gJ2hvc3QnKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vZGUucmVuZGVyZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3ROb2RlSW50ZXJuYWwod3JhcHBlcikge1xuICBpZiAod3JhcHBlcltST09UXS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFJvb3ROb2RlSW50ZXJuYWwod3JhcHBlcikgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gd3JhcHBlciB3cmFwcyBvbmUgbm9kZScpO1xuICB9XG4gIGlmICh3cmFwcGVyW1JPT1RdICE9PSB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJbUk9PVF9OT0RFU11bMF07XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXJbUk9PVF1bTk9ERV07XG59XG5cbmZ1bmN0aW9uIG5vZGVQYXJlbnRzKHdyYXBwZXIsIG5vZGUpIHtcbiAgcmV0dXJuIHBhcmVudHNPZk5vZGUobm9kZSwgZ2V0Um9vdE5vZGVJbnRlcm5hbCh3cmFwcGVyKSk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVTZXROb2Rlcyh3cmFwcGVyLCBub2Rlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFLCBub2Rlcyk7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFUywgW25vZGVzXSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFLCBub2Rlc1swXSk7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFUywgbm9kZXMpO1xuICB9XG4gIHByaXZhdGVTZXQod3JhcHBlciwgJ2xlbmd0aCcsIHdyYXBwZXJbTk9ERVNdLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHB1cmVDb21wb25lbnRTaG91bGRDb21wb25lbnRVcGRhdGUocHJldlByb3BzLCBwcm9wcywgcHJldlN0YXRlLCBzdGF0ZSkge1xuICByZXR1cm4gIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIHByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKHByZXZTdGF0ZSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlLmlzUHVyZVJlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZENvbnRleHQobm9kZSwgaGllcmFyY2h5LCByZW5kZXJlcikge1xuICBjb25zdCB7IGluc3RhbmNlLCB0eXBlOiBDb21wb25lbnQgfSA9IG5vZGU7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZShub2RlKTtcbiAgLy8gV2FybiBsaWtlIHJlYWN0IGlmIGNoaWxkQ29udGV4dFR5cGVzIGlzIG5vdCBkZWZpbmVkOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi8xNDU0YThiZTAzNzk0ZjVlMGIyM2E3ZTc2OTZjYmJiZGNmOGIwZjVkL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2VydmVyL1JlYWN0UGFydGlhbFJlbmRlcmVyLmpzI0w2MzktTDY0NlxuICBpZiAodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGAke2NvbXBvbmVudE5hbWV9LmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLmAsXG4gICAgKTtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLy8gQ2hlY2sgY2hpbGRDb250ZXh0VHlwZXMgbGlrZSByZWFjdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMTQ1NGE4YmUwMzc5NGY1ZTBiMjNhN2U3Njk2Y2JiYmRjZjhiMGY1ZC9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NlcnZlci9SZWFjdFBhcnRpYWxSZW5kZXJlci5qcyNMNjMwLUw2MzdcbiAgY29uc3QgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gIE9iamVjdC5rZXlzKGNoaWxkQ29udGV4dCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tcG9uZW50TmFtZX0uZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiR7a2V5fVwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLmAsXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgcmVuZGVyZXIuY2hlY2tQcm9wVHlwZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZW5kZXJlci5jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBoaWVyYXJjaHkpO1xuICB9XG4gIHJldHVybiBjaGlsZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHNweU9uR2V0Q2hpbGRDb250ZXh0SW5pdGlhbFJlbmRlcihub2RlcywgYWRhcHRlcikge1xuICBpZiAoXG4gICAgIWlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudChub2RlcywgYWRhcHRlcilcbiAgICB8fCAhbm9kZXMudHlwZS5wcm90b3R5cGVcbiAgICB8fCB0eXBlb2Ygbm9kZXMudHlwZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHNweU1ldGhvZChub2Rlcy50eXBlLnByb3RvdHlwZSwgJ2dldENoaWxkQ29udGV4dCcpO1xufVxuXG5mdW5jdGlvbiBwcml2YXRlU2V0Q2hpbGRDb250ZXh0KGFkYXB0ZXIsIHdyYXBwZXIsIGluc3RhbmNlLCByZW5kZXJlZE5vZGUsIGdldENoaWxkQ29udGV4dFNweSkge1xuICBjb25zdCByZW5kZXJlciA9IHdyYXBwZXJbUkVOREVSRVJdO1xuICAvLyBXZSBvbmx5IHN1cHBvcnQgcGFyZW50LWJhc2VkIGNvbnRleHQuXG4gIGlmIChhZGFwdGVyLm9wdGlvbnMubGVnYWN5Q29udGV4dE1vZGUgIT09ICdwYXJlbnQnKSB7IHJldHVybjsgfVxuICBpZiAoZ2V0Q2hpbGRDb250ZXh0U3B5KSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBDSElMRF9DT05URVhULCBnZXRDaGlsZENvbnRleHRTcHkuZ2V0TGFzdFJldHVyblZhbHVlKCkpO1xuICAgIGdldENoaWxkQ29udGV4dFNweS5yZXN0b3JlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3B5IGJ1dCBnZXRDaGlsZENvbnRleHQgaXMgYSBmdW5jdGlvbiwgdGhhdCBtZWFucyBvdXIgcmVuZGVyZXJcbiAgICAvLyBpcyBub3QgZ29pbmcgdG8gY2FsbCBpdCBmb3IgdXMsIHNvIHdlIG5lZWQgdG8gY2FsbCBpdCBvdXJzZWx2ZXMuXG4gICAgY29uc3Qgbm9kZUhpZXJhcmNoeSA9IFt3cmFwcGVyW05PREVdXS5jb25jYXQobm9kZVBhcmVudHMod3JhcHBlciwgd3JhcHBlcltOT0RFXSkpO1xuICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGdldENoaWxkQ29udGV4dChyZW5kZXJlZE5vZGUsIG5vZGVIaWVyYXJjaHksIHJlbmRlcmVyKTtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIENISUxEX0NPTlRFWFQsIGNoaWxkQ29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBDSElMRF9DT05URVhULCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2NrU0NVSWZnRFNGUFJldHVybk5vbk51bGwobm9kZSwgc3RhdGUpIHtcbiAgY29uc3QgeyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfSA9IG5vZGUudHlwZTtcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdlIHRyeSB0byBmaXggYSBSZWFjdCBzaGFsbG93IHJlbmRlcmVyIGJ1ZyBoZXJlLlxuICAgIC8vIChmYWNlYm9vay9yZWFjdCMxNDYwNywgd2hpY2ggaGFzIGJlZW4gZml4ZWQgaW4gcmVhY3QgMTYuOCk6XG4gICAgLy8gd2hlbiBnRFNGUCByZXR1cm4gZGVyaXZlZCBzdGF0ZSwgaXQgd2lsbCBzZXQgaW5zdGFuY2Ugc3RhdGUgaW4gc2hhbGxvdyByZW5kZXJlciBiZWZvcmUgU0NVLFxuICAgIC8vIHRoaXMgd2lsbCBjYXVzZSBgdGhpcy5zdGF0ZWAgaW4gc0NVIGJlIHRoZSB1cGRhdGVkIHN0YXRlLCB3aGljaCBpcyB3cm9uZyBiZWhhdmlvci5cbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHdyYXAgc0NVIHRvIHBhc3MgdGhlIG9sZCBzdGF0ZSB0byBvcmlnaW5hbCBzQ1UuXG4gICAgY29uc3QgeyBpbnN0YW5jZSB9ID0gbm9kZTtcbiAgICBjb25zdCB7IHJlc3RvcmUgfSA9IHNweU1ldGhvZChcbiAgICAgIGluc3RhbmNlLFxuICAgICAgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXG4gICAgICAob3JpZ2luYWxTQ1UpID0+IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHNDVVJlc3VsdCA9IG9yaWdpbmFsU0NVLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgY29uc3QgWywgbmV4dFN0YXRlXSA9IGFyZ3M7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiBzQ1VSZXN1bHQ7XG4gICAgICB9LFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkaXZlKClzIGV2ZXJ5IGN1c3RvbSBjb21wb25lbnQgaW4gYSB3cmFwcGVyIHVudGlsXG4gKiB0aGUgdGFyZ2V0IGNvbXBvbmVudCBpcyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge1NoYWxsb3dXcmFwcGVyfSB3cmFwcGVyIEEgU2hhbGxvd1dyYXBwZXIgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGV9IHRhcmdldCBBIHJlYWN0IGN1c3RvbSBjb21wb25lbnQgdGhhdCwgd2hlbiBmb3VuZCwgd2lsbCBlbmQgcmVjdXJzaW9uXG4gKiBAcGFyYW0ge0FkYXB0ZXJ9IGFkYXB0ZXIgQW4gRW56eW1lIGFkYXB0ZXJcbiAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcnx1bmRlZmluZWR9IEEgU2hhbGxvd1dyYXBwZXIgZm9yIHRoZSB0YXJnZXQsIG9yXG4gKiAgdW5kZWZpbmVkIGlmIGl0IGNhbid0IGJlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGRlZXBSZW5kZXIod3JhcHBlciwgdGFyZ2V0LCBhZGFwdGVyKSB7XG4gIGNvbnN0IG5vZGUgPSB3cmFwcGVyW05PREVdO1xuICBjb25zdCBlbGVtZW50ID0gbm9kZSAmJiBhZGFwdGVyLm5vZGVUb0VsZW1lbnQobm9kZSk7XG4gIGlmICh3cmFwcGVyLnR5cGUoKSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuZGl2ZSgpO1xuICB9XG4gIGlmIChlbGVtZW50ICYmIGlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudChlbGVtZW50LCBhZGFwdGVyKSkge1xuICAgIHJldHVybiBkZWVwUmVuZGVyKHdyYXBwZXIuZGl2ZSgpLCB0YXJnZXQsIGFkYXB0ZXIpO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gd3JhcHBlci5jaGlsZHJlbigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZm91bmQgPSBkZWVwUmVuZGVyKGNoaWxkcmVuLmF0KGkpLCB0YXJnZXQsIGFkYXB0ZXIpO1xuICAgIGlmICh0eXBlb2YgZm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRGVlcC1yZW5kZXJzIHRoZSBgd3JhcHBpbmdDb21wb25lbnRgIGFuZCByZXR1cm5zIHRoZSBjb250ZXh0IHRoYXQgc2hvdWxkXG4gKiBiZSBhY2Nlc3NpYmxlIHRvIHRoZSBwcmltYXJ5IHdyYXBwZXIuXG4gKlxuICogQHBhcmFtIHtXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXJ9IHdyYXBwZXIgVGhlIGBXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXJgIGZvciBhXG4gKiAgYHdyYXBwaW5nQ29tcG9uZW50YFxuICogQHBhcmFtIHtBZGFwdGVyfSBhZGFwdGVyIEFuIEVuenltZSBhZGFwdGVyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbiBvYmplY3Qgb2YgbGVnYWN5IGNvbnRleHQgdmFsdWVzIGFuZCBhIE1hcCBvZlxuICogIGBjcmVhdGVDb250ZXh0KClgIFByb3ZpZGVyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dEZyb21XcmFwcGluZ0NvbXBvbmVudCh3cmFwcGVyLCBhZGFwdGVyKSB7XG4gIGNvbnN0IHJvb3RGaW5kZXIgPSBkZWVwUmVuZGVyKHdyYXBwZXIsIHdyYXBwZXJbUk9PVF9GSU5ERVJdLCBhZGFwdGVyKTtcbiAgaWYgKCFyb290RmluZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgd3JhcHBpbmdDb21wb25lbnRgIG11c3QgcmVuZGVyIGl0cyBjaGlsZHJlbiEnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZ2FjeUNvbnRleHQ6IHJvb3RGaW5kZXJbT1BUSU9OU10uY29udGV4dCxcbiAgICBwcm92aWRlclZhbHVlczogcm9vdEZpbmRlcltQUk9WSURFUl9WQUxVRVNdLFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2VzIG9wdGlvbnMgc3BlY2lmaWNhbGx5IGZvciBgU2hhbGxvd1dyYXBwZXJgLiBNb3N0IG9mIHRoZSBsb2dpYyBoZXJlIGlzIGFyb3VuZCByZW5kZXJpbmdcbiAqIGEgYHdyYXBwaW5nQ29tcG9uZW50YCAoaWYgb25lIHdhcyBwcm92aWRlZCkgYW5kIGFkZGluZyB0aGUgY2hpbGQgY29udGV4dCBvZiB0aGF0IGNvbXBvbmVudFxuICogdG8gYG9wdGlvbnMuY29udGV4dGAuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5vZGVzIHRoZSBub2RlcyBwYXNzZWQgdG8gYFNoYWxsb3dXcmFwcGVyYFxuICogQHBhcmFtIHtTaGFsbG93V3JhcHBlcn0gcm9vdCB0aGlzIGBTaGFsbG93V3JhcHBlcmAncyBwYXJlbnQuIElmIHRoaXMgaXMgcGFzc2VkLCBvcHRpb25zIGFyZVxuICogIG5vdCB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7Kn0gcGFzc2VkT3B0aW9ucyB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gYFNoYWxsb3dXcmFwcGVyYC5cbiAqIEBwYXJhbSB7Kn0gd3JhcHBlciB0aGUgYFNoYWxsb3dXcmFwcGVyYCBpdHNlbGZcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBkZWNvcmF0ZWQgYW5kIHRyYW5zZm9ybWVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gbWFrZVNoYWxsb3dPcHRpb25zKG5vZGVzLCByb290LCBwYXNzZWRPcHRpb25zLCB3cmFwcGVyKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBtYWtlT3B0aW9ucyhwYXNzZWRPcHRpb25zKTtcbiAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIocGFzc2VkT3B0aW9ucyk7XG4gIHByaXZhdGVTZXQob3B0aW9ucywgUFJPVklERVJfVkFMVUVTLCBwYXNzZWRPcHRpb25zW1BST1ZJREVSX1ZBTFVFU10pO1xuICBpZiAocm9vdCB8fCAhaXNDdXN0b21Db21wb25lbnQob3B0aW9ucy53cmFwcGluZ0NvbXBvbmVudCwgYWRhcHRlcikpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBpZiAodHlwZW9mIGFkYXB0ZXIud3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3lvdXIgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IGB3cmFwcGluZ0NvbXBvbmVudGAuIFRyeSB1cGdyYWRpbmcgaXQhJyk7XG4gIH1cbiAgY29uc3QgeyBub2RlOiB3cmFwcGVkTm9kZSwgUm9vdEZpbmRlciB9ID0gYWRhcHRlci53cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KG5vZGVzLCBvcHRpb25zKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHdyYXBwaW5nQ29tcG9uZW50ID0gbmV3IFdyYXBwaW5nQ29tcG9uZW50V3JhcHBlcih3cmFwcGVkTm9kZSwgd3JhcHBlciwgUm9vdEZpbmRlcik7XG4gIGNvbnN0IHtcbiAgICBsZWdhY3lDb250ZXh0OiB3cmFwcGluZ0NvbXBvbmVudExlZ2FjeUNvbnRleHQsXG4gICAgcHJvdmlkZXJWYWx1ZXM6IHdyYXBwaW5nQ29tcG9uZW50UHJvdmlkZXJWYWx1ZXMsXG4gIH0gPSBnZXRDb250ZXh0RnJvbVdyYXBwaW5nQ29tcG9uZW50KHdyYXBwaW5nQ29tcG9uZW50LCBhZGFwdGVyKTtcbiAgcHJpdmF0ZVNldCh3cmFwcGVyLCBXUkFQUElOR19DT01QT05FTlQsIHdyYXBwaW5nQ29tcG9uZW50KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLm9wdGlvbnMuY29udGV4dCxcbiAgICAgIC4uLndyYXBwaW5nQ29tcG9uZW50TGVnYWN5Q29udGV4dCxcbiAgICB9LFxuICAgIFtQUk9WSURFUl9WQUxVRVNdOiB3cmFwcGluZ0NvbXBvbmVudFByb3ZpZGVyVmFsdWVzLFxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VJbmhlcml0ZWRDaGlsZE9wdGlvbnMod3JhcHBlciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGNoaWxkT3B0aW9ucyA9IHtcbiAgICAuLi53cmFwcGVyW09QVElPTlNdLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8IHtcbiAgICAgIC4uLndyYXBwZXJbT1BUSU9OU10uY29udGV4dCxcbiAgICAgIC4uLndyYXBwZXJbUk9PVF1bQ0hJTERfQ09OVEVYVF0sXG4gICAgfSxcbiAgfTtcbiAgcHJpdmF0ZVNldChjaGlsZE9wdGlvbnMsIFBST1ZJREVSX1ZBTFVFUywgd3JhcHBlcltST09UXVtQUk9WSURFUl9WQUxVRVNdKTtcbiAgcmV0dXJuIGNoaWxkT3B0aW9ucztcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBTaGFsbG93V3JhcHBlclxuICovXG5jbGFzcyBTaGFsbG93V3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKG5vZGVzLCByb290LCBwYXNzZWRPcHRpb25zID0ge30pIHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMocGFzc2VkT3B0aW9ucyk7XG5cbiAgICBjb25zdCBvcHRpb25zID0gbWFrZVNoYWxsb3dPcHRpb25zKG5vZGVzLCByb290LCBwYXNzZWRPcHRpb25zLCB0aGlzKTtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcihvcHRpb25zKTtcbiAgICBjb25zdCBsaWZlY3ljbGVzID0gZ2V0QWRhcHRlckxpZmVjeWNsZXMoYWRhcHRlcik7XG5cbiAgICAvLyBtb3VudGluZyBhIFNoYWxsb3dSZW5kZXIgY29tcG9uZW50XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBpZiAoIWFkYXB0ZXIuaXNWYWxpZEVsZW1lbnQobm9kZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NoYWxsb3dXcmFwcGVyIGNhbiBvbmx5IHdyYXAgdmFsaWQgZWxlbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2V0Q2hpbGRDb250ZXh0U3B5ID0gbGlmZWN5Y2xlcy5nZXRDaGlsZENvbnRleHQuY2FsbGVkQnlSZW5kZXJlclxuICAgICAgICA/IHNweU9uR2V0Q2hpbGRDb250ZXh0SW5pdGlhbFJlbmRlcihub2RlcywgYWRhcHRlcilcbiAgICAgICAgOiBudWxsO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBST09ULCB0aGlzKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgVU5SRU5ERVJFRCwgbm9kZXMpO1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSBhZGFwdGVyLmNyZWF0ZVJlbmRlcmVyKHsgbW9kZTogJ3NoYWxsb3cnLCAuLi5vcHRpb25zIH0pO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBSRU5ERVJFUiwgcmVuZGVyZXIpO1xuICAgICAgY29uc3QgcHJvdmlkZXJWYWx1ZXMgPSBuZXcgTWFwKG9wdGlvbnNbUFJPVklERVJfVkFMVUVTXSB8fCBbXSk7XG4gICAgICB0aGlzW1JFTkRFUkVSXS5yZW5kZXIobm9kZXMsIG9wdGlvbnMuY29udGV4dCwgeyBwcm92aWRlclZhbHVlcyB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkTm9kZSA9IHRoaXNbUkVOREVSRVJdLmdldE5vZGUoKTtcbiAgICAgIHByaXZhdGVTZXROb2Rlcyh0aGlzLCBnZXRSb290Tm9kZShyZW5kZXJlZE5vZGUpKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFBST1ZJREVSX1ZBTFVFUywgcHJvdmlkZXJWYWx1ZXMpO1xuXG4gICAgICBjb25zdCB7IGluc3RhbmNlIH0gPSByZW5kZXJlZE5vZGU7XG4gICAgICBpZiAoaW5zdGFuY2UgJiYgIW9wdGlvbnMuZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRvIGNhbGwgY29tcG9uZW50RGlkVXBkYXRlIHdoZW4gaW5zdGFuY2Uuc2V0U3RhdGUgaXMgY2FsbGVkXG4gICAgICAgIGlmIChsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZS5vblNldFN0YXRlICYmICFpbnN0YW5jZVtTRVRfU1RBVEVdKSB7XG4gICAgICAgICAgcHJpdmF0ZVNldChpbnN0YW5jZSwgU0VUX1NUQVRFLCBpbnN0YW5jZS5zZXRTdGF0ZSk7XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0U3RhdGUgPSAodXBkYXRlciwgY2FsbGJhY2sgPSB1bmRlZmluZWQpID0+IHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICAuLi4oY2FsbGJhY2sgPT0gbnVsbCA/IFt1cGRhdGVyXSA6IFt1cGRhdGVyLCBjYWxsYmFja10pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tSRU5ERVJFUl0uYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcml2YXRlU2V0Q2hpbGRDb250ZXh0KGFkYXB0ZXIsIHRoaXMsIGluc3RhbmNlLCByZW5kZXJlZE5vZGUsIGdldENoaWxkQ29udGV4dFNweSk7XG4gICAgICB9XG4gICAgLy8gY3JlYXRpbmcgYSBjaGlsZCBjb21wb25lbnQgdGhyb3VnaCBlbnp5bWUncyBTaGFsbG93V3JhcHBlciBBUElzLlxuICAgIH0gZWxzZSB7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1QsIHJvb3QpO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBVTlJFTkRFUkVELCBudWxsKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUkVOREVSRVIsIHJvb3RbUkVOREVSRVJdKTtcbiAgICAgIHByaXZhdGVTZXROb2Rlcyh0aGlzLCBub2Rlcyk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIE9QVElPTlMsIHJvb3RbT1BUSU9OU10pO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBST09UX05PREVTLCByb290W05PREVTXSk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFBST1ZJREVSX1ZBTFVFUywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgd3JhcHBlclxuICAgKlxuICAgKiBAcmV0dXJuIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbUk9PVF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd3JhcHBlZCBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Tm9kZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Z2V0Tm9kZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHdyYXBwaW5nIG9uZSBub2RlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzW1JPT1RdID09PSB0aGlzKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT0RFXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aGUgd3JhcHBlZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxSZWFjdENvbXBvbmVudD59XG4gICAqL1xuICBnZXROb2Rlc0ludGVybmFsKCkge1xuICAgIGlmICh0aGlzW1JPT1RdID09PSB0aGlzICYmIHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT0RFU107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd3JhcHBlZCBSZWFjdEVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH1cbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdnZXRFbGVtZW50JywgKG4pID0+IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSkubm9kZVRvRWxlbWVudChuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd3JhcHBlZCBSZWFjdEVsZW1lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxSZWFjdEVsZW1lbnQ+fVxuICAgKi9cbiAgZ2V0RWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLm1hcCgobikgPT4gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKS5ub2RlVG9FbGVtZW50KG4pKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGdldE5vZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Z2V0Tm9kZSgpIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzZSBTaGFsbG93V3JhcHBlcjo6Z2V0RWxlbWVudCgpIGluc3RlYWQnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGdldE5vZGVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmdldE5vZGVzKCkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIFNoYWxsb3dXcmFwcGVyOjpnZXRFbGVtZW50cygpIGluc3RlYWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGJlaW5nIHJlbmRlcmVkIGFzIHRoZSByb290IG5vZGUgcGFzc2VkIGludG8gYHNoYWxsb3coKWAuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHNvIHRoZSByb290IGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogY29uc3Qgd3JhcHBlciA9IHNoYWxsb3coPE15Q29tcG9uZW50IC8+KTtcbiAgICogY29uc3QgaW5zdCA9IHdyYXBwZXIuaW5zdGFuY2UoKTtcbiAgICogZXhwZWN0KGluc3QpLnRvLmJlLmluc3RhbmNlT2YoTXlDb21wb25lbnQpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgaW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6Omluc3RhbmNlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCkuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBgd3JhcHBpbmdDb21wb25lbnRgIHdhcyBwYXNzZWQgaW4gYG9wdGlvbnNgLCB0aGlzIG1ldGhvZHMgcmV0dXJucyBhIGBTaGFsbG93V3JhcHBlcmBcbiAgICogYXJvdW5kIHRoZSByZW5kZXJlZCBgd3JhcHBpbmdDb21wb25lbnRgLiBUaGlzIGBTaGFsbG93V3JhcHBlcmAgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZVxuICAgKiBgd3JhcHBpbmdDb21wb25lbnRgJ3MgcHJvcHMsIHN0YXRlLCBldGMuXG4gICAqXG4gICAqIEByZXR1cm5zIFNoYWxsb3dXcmFwcGVyXG4gICAqL1xuICBnZXRXcmFwcGluZ0NvbXBvbmVudCgpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Z2V0V3JhcHBpbmdDb21wb25lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzW09QVElPTlNdLndyYXBwaW5nQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpnZXRXcmFwcGluZ0NvbXBvbmVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgYSBgd3JhcHBpbmdDb21wb25lbnRgIG9wdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tXUkFQUElOR19DT01QT05FTlRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIHJlLXJlbmRlci4gVXNlZnVsIHRvIHJ1biBiZWZvcmUgY2hlY2tpbmcgdGhlIHJlbmRlciBvdXRwdXQgaWYgc29tZXRoaW5nIGV4dGVybmFsXG4gICAqIG1heSBiZSB1cGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBzb21ld2hlcmUuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHNvIHRoZSByb290IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnVwZGF0ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnVwZGF0ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHdyYXBwaW5nIG9uZSBub2RlJyk7XG4gICAgfVxuICAgIHByaXZhdGVTZXROb2Rlcyh0aGlzLCBnZXRSb290Tm9kZSh0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHVubW91bnRzIHRoZSBjb21wb25lbnQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2ltdWxhdGUgYSBjb21wb25lbnQgZ29pbmcgdGhyb3VnaFxuICAgKiBhbmQgdW5tb3VudC9tb3VudCBsaWZlY3ljbGUuXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHVubW91bnQoKSB7XG4gICAgdGhpc1tSRU5ERVJFUl0udW5tb3VudCgpO1xuICAgIGlmICh0aGlzW1JPT1RdW1dSQVBQSU5HX0NPTVBPTkVOVF0pIHtcbiAgICAgIHRoaXNbUk9PVF1bV1JBUFBJTkdfQ09NUE9ORU5UXS51bm1vdW50KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGlzIGZvciByZS1yZW5kZXIgd2l0aCBuZXcgcHJvcHMgYW5kIGNvbnRleHQuXG4gICAqIFRoaXMgY2FsbHMgY29tcG9uZW50RGlkVXBkYXRlIG1ldGhvZCBpZiBkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyBpcyBub3QgZW5hYmxlZC5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICByZXJlbmRlcihwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIHRoaXMuc2luZ2xlKCdyZXJlbmRlcicsICgpID0+IHtcbiAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xuICAgICAgICAvLyBOT1RFKGxtcik6IEluIHJlYWN0IDE2LCBpbnN0YW5jZXMgd2lsbCBiZSBudWxsIGZvciBTRkNzLCBidXRcbiAgICAgICAgLy8gcmVyZW5kZXJpbmcgd2l0aCBwcm9wcy9jb250ZXh0IGlzIHN0aWxsIGEgdmFsaWQgdGhpbmcgdG8gZG8uIEluXG4gICAgICAgIC8vIHRoaXMgY2FzZSwgc3RhdGUgd2lsbCBiZSB1bmRlZmluZWQsIGJ1dCBwcm9wcy9jb250ZXh0IHdpbGwgZXhpc3QuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbm9kZS5pbnN0YW5jZSB8fCB7fTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZSB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzIHx8IHRoaXNbVU5SRU5ERVJFRF0ucHJvcHM7XG4gICAgICAgIGNvbnN0IHByZXZDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dCB8fCB0aGlzW09QVElPTlNdLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0gY29udGV4dCB8fCBwcmV2Q29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzW09QVElPTlNdID0geyAuLi50aGlzW09QVElPTlNdLCBjb250ZXh0OiBuZXh0Q29udGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbUkVOREVSRVJdLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAvLyBXaGVuIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlIHdlIHNob3VsZG4ndCBjYWxsIGNvbXBvbmVudERpZFVwZGF0ZS5cbiAgICAgICAgICAvLyBzbyB3ZSBzcHkgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHRvIGdldCB0aGUgcmVzdWx0LlxuICAgICAgICAgIGNvbnN0IGxpZmVjeWNsZXMgPSBnZXRBZGFwdGVyTGlmZWN5Y2xlcyhhZGFwdGVyKTtcbiAgICAgICAgICBsZXQgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5O1xuICAgICAgICAgIGxldCBnZXRDaGlsZENvbnRleHRTcHk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXNbT1BUSU9OU10uZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHNcbiAgICAgICAgICAgICYmIGluc3RhbmNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb25zdCB7IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogZ0RTRlAgfSA9IGxpZmVjeWNsZXM7XG4gICAgICAgICAgICAgIGlmIChnRFNGUCAmJiBnRFNGUC5oYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWcpIHtcbiAgICAgICAgICAgICAgICBtb2NrU0NVSWZnRFNGUFJldHVybk5vbk51bGwobm9kZSwgc3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZVNweSA9IHNweU1ldGhvZChpbnN0YW5jZSwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBsaWZlY3ljbGVzLmdldENoaWxkQ29udGV4dC5jYWxsZWRCeVJlbmRlcmVyXG4gICAgICAgICAgICAgICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBnZXRDaGlsZENvbnRleHRTcHkgPSBzcHlNZXRob2QoaW5zdGFuY2UsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzaG91bGRDb21wb25lbnRVcGRhdGVTcHkgJiYgaXNQdXJlQ29tcG9uZW50KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gcHVyZUNvbXBvbmVudFNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BzKSB0aGlzW1VOUkVOREVSRURdID0gY2xvbmVFbGVtZW50KGFkYXB0ZXIsIHRoaXNbVU5SRU5ERVJFRF0sIHByb3BzKTtcbiAgICAgICAgICB0aGlzW1JFTkRFUkVSXS5yZW5kZXIodGhpc1tVTlJFTkRFUkVEXSwgbmV4dENvbnRleHQsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyVmFsdWVzOiB0aGlzW1BST1ZJREVSX1ZBTFVFU10sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHNob3VsZENvbXBvbmVudFVwZGF0ZVNweSkge1xuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5LmdldExhc3RSZXR1cm5WYWx1ZSgpO1xuICAgICAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyXG4gICAgICAgICAgICAmJiAhdGhpc1tPUFRJT05TXS5kaXNhYmxlTGlmZWN5Y2xlTWV0aG9kc1xuICAgICAgICAgICAgJiYgaW5zdGFuY2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaXZhdGVTZXRDaGlsZENvbnRleHQoYWRhcHRlciwgdGhpcywgaW5zdGFuY2UsIG5vZGUsIGdldENoaWxkQ29udGV4dFNweSk7XG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkge1xuICAgICAgICAgICAgICBsZXQgc25hcHNob3Q7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgc3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAhc3RhdGVcbiAgICAgICAgICAgICAgICAgIHx8IHNoYWxsb3dFcXVhbChzdGF0ZSwgdGhpcy5pbnN0YW5jZSgpLnN0YXRlKVxuICAgICAgICAgICAgICAgICAgfHwgdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBzdGF0ZSwgc25hcHNob3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAgICAgICAgICAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlLnByZXZDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgc3RhdGUsIHByZXZDb250ZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RhdGUgfHwgc2hhbGxvd0VxdWFsKHRoaXMuaW5zdGFuY2UoKS5zdGF0ZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgc3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBuZWVkIHRvIHJlcmVuZGVyLCB1cGRhdGUgb25seSBpdHMgcHJvcHMuXG4gICAgICAgICAgfSBlbHNlIGlmICghc2hhbGxvd0VxdWFsKHByb3BzLCBpbnN0YW5jZS5wcm9wcykpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7IC4uLmluc3RhbmNlLnByb3BzLCAuLi5wcm9wcyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHNldHMgdGhlIHByb3BzIG9mIHRoZSByb290IGNvbXBvbmVudCwgYW5kIHJlLXJlbmRlcnMuIFVzZWZ1bCBmb3Igd2hlbiB5b3UgYXJlXG4gICAqIHdhbnRpbmcgdG8gdGVzdCBob3cgdGhlIGNvbXBvbmVudCBiZWhhdmVzIG92ZXIgdGltZSB3aXRoIGNoYW5naW5nIHByb3BzLiBDYWxsaW5nIHRoaXMsIGZvclxuICAgKiBpbnN0YW5jZSwgd2lsbCBjYWxsIHRoZSBgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc2AgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICpcbiAgICogU2ltaWxhciB0byBgc2V0U3RhdGVgLCB0aGlzIG1ldGhvZCBhY2NlcHRzIGEgcHJvcHMgb2JqZWN0IGFuZCB3aWxsIG1lcmdlIGl0IGluIHdpdGggdGhlIGFscmVhZHlcbiAgICogZXhpc3RpbmcgcHJvcHMuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHNvIHRoZSByb290IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgc2V0UHJvcHMocHJvcHMsIGNhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnNldFByb3BzKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6c2V0UHJvcHMoKSBleHBlY3RzIGEgZnVuY3Rpb24gYXMgaXRzIHNlY29uZCBhcmd1bWVudCcpO1xuICAgIH1cbiAgICB0aGlzLnJlcmVuZGVyKHByb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGludm9rZSBgc2V0U3RhdGVgIG9uIHRoZSByb290IGNvbXBvbmVudCBpbnN0YW5jZSBzaW1pbGFyIHRvIGhvdyB5b3UgbWlnaHQgaW4gdGhlXG4gICAqIGRlZmluaXRpb24gb2YgdGhlIGNvbXBvbmVudCwgYW5kIHJlLXJlbmRlcnMuICBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgeW91ciBjb21wb25lbnRcbiAgICogaW4gaGFyZCB0byBhY2hpZXZlIHN0YXRlcywgaG93ZXZlciBzaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkuIElmIHBvc3NpYmxlLCB5b3Ugc2hvdWxkIHV0aWxpemVcbiAgICogeW91ciBjb21wb25lbnQncyBleHRlcm5hbCBBUEkgaW4gb3JkZXIgdG8gZ2V0IGl0IGludG8gd2hhdGV2ZXIgc3RhdGUgeW91IHdhbnQgdG8gdGVzdCwgaW4gb3JkZXJcbiAgICogdG8gYmUgYXMgYWNjdXJhdGUgb2YgYSB0ZXN0IGFzIHBvc3NpYmxlLiBUaGlzIGlzIG5vdCBhbHdheXMgcHJhY3RpY2FsLCBob3dldmVyLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIGluc3RhbmNlIHRoYXQgaXMgYWxzbyB0aGUgcm9vdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIHRvIG1lcmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnNldFN0YXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluc3RhbmNlKCkgPT09IG51bGwgfHwgdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpLm5vZGVUeXBlICE9PSAnY2xhc3MnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpzZXRTdGF0ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjbGFzcyBjb21wb25lbnRzJyk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6c2V0U3RhdGUoKSBleHBlY3RzIGEgZnVuY3Rpb24gYXMgaXRzIHNlY29uZCBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2luZ2xlKCdzZXRTdGF0ZScsICgpID0+IHtcbiAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcblxuICAgICAgICBjb25zdCBsaWZlY3ljbGVzID0gZ2V0QWRhcHRlckxpZmVjeWNsZXMoYWRhcHRlcik7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbUkVOREVSRVJdLmdldE5vZGUoKTtcbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICBjb25zdCBwcmV2Q29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbiAgICAgICAgY29uc3Qgc3RhdGVQYXlsb2FkID0gdHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBzdGF0ZS5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByZXZQcm9wcylcbiAgICAgICAgICA6IHN0YXRlO1xuXG4gICAgICAgIC8vIHJldHVybmluZyBudWxsIG9yIHVuZGVmaW5lZCBwcmV2ZW50cyB0aGUgdXBkYXRlIGluIFJlYWN0IDE2K1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMjc1NlxuICAgICAgICBjb25zdCBtYXliZUhhc1VwZGF0ZSA9ICFsaWZlY3ljbGVzLnNldFN0YXRlLnNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoXG4gICAgICAgICAgfHwgc3RhdGVQYXlsb2FkICE9IG51bGw7XG5cbiAgICAgICAgLy8gV2hlbiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZSB3ZSBzaG91bGRuJ3QgY2FsbCBjb21wb25lbnREaWRVcGRhdGUuXG4gICAgICAgIC8vIHNvIHdlIHNweSBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gZ2V0IHRoZSByZXN1bHQuXG4gICAgICAgIGxldCBzaG91bGRDb21wb25lbnRVcGRhdGVTcHk7XG4gICAgICAgIGxldCBnZXRDaGlsZENvbnRleHRTcHk7XG4gICAgICAgIGxldCBzaG91bGRSZW5kZXIgPSB0cnVlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXNbT1BUSU9OU10uZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHNcbiAgICAgICAgICAmJiBpbnN0YW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAgICAgICAgJiYgbGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGUub25TZXRTdGF0ZVxuICAgICAgICAgICAgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgeyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IGdEU0ZQIH0gPSBsaWZlY3ljbGVzO1xuICAgICAgICAgICAgaWYgKGdEU0ZQICYmIGdEU0ZQLmhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1Zykge1xuICAgICAgICAgICAgICBtb2NrU0NVSWZnRFNGUFJldHVybk5vbk51bGwobm9kZSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5ID0gc3B5TWV0aG9kKGluc3RhbmNlLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpZmVjeWNsZXMuZ2V0Q2hpbGRDb250ZXh0LmNhbGxlZEJ5UmVuZGVyZXJcbiAgICAgICAgICAgICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGdldENoaWxkQ29udGV4dFNweSA9IHNweU1ldGhvZChpbnN0YW5jZSwgJ2dldENoaWxkQ29udGV4dCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNob3VsZENvbXBvbmVudFVwZGF0ZVNweSAmJiBpc1B1cmVDb21wb25lbnQoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gcHVyZUNvbXBvbmVudFNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzLFxuICAgICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgICAgeyAuLi5wcmV2U3RhdGUsIC4uLnN0YXRlUGF5bG9hZCB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkb24ndCBwYXNzIHRoZSBzZXRTdGF0ZSBjYWxsYmFjayBoZXJlXG4gICAgICAgIC8vIHRvIGd1YXJhbnRlZSB0byBjYWxsIHRoZSBjYWxsYmFjayBhZnRlciBmaW5pc2hpbmcgdGhlIHJlbmRlclxuICAgICAgICBpZiAoaW5zdGFuY2VbU0VUX1NUQVRFXSkge1xuICAgICAgICAgIGluc3RhbmNlW1NFVF9TVEFURV0oc3RhdGVQYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZS5zZXRTdGF0ZShzdGF0ZVBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wb25lbnRVcGRhdGVTcHkpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSBzaG91bGRDb21wb25lbnRVcGRhdGVTcHkuZ2V0TGFzdFJldHVyblZhbHVlKCk7XG4gICAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWF5YmVIYXNVcGRhdGVcbiAgICAgICAgICAmJiBzaG91bGRSZW5kZXJcbiAgICAgICAgICAmJiAhdGhpc1tPUFRJT05TXS5kaXNhYmxlTGlmZWN5Y2xlTWV0aG9kc1xuICAgICAgICApIHtcbiAgICAgICAgICBwcml2YXRlU2V0Q2hpbGRDb250ZXh0KGFkYXB0ZXIsIHRoaXMsIGluc3RhbmNlLCBub2RlLCBnZXRDaGlsZENvbnRleHRTcHkpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICAgICAmJiBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZS5vblNldFN0YXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxpZmVjeWNsZXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAobGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGUucHJldkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIC8vIGNhbGwgdGhlIHNldFN0YXRlIGNhbGxiYWNrXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGlmIChhZGFwdGVyLmludm9rZVNldFN0YXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFkYXB0ZXIuaW52b2tlU2V0U3RhdGVDYWxsYmFjayhpbnN0YW5jZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgcm9vdCBjb21wb25lbnQsIGFuZCByZS1yZW5kZXJzLiBVc2VmdWwgZm9yIHdoZW4geW91IGFyZVxuICAgKiB3YW50aW5nIHRvIHRlc3QgaG93IHRoZSBjb21wb25lbnQgYmVoYXZlcyBvdmVyIHRpbWUgd2l0aCBjaGFuZ2luZyBjb250ZXh0cy5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9iamVjdFxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c2V0Q29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXNbT1BUSU9OU10uY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c2V0Q29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgYSBjb250ZXh0IG9wdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXJlbmRlcihudWxsLCBjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzaGFsbG93IHJlbmRlciB0cmVlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogY29uc3Qgd3JhcHBlciA9IHNoYWxsb3coPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIuY29udGFpbnMoPGRpdiBjbGFzc05hbWU9XCJmb28gYmFyXCIgLz4pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fEFycmF5PFJlYWN0RWxlbWVudD59IG5vZGVPck5vZGVzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY29udGFpbnMobm9kZU9yTm9kZXMpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICBpZiAoIWlzUmVhY3RFbGVtZW50QWxpa2Uobm9kZU9yTm9kZXMsIGFkYXB0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpjb250YWlucygpIGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgUmVhY3RFbGVtZW50IChvciBhbiBhcnJheSBvZiB0aGVtKSwgYSBzdHJpbmcsIG9yIGEgbnVtYmVyIGFzIGFuIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBwcmVkaWNhdGUgPSBBcnJheS5pc0FycmF5KG5vZGVPck5vZGVzKVxuICAgICAgPyAob3RoZXIpID0+IGNvbnRhaW5zQ2hpbGRyZW5TdWJBcnJheShcbiAgICAgICAgbm9kZUVxdWFsLFxuICAgICAgICBvdGhlcixcbiAgICAgICAgbm9kZU9yTm9kZXMubWFwKChub2RlKSA9PiBhZGFwdGVyLmVsZW1lbnRUb05vZGUobm9kZSkpLFxuICAgICAgKVxuICAgICAgOiAob3RoZXIpID0+IG5vZGVFcXVhbChhZGFwdGVyLmVsZW1lbnRUb05vZGUobm9kZU9yTm9kZXMpLCBvdGhlcik7XG5cbiAgICByZXR1cm4gZmluZFdoZXJlVW53cmFwcGVkKHRoaXMsIHByZWRpY2F0ZSkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzaGFsbG93IHJlbmRlciB0cmVlLlxuICAgKiBNYXRjaCBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhbmQgbm90IG9uIHdyYXBwZXJzIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgZGV0ZXJtaW5lIGlmIG9uZSBvZiB0aGUgd3JhcHBlcnMgZWxlbWVudCBcImxvb2tzIGxpa2VcIiB0aGUgZXhwZWN0ZWRcbiAgICogZWxlbWVudCBieSBjaGVja2luZyBpZiBhbGwgcHJvcHMgb2YgdGhlIGV4cGVjdGVkIGVsZW1lbnQgYXJlIHByZXNlbnRcbiAgICogb24gdGhlIHdyYXBwZXJzIGVsZW1lbnQgYW5kIGVxdWFscyB0byBlYWNoIG90aGVyLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogLy8gTXlDb21wb25lbnQgb3V0cHV0cyA8ZGl2PjxkaXYgY2xhc3M9XCJmb29cIj5IZWxsbzwvZGl2PjwvZGl2PlxuICAgKiBjb25zdCB3cmFwcGVyID0gc2hhbGxvdyg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWluc01hdGNoaW5nRWxlbWVudCg8ZGl2PkhlbGxvPC9kaXY+KSkudG8uZXF1YWwodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KG5vZGUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICBjb25zdCByc3ROb2RlID0gYWRhcHRlci5lbGVtZW50VG9Ob2RlKG5vZGUpO1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IChvdGhlcikgPT4gbm9kZU1hdGNoZXMocnN0Tm9kZSwgb3RoZXIsIChhLCBiKSA9PiBhIDw9IGIpO1xuICAgIHJldHVybiBmaW5kV2hlcmVVbndyYXBwZWQodGhpcywgcHJlZGljYXRlKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGFsbCB0aGUgZ2l2ZW4gcmVhY3QgZWxlbWVudHMgZXhpc3QgaW4gdGhlIHNoYWxsb3cgcmVuZGVyIHRyZWUuXG4gICAqIE1hdGNoIGlzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBlbGVtZW50IGFuZCBub3Qgb24gd3JhcHBlcnMgZWxlbWVudC5cbiAgICogSXQgd2lsbCBkZXRlcm1pbmUgaWYgb25lIG9mIHRoZSB3cmFwcGVycyBlbGVtZW50IFwibG9va3MgbGlrZVwiIHRoZSBleHBlY3RlZFxuICAgKiBlbGVtZW50IGJ5IGNoZWNraW5nIGlmIGFsbCBwcm9wcyBvZiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhcmUgcHJlc2VudFxuICAgKiBvbiB0aGUgd3JhcHBlcnMgZWxlbWVudCBhbmQgZXF1YWxzIHRvIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gc2hhbGxvdyg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWluc0FsbE1hdGNoaW5nRWxlbWVudHMoW1xuICAgKiAgIDxkaXY+SGVsbG88L2Rpdj4sXG4gICAqICAgPGRpdj5Hb29kYnllPC9kaXY+LFxuICAgKiBdKSkudG8uZXF1YWwodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFJlYWN0RWxlbWVudD59IG5vZGVzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY29udGFpbnNBbGxNYXRjaGluZ0VsZW1lbnRzKG5vZGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm9kZXMgc2hvdWxkIGJlIGFuIEFycmF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KChub2RlKSA9PiB0aGlzLmNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBvbmUgb2YgdGhlIGdpdmVuIHJlYWN0IGVsZW1lbnRzIGV4aXN0cyBpbiB0aGUgc2hhbGxvdyByZW5kZXIgdHJlZS5cbiAgICogTWF0Y2ggaXMgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGVsZW1lbnQgYW5kIG5vdCBvbiB3cmFwcGVycyBlbGVtZW50LlxuICAgKiBJdCB3aWxsIGRldGVybWluZSBpZiBvbmUgb2YgdGhlIHdyYXBwZXJzIGVsZW1lbnQgXCJsb29rcyBsaWtlXCIgdGhlIGV4cGVjdGVkXG4gICAqIGVsZW1lbnQgYnkgY2hlY2tpbmcgaWYgYWxsIHByb3BzIG9mIHRoZSBleHBlY3RlZCBlbGVtZW50IGFyZSBwcmVzZW50XG4gICAqIG9uIHRoZSB3cmFwcGVycyBlbGVtZW50IGFuZCBlcXVhbHMgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBzaGFsbG93KDxNeUNvbXBvbmVudCAvPik7XG4gICAqIGV4cGVjdCh3cmFwcGVyLmNvbnRhaW5zQW55TWF0Y2hpbmdFbGVtZW50cyhbXG4gICAqICAgPGRpdj5IZWxsbzwvZGl2PixcbiAgICogICA8ZGl2Pkdvb2RieWU8L2Rpdj4sXG4gICAqIF0pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVhY3RFbGVtZW50Pn0gbm9kZXNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjb250YWluc0FueU1hdGNoaW5nRWxlbWVudHMobm9kZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShub2RlcykgJiYgbm9kZXMuc29tZSgobm9kZSkgPT4gdGhpcy5jb250YWluc01hdGNoaW5nRWxlbWVudChub2RlKSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgYSBnaXZlbiByZWFjdCBlbGVtZW50IGV4aXN0cyBpbiB0aGUgcmVuZGVyIHRyZWUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gc2hhbGxvdyg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWlucyg8ZGl2IGNsYXNzTmFtZT1cImZvbyBiYXJcIiAvPikpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5vZGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMobm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnZXF1YWxzJywgKCkgPT4gbm9kZUVxdWFsKHRoaXMuZ2V0Tm9kZUludGVybmFsKCksIG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgbWF0Y2hlcyB0aGUgcmVuZGVyIHRyZWUuXG4gICAqIE1hdGNoIGlzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBlbGVtZW50IGFuZCBub3Qgb24gd3JhcHBlciByb290IG5vZGUuXG4gICAqIEl0IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSB3cmFwcGVyIHJvb3Qgbm9kZSBcImxvb2tzIGxpa2VcIiB0aGUgZXhwZWN0ZWRcbiAgICogZWxlbWVudCBieSBjaGVja2luZyBpZiBhbGwgcHJvcHMgb2YgdGhlIGV4cGVjdGVkIGVsZW1lbnQgYXJlIHByZXNlbnRcbiAgICogb24gdGhlIHdyYXBwZXIgcm9vdCBub2RlIGFuZCBlcXVhbHMgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIC8vIE15Q29tcG9uZW50IG91dHB1dHMgPGRpdiBjbGFzcz1cImZvb1wiPkhlbGxvPC9kaXY+XG4gICAqIGNvbnN0IHdyYXBwZXIgPSBzaGFsbG93KDxNeUNvbXBvbmVudCAvPik7XG4gICAqIGV4cGVjdCh3cmFwcGVyLm1hdGNoZXNFbGVtZW50KDxkaXY+SGVsbG88L2Rpdj4pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBub2RlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgbWF0Y2hlc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnbWF0Y2hlc0VsZW1lbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICAgIGNvbnN0IHJzdE5vZGUgPSBhZGFwdGVyLmVsZW1lbnRUb05vZGUobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZU1hdGNoZXMocnN0Tm9kZSwgdGhpcy5nZXROb2RlSW50ZXJuYWwoKSwgKGEsIGIpID0+IGEgPD0gYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgZXZlcnkgbm9kZSBpbiB0aGUgcmVuZGVyIHRyZWUgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcChyZWR1Y2VUcmVlc0J5U2VsZWN0b3Ioc2VsZWN0b3IsIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBjdXJyZW50IG5vZGUgbWF0Y2hlcyBhIHByb3ZpZGVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXMoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdpcycsIChuKSA9PiBwcmVkaWNhdGUobikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG5vdGhpbmcsIGkuZS4sIG51bGwgb3IgZmFsc2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eVJlbmRlcigpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpO1xuXG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KChuKSA9PiBpc0VtcHR5VmFsdWUobikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBtYXRjaFxuICAgKiB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLiBUaGUgcHJlZGljYXRlIHNob3VsZCByZWNlaXZlIGEgd3JhcHBlZCBub2RlIGFzIGl0cyBmaXJzdFxuICAgKiBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZpbHRlcldoZXJlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmaWx0ZXJXaGVyZVVud3JhcHBlZCh0aGlzLCAobikgPT4gcHJlZGljYXRlKHRoaXMud3JhcChuKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBtYXRjaFxuICAgKiB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZpbHRlcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZmlsdGVyV2hlcmVVbndyYXBwZWQodGhpcywgcHJlZGljYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBvbmx5IHRoZSBub2RlcyBvZiB0aGUgY3VycmVudCB3cmFwcGVyIHRoYXQgZGlkIG5vdCBtYXRjaFxuICAgKiB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuIEVzc2VudGlhbGx5IHRoZSBpbnZlcnNlIG9mIGBmaWx0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBub3Qoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIGZpbHRlcldoZXJlVW53cmFwcGVkKHRoaXMsIChuKSA9PiAhcHJlZGljYXRlKG4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSByZW5kZXJlZCB0ZXh0IG9mIHRoZSBjdXJyZW50IHJlbmRlciB0cmVlLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmVcbiAgICogbG9va2VkIGF0IHdpdGggc2tlcHRpY2lzbSBpZiBiZWluZyB1c2VkIHRvIHRlc3Qgd2hhdCB0aGUgYWN0dWFsIEhUTUwgb3V0cHV0IG9mIHRoZSBjb21wb25lbnRcbiAgICogd2lsbCBiZS4gSWYgdGhhdCBpcyB3aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHRlc3QsIHVzZSBlbnp5bWUncyBgcmVuZGVyYCBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgndGV4dCcsIGdldFRleHRGcm9tTm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSFRNTCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgaHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2h0bWwnLCAobikgPT4ge1xuICAgICAgaWYgKHRoaXMudHlwZSgpID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSBhZGFwdGVyLmNyZWF0ZVJlbmRlcmVyKHsgLi4udGhpc1tPUFRJT05TXSwgbW9kZTogJ3N0cmluZycgfSk7XG4gICAgICByZXR1cm4gcmVuZGVyZXIucmVuZGVyKGFkYXB0ZXIubm9kZVRvRWxlbWVudChuKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBub2RlIHJlbmRlcmVkIHRvIEhUTUwgYW5kIHdyYXBwZWQgaW4gYSBDaGVlcmlvV3JhcHBlci5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q2hlZXJpb1dyYXBwZXJ9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaHRtbCA9IHRoaXMuaHRtbCgpO1xuICAgIHJldHVybiBsb2FkQ2hlZXJpb1Jvb3QoaHRtbCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzaW11bGF0ZSBldmVudHMuIFBhc3MgYW4gZXZlbnRuYW1lIGFuZCAob3B0aW9uYWxseSkgZXZlbnQgYXJndW1lbnRzLiBUaGlzIG1ldGhvZCBvZlxuICAgKiB0ZXN0aW5nIGV2ZW50cyBzaG91bGQgYmUgbWV0IHdpdGggc29tZSBza2VwdGljaXNtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBzaW11bGF0ZShldmVudCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnc2ltdWxhdGUnLCAobikgPT4ge1xuICAgICAgdGhpc1tSRU5ERVJFUl0uc2ltdWxhdGVFdmVudChuLCBldmVudCwgLi4uYXJncyk7XG4gICAgICB0aGlzW1JPT1RdLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzaW11bGF0ZSB0aHJvd2luZyBhIHJlbmRlcmluZyBlcnJvci4gUGFzcyBhbiBlcnJvciB0byB0aHJvdy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNpbXVsYXRlRXJyb3IoZXJyb3IpIHtcbiAgICAvLyBpbiBzaGFsbG93LCB0aGUgXCJyb290XCIgaXMgdGhlIFwicmVuZGVyZWRcIiB0aGluZy5cblxuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnc2ltdWxhdGVFcnJvcicsICh0aGlzTm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXNOb2RlLm5vZGVUeXBlID09PSAnaG9zdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2hhbGxvd1dyYXBwZXI6OnNpbXVsYXRlRXJyb3IoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gY3VzdG9tIGNvbXBvbmVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzW1JFTkRFUkVSXTtcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2ltdWxhdGVFcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd5b3VyIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBgc2ltdWxhdGVFcnJvcmAuIFRyeSB1cGdyYWRpbmcgaXQhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGVJbnRlcm5hbCh0aGlzKTtcbiAgICAgIGNvbnN0IG5vZGVIaWVyYXJjaHkgPSBbdGhpc05vZGVdLmNvbmNhdChub2RlUGFyZW50cyh0aGlzLCB0aGlzTm9kZSkpO1xuICAgICAgcmVuZGVyZXIuc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wcyBoYXNoIGZvciB0aGUgY3VycmVudCBub2RlIG9mIHRoZSB3cmFwcGVyLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBwcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3Byb3BzJywgcHJvcHNPZk5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIGhhc2ggZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIHdyYXBwZXIuIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHByb3AgbmFtZSBhbmQgaXRcbiAgICogd2lsbCByZXR1cm4ganVzdCB0aGF0IHZhbHVlLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIChvcHRpb25hbClcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzdGF0ZShuYW1lKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnN0YXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluc3RhbmNlKCkgPT09IG51bGwgfHwgdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpLm5vZGVUeXBlICE9PSAnY2xhc3MnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpzdGF0ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjbGFzcyBjb21wb25lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IF9zdGF0ZSA9IHRoaXMuc2luZ2xlKCdzdGF0ZScsICgpID0+IHRoaXMuaW5zdGFuY2UoKS5zdGF0ZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKF9zdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNoYWxsb3dXcmFwcGVyOjpzdGF0ZShcIiR7bmFtZX1cIikgcmVxdWlyZXMgdGhhdCBcXGBzdGF0ZVxcYCBub3QgYmUgXFxgbnVsbFxcYCBvciBcXGB1bmRlZmluZWRcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfc3RhdGVbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGV4dCBoYXNoIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSB3cmFwcGVyLlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYSBwcm9wIG5hbWUgYW5kIGl0IHdpbGwgcmV0dXJuIGp1c3QgdGhhdCB2YWx1ZS5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY29udGV4dChuYW1lKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmNvbnRleHQoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzW09QVElPTlNdLmNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmNvbnRleHQoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIHRoYXQgd2FzIG9yaWdpbmFsbHkgcGFzc2VkIGEgY29udGV4dCBvcHRpb24nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UoKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Y29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB3cmFwcGVkIG5vZGVzIHRoYXQgaGF2ZSBhIG5vbi1udWxsIGluc3RhbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IF9jb250ZXh0ID0gdGhpcy5zaW5nbGUoJ2NvbnRleHQnLCAoKSA9PiB0aGlzLmluc3RhbmNlKCkuY29udGV4dCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBfY29udGV4dFtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciB3aXRoIGFsbCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gW3NlbGVjdG9yXVxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBjaGlsZHJlbihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGFsbENoaWxkcmVuID0gdGhpcy5mbGF0TWFwKChuKSA9PiBjaGlsZHJlbk9mTm9kZShuLmdldE5vZGVJbnRlcm5hbCgpKSk7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gYWxsQ2hpbGRyZW4uZmlsdGVyKHNlbGVjdG9yKSA6IGFsbENoaWxkcmVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciB3aXRoIGEgc3BlY2lmaWMgY2hpbGRcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgY2hpbGRBdChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnY2hpbGRBdCcsICgpID0+IHRoaXMuY2hpbGRyZW4oKS5hdChpbmRleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCBhbGwgb2YgdGhlIHBhcmVudHMvYW5jZXN0b3JzIG9mIHRoZSB3cmFwcGVyLiBEb2VzIG5vdCBpbmNsdWRlIHRoZSBub2RlXG4gICAqIGluIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gW3NlbGVjdG9yXVxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdwYXJlbnRzJywgKG4pID0+IHtcbiAgICAgIGNvbnN0IGFsbFBhcmVudHMgPSB0aGlzLndyYXAobm9kZVBhcmVudHModGhpcywgbikpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gYWxsUGFyZW50cy5maWx0ZXIoc2VsZWN0b3IpIDogYWxsUGFyZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRNYXAoKG4pID0+IFtuLnBhcmVudHMoKS5nZXQoMCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuaXMoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hpbmdBbmNlc3RvcnMgPSB0aGlzLnBhcmVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIHJldHVybiBtYXRjaGluZ0FuY2VzdG9ycy5sZW5ndGggPiAwID8gbWF0Y2hpbmdBbmNlc3RvcnMuZmlyc3QoKSA6IHRoaXMuZmluZFdoZXJlKCgpID0+IGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFsbG93IHJlbmRlcnMgdGhlIGN1cnJlbnQgbm9kZSBhbmQgcmV0dXJucyBhIHNoYWxsb3cgd3JhcHBlciBhcm91bmQgaXQuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNoYWxsb3cob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdzaGFsbG93JywgKG4pID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkT3B0aW9ucyA9IG1ha2VJbmhlcml0ZWRDaGlsZE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy53cmFwKGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSkubm9kZVRvRWxlbWVudChuKSwgbnVsbCwgY2hpbGRPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBwcm9wIHdpdGggdGhlIGdpdmVuIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcHJvcChwcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzKClbcHJvcE5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24gcHJvcC5cbiAgICogV2lsbCBpbnZva2UgYW4gZnVuY3Rpb24gcHJvcCBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHtBbnl9XG4gICAqL1xuICBpbnZva2UocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2ludm9rZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnByb3AocHJvcE5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjppbnZva2UoKSByZXF1aXJlcyB0aGUgbmFtZSBvZiBhIHByb3Agd2hvc2UgdmFsdWUgaXMgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgdGhpc1tST09UXS51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgd3JhcHBlciBvZiB0aGUgbm9kZSByZW5kZXJlZCBieSB0aGUgcHJvdmlkZWQgcmVuZGVyIHByb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuICByZW5kZXJQcm9wKHByb3BOYW1lKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgaWYgKHR5cGVvZiBhZGFwdGVyLndyYXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd5b3VyIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBgd3JhcGAuIFRyeSB1cGdyYWRpbmcgaXQhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdyZW5kZXJQcm9wJywgKG4pID0+IHtcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSAnaG9zdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2hhbGxvd1dyYXBwZXI6OnJlbmRlclByb3AoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gY3VzdG9tIGNvbXBvbmVudHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpyZW5kZXJQcm9wKCk6IGBwcm9wTmFtZWAgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzKCk7XG4gICAgICBpZiAoIWhhcyhwcm9wcywgcHJvcE5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2hhbGxvd1dyYXBwZXI6OnJlbmRlclByb3AoKTogbm8gcHJvcCBjYWxsZWQg4oCcJHtwcm9wTmFtZX3igJwgZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNoYWxsb3dXcmFwcGVyOjpyZW5kZXJQcm9wKCk6IGV4cGVjdGVkIHByb3Ag4oCcJHtwcm9wTmFtZX3igJwgdG8gY29udGFpbiBhIGZ1bmN0aW9uLCBidXQgaXQgaG9sZHMg4oCcJHt0eXBlb2YgcHJvcFZhbHVlfeKAnGApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IGFkYXB0ZXIud3JhcChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh3cmFwcGVkLCBudWxsLCB0aGlzW09QVElPTlNdKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGFzc2lnbmVkIHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdrZXknLCAobikgPT4gKG4ua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogbi5rZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IG5vZGUgb2YgdGhpcyB3cmFwcGVyLiBJZiBpdCdzIGEgY29tcG9zaXRlIGNvbXBvbmVudCwgdGhpcyB3aWxsXG4gICAqIGJlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IuIElmIGl0J3MgYSBuYXRpdmUgRE9NIG5vZGUsIGl0IHdpbGwgYmUgYSBzdHJpbmcgb2YgdGhlIHRhZyBuYW1lLlxuICAgKiBJZiBpdCdzIG51bGwsIGl0IHdpbGwgYmUgbnVsbC5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3R5cGUnLCAobikgPT4gdHlwZU9mTm9kZShuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBub2RlIG9mIHRoaXMgd3JhcHBlci5cbiAgICpcbiAgICogSW4gb3JkZXIgb2YgcHJlY2VkZW5jZSA9PiB0eXBlLmRpc3BsYXlOYW1lIC0+IHR5cGUubmFtZSAtPiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ25hbWUnLCAobikgPT4gKFxuICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSA/IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUobikgOiBkaXNwbGF5TmFtZU9mTm9kZShuKVxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbm9kZSBoYXMgdGhlIGdpdmVuIGNsYXNzIG5hbWUgb3Igbm90LlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycgJiYgY2xhc3NOYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgY2FsbGluZyBgU2hhbGxvd1dyYXBwZXI6Omhhc0NsYXNzKClgIHdpdGggYSBDU1Mgc2VsZWN0b3IuIGhhc0NsYXNzKCkgZXhwZWN0cyBhIGNsYXNzIG5hbWUsIG5vdCBhIENTUyBzZWxlY3Rvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdoYXNDbGFzcycsIChuKSA9PiBoYXNDbGFzc05hbWUobiwgY2xhc3NOYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIG5vZGUgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGggYVxuICAgKiB3cmFwcGVyIGFyb3VuZCB0aGUgY29ycmVzcG9uZGluZyBub2RlIHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5mb3JFYWNoKChuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgdG8gYW5vdGhlciBhcnJheS4gRWFjaCBub2RlIGlzIHBhc3NlZCBpbiBhcyBhIGBTaGFsbG93V3JhcHBlcmBcbiAgICogdG8gdGhlIG1hcCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgbWFwKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLm1hcCgobiwgaSkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzLndyYXAobiksIGkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2VzIHRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzIHRvIGEgdmFsdWUuIEVhY2ggbm9kZSBpcyBwYXNzZWQgaW4gYXMgYSBgU2hhbGxvd1dyYXBwZXJgXG4gICAqIHRvIHRoZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSByZWR1Y2VyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gaW5pdGlhbFZhbHVlIC0gdGhlIGluaXRpYWwgdmFsdWVcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnJlZHVjZShcbiAgICAgICAgKGFjY3VtLCBuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIGFjY3VtLCB0aGlzLndyYXAobiksIGkpLFxuICAgICAgICBpbml0aWFsVmFsdWUsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkucmVkdWNlKChhY2N1bSwgbiwgaSkgPT4gZm4uY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBpID09PSAxID8gdGhpcy53cmFwKGFjY3VtKSA6IGFjY3VtLFxuICAgICAgdGhpcy53cmFwKG4pLFxuICAgICAgaSxcbiAgICApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2VzIHRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzIHRvIGFub3RoZXIgYXJyYXksIGZyb20gcmlnaHQgdG8gbGVmdC4gRWFjaCBub2RlIGlzIHBhc3NlZFxuICAgKiBpbiBhcyBhIGBTaGFsbG93V3JhcHBlcmAgdG8gdGhlIHJlZHVjZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIHJlZHVjZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBpbml0aWFsVmFsdWUgLSB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlZHVjZVJpZ2h0KGZuLCBpbml0aWFsVmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5yZWR1Y2VSaWdodChcbiAgICAgICAgKGFjY3VtLCBuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIGFjY3VtLCB0aGlzLndyYXAobiksIGkpLFxuICAgICAgICBpbml0aWFsVmFsdWUsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkucmVkdWNlUmlnaHQoKGFjY3VtLCBuLCBpKSA9PiBmbi5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIGkgPT09IDEgPyB0aGlzLndyYXAoYWNjdW0pIDogYWNjdW0sXG4gICAgICB0aGlzLndyYXAobiksXG4gICAgICBpLFxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciB3aXRoIGEgc3Vic2V0IG9mIHRoZSBub2RlcyBvZiB0aGUgb3JpZ2luYWwgd3JhcHBlciwgYWNjb3JkaW5nIHRvIHRoZVxuICAgKiBydWxlcyBvZiBgQXJyYXkjc2xpY2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYmVnaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcCh0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5zbGljZShiZWdpbiwgZW5kKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbnkgb2YgdGhlIG5vZGVzIGluIHRoZSB3cmFwcGVyIG1hdGNoIHRoZSBwcm92aWRlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzb21lKHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gPT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnNvbWUoKSBjYW4gbm90IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSBvZiB0aGUgbm9kZXMgaW4gdGhlIHdyYXBwZXIgcGFzcyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzb21lV2hlcmUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNvbWUoKG4sIGkpID0+IHByZWRpY2F0ZS5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgd3JhcHBlciBtYXRjaCB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZXZlcnkoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbnkgb2YgdGhlIG5vZGVzIGluIHRoZSB3cmFwcGVyIHBhc3MgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZXZlcnlXaGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuZXZlcnkoKG4sIGkpID0+IHByZWRpY2F0ZS5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHVzZWQgdG8gY3JlYXRlIG5ldyB3cmFwcGVycyB3aXRoIGEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogbm9kZXMgaW4gcmVzcG9uc2UgdG8gYSBzaW5nbGUgbm9kZSB3cmFwcGVyLiBUaGUgcmV0dXJuZWQgd3JhcHBlciBpcyBhIHNpbmdsZSB3cmFwcGVyIGFyb3VuZFxuICAgKiBhbGwgb2YgdGhlIG1hcHBlZCBub2RlcyBmbGF0dGVuZWQgKGFuZCBkZS1kdXBsaWNhdGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgZmxhdE1hcChmbikge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkubWFwKChuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQobm9kZXMsIDEpO1xuICAgIHJldHVybiB0aGlzLndyYXAoZmxhdHRlbmVkLmZpbHRlcihCb29sZWFuKSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIG5vZGVzIGluIHRoZSBjdXJyZW50IHdyYXBwZXIgbm9kZXMnIHJlbmRlciB0cmVlcyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVcbiAgICogZnVuY3Rpb24uIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBub2RlcyBpbnNpZGUgYSBTaGFsbG93V3JhcHBlciBhcyBpdHNcbiAgICogZmlyc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBmaW5kV2hlcmUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZpbmRXaGVyZVVud3JhcHBlZCh0aGlzLCAobikgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMud3JhcChuKTtcbiAgICAgIHJldHVybiBub2RlLmxlbmd0aCA+IDAgJiYgcHJlZGljYXRlKG5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vZGUgYXQgYSBnaXZlbiBpbmRleCBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHJldHVybnMge1JlYWN0RWxlbWVudH1cbiAgICovXG4gIGdldChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzKClbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbm9kZSBhdCBhIGdpdmVuIGluZGV4IG9mIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBhdChpbmRleCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2Rlc0ludGVybmFsKCk7XG4gICAgaWYgKGluZGV4IDwgbm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwKG5vZGVzW2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXAoW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZmlyc3Qgbm9kZSBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIGxhc3Qgbm9kZSBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLmF0KHRoaXMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZWdhdGVzIHRvIGV4aXN0cygpXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignRW56eW1lOjpEZXByZWNhdGVkIG1ldGhvZCBpc0VtcHR5KCkgY2FsbGVkLCB1c2UgZXhpc3RzKCkgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gIXRoaXMuZXhpc3RzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHdyYXBwZXIgaGFzIG5vZGVzLiBGYWxzZSBvdGhlcndpc2UuXG4gICAqIElmIGNhbGxlZCB3aXRoIGEgc2VsZWN0b3IgaXQgcmV0dXJucyBgLmZpbmQoc2VsZWN0b3IpLmV4aXN0cygpYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvciAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXhpc3RzKHNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHRoaXMuZmluZChzZWxlY3RvcikuZXhpc3RzKCkgOiB0aGlzLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdGhhdCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGN1cnJlbnQgaW5zdGFuY2UgaGFzIGEgbGVuZ3RoIG90aGVyIHRoYW4gb25lLlxuICAgKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIGVuZm9yY2UgdGhhdCBjZXJ0YWluIG1ldGhvZHMgYXJlIG9ubHkgcnVuIG9uIGEgd3JhcHBlciB3aGVuIGl0IGlzXG4gICAqIHdyYXBwaW5nIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmblxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNpbmdsZShuYW1lLCBmbikge1xuICAgIGNvbnN0IGZuTmFtZSA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IG5hbWUgOiAndW5rbm93bic7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IG5hbWU7XG4gICAgaWYgKHRoaXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCDigJwke2ZuTmFtZX3igJ0gaXMgbWVhbnQgdG8gYmUgcnVuIG9uIDEgbm9kZS4gJHt0aGlzLmxlbmd0aH0gZm91bmQgaW5zdGVhZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5nZXROb2RlSW50ZXJuYWwoKSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGZ1bCB1dGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgd3JhcHBlciB3aXRoIHRoZSBzYW1lIHJvb3QgYXMgdGhlIGN1cnJlbnQgd3JhcHBlciwgd2l0aFxuICAgKiBhbnkgbm9kZXMgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYXV0b21hdGljYWxseSB3cmFwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZVxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICB3cmFwKG5vZGUsIHJvb3QgPSB0aGlzW1JPT1RdLCAuLi5hcmdzKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTaGFsbG93V3JhcHBlcikge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2hhbGxvd1dyYXBwZXIobm9kZSwgcm9vdCwgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBIVE1MLWxpa2Ugc3RyaW5nIG9mIHRoZSBzaGFsbG93IHJlbmRlciBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUHJvcGVydHkgYmFnIG9mIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVQcm9wc10gLSBpZiB0cnVlLCBwcm9wcyBhcmUgb21pdHRlZCBmcm9tIHRoZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudmVyYm9zZV0gLSBpZiB0cnVlLCBhcnJheXMgYW5kIG9iamVjdHMgdG8gYmUgdmVyYm9zZWx5IHByaW50ZWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBkZWJ1ZyhvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZGVidWdOb2Rlcyh0aGlzLmdldE5vZGVzSW50ZXJuYWwoKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBpbnRlcmNlcHRlciBhbmQgcmV0dXJucyBpdHNlbGYuIGludGVyY2VwdGVyIGlzIGNhbGxlZCB3aXRoIGl0c2VsZi5cbiAgICogVGhpcyBpcyBoZWxwZnVsIHdoZW4gZGVidWdnaW5nIG5vZGVzIGluIG1ldGhvZCBjaGFpbnMuXG4gICAqIEBwYXJhbSBmblxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICB0YXAoaW50ZXJjZXB0ZXIpIHtcbiAgICBpbnRlcmNlcHRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltYXJpbHkgdXNlZnVsIGZvciBIT0NzIChoaWdoZXItb3JkZXIgY29tcG9uZW50cyksIHRoaXMgbWV0aG9kIG1heSBvbmx5IGJlXG4gICAqIHJ1biBvbiBhIHNpbmdsZSwgbm9uLURPTSBub2RlLCBhbmQgd2lsbCByZXR1cm4gdGhlIG5vZGUsIHNoYWxsb3ctcmVuZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgY29uc3QgbmFtZSA9ICdkaXZlJztcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUobmFtZSwgKG4pID0+IHtcbiAgICAgIGlmIChuICYmIG4ubm9kZVR5cGUgPT09ICdob3N0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTaGFsbG93V3JhcHBlcjo6JHtuYW1lfSgpIGNhbiBub3QgYmUgY2FsbGVkIG9uIEhvc3QgQ29tcG9uZW50c2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgZWwgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pLm5vZGVUb0VsZW1lbnQobik7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudChlbCwgYWRhcHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2hhbGxvd1dyYXBwZXI6OiR7bmFtZX0oKSBjYW4gb25seSBiZSBjYWxsZWQgb24gY29tcG9uZW50c2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRPcHRpb25zID0gbWFrZUluaGVyaXRlZENoaWxkT3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLndyYXAoZWwsIG51bGwsIGNoaWxkT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXBzIG91dCBhbGwgdGhlIG5vdCBob3N0LW5vZGVzIGZyb20gdGhlIGxpc3Qgb2Ygbm9kZXNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgaG9zdCBub2Rlc1xuICAgKiAoYWN0dWFsbHkgcmVuZGVyZWQgSFRNTCBlbGVtZW50cykgaWdub3JpbmcgdGhlIFJlYWN0IG5vZGVzLlxuICAgKi9cbiAgaG9zdE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldoZXJlKChuKSA9PiB0eXBlb2Ygbi50eXBlKCkgPT09ICdzdHJpbmcnKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGNvbnRleHQgb2YgdGhlIHByaW1hcnkgd3JhcHBlciB3aGVuIHRoZVxuICogYHdyYXBwaW5nQ29tcG9uZW50YCByZS1yZW5kZXJzLlxuICovXG5mdW5jdGlvbiB1cGRhdGVQcmltYXJ5Um9vdENvbnRleHQod3JhcHBpbmdDb21wb25lbnQpIHtcbiAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIod3JhcHBpbmdDb21wb25lbnRbT1BUSU9OU10pO1xuICBjb25zdCBwcmltYXJ5V3JhcHBlciA9IHdyYXBwaW5nQ29tcG9uZW50W1BSSU1BUllfV1JBUFBFUl07XG4gIGNvbnN0IHByaW1hcnlSZW5kZXJlciA9IHByaW1hcnlXcmFwcGVyW1JFTkRFUkVSXTtcbiAgY29uc3QgcHJpbWFyeU5vZGUgPSBwcmltYXJ5UmVuZGVyZXIuZ2V0Tm9kZSgpO1xuICBjb25zdCB7XG4gICAgbGVnYWN5Q29udGV4dCxcbiAgICBwcm92aWRlclZhbHVlcyxcbiAgfSA9IGdldENvbnRleHRGcm9tV3JhcHBpbmdDb21wb25lbnQod3JhcHBpbmdDb21wb25lbnQsIGFkYXB0ZXIpO1xuICBjb25zdCBwcmV2UHJvdmlkZXJWYWx1ZXMgPSBwcmltYXJ5V3JhcHBlcltQUk9WSURFUl9WQUxVRVNdO1xuXG4gIHByaW1hcnlXcmFwcGVyLnNldENvbnRleHQoe1xuICAgIC4uLndyYXBwaW5nQ29tcG9uZW50W1BSSU1BUllfV1JBUFBFUl1bT1BUSU9OU10uY29udGV4dCxcbiAgICAuLi5sZWdhY3lDb250ZXh0LFxuICB9KTtcbiAgcHJpbWFyeVdyYXBwZXJbUFJPVklERVJfVkFMVUVTXSA9IG5ldyBNYXAoWy4uLnByZXZQcm92aWRlclZhbHVlcywgLi4ucHJvdmlkZXJWYWx1ZXNdKTtcblxuICBpZiAodHlwZW9mIGFkYXB0ZXIuaXNDb250ZXh0Q29uc3VtZXIgPT09ICdmdW5jdGlvbicgJiYgYWRhcHRlci5pc0NvbnRleHRDb25zdW1lcihwcmltYXJ5Tm9kZS50eXBlKSkge1xuICAgIGNvbnN0IENvbnN1bWVyID0gcHJpbWFyeU5vZGUudHlwZTtcbiAgICAvLyBBZGFwdGVycyB3aXRoIGFuIGBpc0NvbnRleHRDb25zdW1lcmAgbWV0aG9kIHdpbGwgZGVmaW5pdGVseSBoYXZlIGEgYGdldFByb3ZpZGVyRnJvbUNvbnN1bWVyYFxuICAgIC8vIG1ldGhvZC5cbiAgICBjb25zdCBQcm92aWRlciA9IGFkYXB0ZXIuZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJvdmlkZXJWYWx1ZXMuZ2V0KFByb3ZpZGVyKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHByZXZQcm92aWRlclZhbHVlcy5nZXQoUHJvdmlkZXIpO1xuXG4gICAgLy8gVXNlIHJlZmVyZW50aWFsIGNvbXBhcmlzb24gbGlrZSBSZWFjdFxuICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHByaW1hcnlXcmFwcGVyLnJlcmVuZGVyKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSAqc3BlY2lhbCogXCJyb290XCIgd3JhcHBlciB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbXBvbmVudCBwYXNzZWQgYXMgYHdyYXBwaW5nQ29tcG9uZW50YC5cbiAqIEl0IGlzIGxpbmtlZCB0byB0aGUgcHJpbWFyeSByb290IHN1Y2ggdGhhdCB1cGRhdGVzIHRvIGl0IHdpbGwgdXBkYXRlIHRoZSBwcmltYXJ5LlxuICpcbiAqIEBjbGFzcyBXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXJcbiAqL1xuY2xhc3MgV3JhcHBpbmdDb21wb25lbnRXcmFwcGVyIGV4dGVuZHMgU2hhbGxvd1dyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihub2Rlcywgcm9vdCwgUm9vdEZpbmRlcikge1xuICAgIHN1cGVyKG5vZGVzKTtcbiAgICBwcml2YXRlU2V0KHRoaXMsIFBSSU1BUllfV1JBUFBFUiwgcm9vdCk7XG4gICAgcHJpdmF0ZVNldCh0aGlzLCBST09UX0ZJTkRFUiwgUm9vdEZpbmRlcik7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSByZXJlbmRlcigpIG9uIFNoYWxsb3dXcmFwcGVyLCBleGNlcHQgaXQgYWxzbyBkb2VzIGEgXCJmdWxsIHJlbmRlclwiIG9mXG4gICAqIGl0c2VsZiBhbmQgdXBkYXRlcyB0aGUgcHJpbWFyeSBTaGFsbG93V3JhcHBlcidzIGNvbnRleHQuXG4gICAqL1xuICByZXJlbmRlciguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucmVyZW5kZXIoLi4uYXJncyk7XG4gICAgdXBkYXRlUHJpbWFyeVJvb3RDb250ZXh0KHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSBzZXRTdGF0ZSgpIG9uIFNoYWxsb3dXcmFwcGVyLCBleGNlcHQgaXQgYWxzbyBkb2VzIGEgXCJmdWxsIHJlbmRlclwiIG9mXG4gICAqIGl0c2VsZiBhbmQgdXBkYXRlcyB0aGUgcHJpbWFyeSBTaGFsbG93V3JhcHBlcidzIGNvbnRleHQuXG4gICAqL1xuICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuc2V0U3RhdGUoLi4uYXJncyk7XG4gICAgdXBkYXRlUHJpbWFyeVJvb3RDb250ZXh0KHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBnZXRXcmFwcGluZ0NvbXBvbmVudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpnZXRXcmFwcGluZ0NvbXBvbmVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICB9XG59XG5cbmlmIChJVEVSQVRPUl9TWU1CT0wpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNoYWxsb3dXcmFwcGVyLnByb3RvdHlwZSwgSVRFUkFUT1JfU1lNQk9MLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKVtJVEVSQVRPUl9TWU1CT0xdKCk7XG4gICAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtJVEVSQVRPUl9TWU1CT0xdKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlci5uZXh0KCk7XG4gICAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogYWRhcHRlci5ub2RlVG9FbGVtZW50KG5leHQudmFsdWUpLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcml2YXRlV2FybmluZyhwcm9wLCBleHRyYU1lc3NhZ2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNoYWxsb3dXcmFwcGVyLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIEF0dGVtcHRlZCB0byBhY2Nlc3MgU2hhbGxvd1dyYXBwZXI6OiR7cHJvcH0sIHdoaWNoIHdhcyBwcmV2aW91c2x5IGEgcHJpdmF0ZSBwcm9wZXJ0eSBvblxuICAgICAgICBFbnp5bWUgU2hhbGxvd1dyYXBwZXIgaW5zdGFuY2VzLCBidXQgaXMgbm8gbG9uZ2VyIGFuZCBzaG91bGQgbm90IGJlIHJlbGllZCB1cG9uLlxuICAgICAgICAke2V4dHJhTWVzc2FnZX1cbiAgICAgIGApO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgfSk7XG59XG5cbnByaXZhdGVXYXJuaW5nKCdub2RlJywgJ0NvbnNpZGVyIHVzaW5nIHRoZSBnZXRFbGVtZW50KCkgbWV0aG9kIGluc3RlYWQuJyk7XG5wcml2YXRlV2FybmluZygnbm9kZXMnLCAnQ29uc2lkZXIgdXNpbmcgdGhlIGdldEVsZW1lbnRzKCkgbWV0aG9kIGluc3RlYWQuJyk7XG5wcml2YXRlV2FybmluZygncmVuZGVyZXInLCAnJyk7XG5wcml2YXRlV2FybmluZygnb3B0aW9ucycsICcnKTtcbnByaXZhdGVXYXJuaW5nKCdjb21wbGV4U2VsZWN0b3InLCAnJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoYWxsb3dXcmFwcGVyO1xuIl19