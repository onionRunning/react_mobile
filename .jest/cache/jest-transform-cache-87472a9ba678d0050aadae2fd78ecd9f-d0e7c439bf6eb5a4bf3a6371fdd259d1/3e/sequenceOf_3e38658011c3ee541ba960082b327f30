a1a526fe38b85a753abf9f7387fa703b
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = sequenceOfValidator;

var _propTypes = require("prop-types");

var _and = _interopRequireDefault(require("./and"));

var _between = _interopRequireDefault(require("./between"));

var _nonNegativeInteger = _interopRequireDefault(require("./nonNegativeInteger"));

var _object = _interopRequireDefault(require("./object"));

var _withShape = _interopRequireDefault(require("./withShape"));

var _typeOf = _interopRequireDefault(require("./helpers/typeOf"));

var _wrapValidator = _interopRequireDefault(require("./helpers/wrapValidator"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var minValidator = _nonNegativeInteger["default"];
var maxValidator = (0, _and["default"])([_nonNegativeInteger["default"], (0, _between["default"])({
  gte: 1
})]);

function validateRange(min, max) {
  if (typeof max !== 'number' || typeof min !== 'number') {
    return null; // no additional checking needed unless both are present
  }

  if (min <= max) {
    return null;
  }

  return new RangeError('min must be less than or equal to max');
}

var specifierShape = {
  validator: function validator(props, propName) {
    var propValue = props[propName];

    if (typeof propValue !== 'function') {
      return new TypeError('"validator" must be a propType validator function');
    }

    return null;
  },
  min: function min(props, propName) {
    return minValidator(props, propName) || validateRange(props.min, props.max);
  },
  max: function max(props, propName) {
    return maxValidator(props, propName) || validateRange(props.min, props.max);
  }
};

function getMinMax(_ref) {
  var min = _ref.min,
      max = _ref.max;
  var minimum;
  var maximum;

  if (typeof min !== 'number' && typeof max !== 'number') {
    // neither provided, default to "1"
    minimum = 1;
    maximum = 1;
  } else {
    minimum = typeof min === 'number' ? min : 1;
    maximum = typeof max === 'number' ? max : Infinity;
  }

  return {
    minimum: minimum,
    maximum: maximum
  };
}

function chunkByType(items) {
  var chunk = [];
  var lastType;
  return items.reduce(function (chunks, item) {
    var itemType = (0, _typeOf["default"])(item);

    if (!lastType || itemType === lastType) {
      chunk.push(item);
    } else {
      chunks.push(chunk);
      chunk = [item];
    }

    lastType = itemType;
    return chunks;
  }, []).concat(chunk.length > 0 ? [chunk] : []);
}

function validateChunks(specifiers, props, propName, componentName) {
  var items = props[propName];
  var chunks = chunkByType(items);

  for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
    rest[_key - 4] = arguments[_key];
  }

  for (var i = 0; i < specifiers.length; i += 1) {
    var _specifiers$i = specifiers[i],
        validator = _specifiers$i.validator,
        min = _specifiers$i.min,
        max = _specifiers$i.max;

    var _getMinMax = getMinMax({
      min: min,
      max: max
    }),
        minimum = _getMinMax.minimum,
        maximum = _getMinMax.maximum;

    if (chunks.length === 0 && minimum === 0) {
      // no chunks left, but this specifier does not require any items
      continue; // eslint-disable-line no-continue
    }

    var arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;
    var chunk = chunks.shift(); // extract the next chunk to test

    var chunkError = arrayOfValidator.apply(void 0, [_objectSpread({}, props, _defineProperty({}, propName, chunk)), propName, componentName].concat(rest));

    if (chunkError) {
      // this chunk is invalid
      if (minimum === 0) {
        // but, specifier has a min of 0 and can be skipped
        chunks.unshift(chunk); // put the chunk back, for the next iteration

        continue; // eslint-disable-line no-continue
      }

      return chunkError;
    } // chunk is valid!


    if (chunk.length < minimum) {
      return new RangeError("".concat(componentName, ": specifier index ").concat(i, " requires a minimum of ").concat(min, " items, but only has ").concat(chunk.length, "."));
    }

    if (chunk.length > maximum) {
      return new RangeError("".concat(componentName, ": specifier index ").concat(i, " requires a maximum of ").concat(max, " items, but has ").concat(chunk.length, "."));
    }
  }

  if (chunks.length > 0) {
    return new TypeError("".concat(componentName, ": after all ").concat(specifiers.length, " specifiers matched, ").concat(chunks.length, " types of items were remaining."));
  }

  return null;
}

var specifierValidator = (0, _withShape["default"])((0, _object["default"])(), specifierShape).isRequired;

function sequenceOfValidator() {
  for (var _len2 = arguments.length, specifiers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    specifiers[_key2] = arguments[_key2];
  }

  if (specifiers.length === 0) {
    throw new RangeError('sequenceOf: at least one specifier is required');
  }

  var errors = specifiers.map(function (specifier, i) {
    return specifierValidator({
      specifier: specifier
    }, 'specifier', 'sequenceOf specifier', "suequenceOf specifier, index ".concat(i), "specifier, index ".concat(i));
  });

  if (errors.some(Boolean)) {
    throw new TypeError("\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ".concat(errors.map(function (e, i) {
      return " - Argument index ".concat(i, ": ").concat(e.message);
    }).join(',\n        '), "\n    "));
  }

  var validator = function sequenceOf(props, propName) {
    var propValue = props[propName];

    if (propValue == null) {
      return null;
    }

    for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      rest[_key3 - 2] = arguments[_key3];
    }

    var error = _propTypes.array.apply(void 0, [props, propName].concat(rest));

    if (error) {
      return error;
    }

    return validateChunks.apply(void 0, [specifiers, props, propName].concat(rest));
  };

  validator.isRequired = function sequenceOfRequired(props, propName, componentName) {
    for (var _len4 = arguments.length, rest = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
      rest[_key4 - 3] = arguments[_key4];
    }

    var error = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));

    if (error) {
      return error;
    }

    return validateChunks.apply(void 0, [specifiers, props, propName, componentName].concat(rest));
  };

  return (0, _wrapValidator["default"])(validator, 'sequenceOf', specifiers);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zZXF1ZW5jZU9mLmpzIl0sIm5hbWVzIjpbIm1pblZhbGlkYXRvciIsIm5vbk5lZ2F0aXZlSW50ZWdlciIsIm1heFZhbGlkYXRvciIsImd0ZSIsIm1pbiIsInNwZWNpZmllclNoYXBlIiwidmFsaWRhdG9yIiwicHJvcFZhbHVlIiwicHJvcHMiLCJ2YWxpZGF0ZVJhbmdlIiwibWF4IiwibWluaW11bSIsIm1heGltdW0iLCJjaHVuayIsIml0ZW1UeXBlIiwiY2h1bmtzIiwibGFzdFR5cGUiLCJyZXN0IiwiaXRlbXMiLCJjaHVua0J5VHlwZSIsImkiLCJzcGVjaWZpZXJzIiwiZ2V0TWluTWF4IiwiYXJyYXlPZlZhbGlkYXRvciIsImNodW5rRXJyb3IiLCJzcGVjaWZpZXJWYWxpZGF0b3IiLCJlcnJvcnMiLCJzcGVjaWZpZXIiLCJlIiwiZXJyb3IiLCJhcnJheSIsInZhbGlkYXRlQ2h1bmtzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBQSxVQUFBLEdBQUEsT0FBQSxDQUFBLFlBQUEsQ0FBQTs7QUFFQSxJQUFBLElBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFFBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLG1CQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsVUFBQSxHQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGFBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGtCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGNBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUEsS0FBQUEsQ0FBQUEsVUFBQUEsQ0FBQUEsS0FBQUEsQ0FBQUEsVUFBQUEsQ0FBQUEsS0FBQUEsRUFBQUEsQ0FBQUEsS0FBQUEsRUFBQUEsUUFBQUEsRUFBQUEsYUFBQUEsRUFBQUEsTUFBQUEsQ0FBZCxJQUFjQSxDQUFBQSxDQUFkOztBQUNBLFFBQUEsS0FBQSxFQUFXO0FBQ1QsYUFBQSxLQUFBO0FBQ0Q7O0FBRUQsV0FBT0MsY0FBYyxDQUFkQSxLQUFBQSxDQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxVQUFBQSxFQUFBQSxLQUFBQSxFQUFBQSxRQUFBQSxFQUFBQSxhQUFBQSxFQUFBQSxNQUFBQSxDQUFQLElBQU9BLENBQUFBLENBQVA7QUFORnpCLEdBQUFBOztBQVNBLFNBQU8sQ0FBQSxHQUFBLGNBQUEsQ0FBQSxTQUFBLENBQUEsRUFBQSxTQUFBLEVBQUEsWUFBQSxFQUFQLFVBQU8sQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXJyYXksIGFycmF5T2YgfSBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IGFuZCBmcm9tICcuL2FuZCc7XG5pbXBvcnQgYmV0d2VlbiBmcm9tICcuL2JldHdlZW4nO1xuaW1wb3J0IG5vbk5lZ2F0aXZlSW50ZWdlciBmcm9tICcuL25vbk5lZ2F0aXZlSW50ZWdlcic7XG5pbXBvcnQgb2JqZWN0IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCB3aXRoU2hhcGUgZnJvbSAnLi93aXRoU2hhcGUnO1xuaW1wb3J0IHR5cGVPZiBmcm9tICcuL2hlbHBlcnMvdHlwZU9mJztcbmltcG9ydCB3cmFwVmFsaWRhdG9yIGZyb20gJy4vaGVscGVycy93cmFwVmFsaWRhdG9yJztcblxuY29uc3QgbWluVmFsaWRhdG9yID0gbm9uTmVnYXRpdmVJbnRlZ2VyO1xuY29uc3QgbWF4VmFsaWRhdG9yID0gYW5kKFtub25OZWdhdGl2ZUludGVnZXIsIGJldHdlZW4oeyBndGU6IDEgfSldKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZShtaW4sIG1heCkge1xuICBpZiAodHlwZW9mIG1heCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIG1pbiAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm8gYWRkaXRpb25hbCBjaGVja2luZyBuZWVkZWQgdW5sZXNzIGJvdGggYXJlIHByZXNlbnRcbiAgfVxuXG4gIGlmIChtaW4gPD0gbWF4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKCdtaW4gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4Jyk7XG59XG5cbmNvbnN0IHNwZWNpZmllclNoYXBlID0ge1xuICB2YWxpZGF0b3IocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgY29uc3QgeyBbcHJvcE5hbWVdOiBwcm9wVmFsdWUgfSA9IHByb3BzO1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignXCJ2YWxpZGF0b3JcIiBtdXN0IGJlIGEgcHJvcFR5cGUgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIG1pbihwcm9wcywgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gbWluVmFsaWRhdG9yKHByb3BzLCBwcm9wTmFtZSkgfHwgdmFsaWRhdGVSYW5nZShwcm9wcy5taW4sIHByb3BzLm1heCk7XG4gIH0sXG5cbiAgbWF4KHByb3BzLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBtYXhWYWxpZGF0b3IocHJvcHMsIHByb3BOYW1lKSB8fCB2YWxpZGF0ZVJhbmdlKHByb3BzLm1pbiwgcHJvcHMubWF4KTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldE1pbk1heCh7IG1pbiwgbWF4IH0pIHtcbiAgbGV0IG1pbmltdW07XG4gIGxldCBtYXhpbXVtO1xuICBpZiAodHlwZW9mIG1pbiAhPT0gJ251bWJlcicgJiYgdHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBuZWl0aGVyIHByb3ZpZGVkLCBkZWZhdWx0IHRvIFwiMVwiXG4gICAgbWluaW11bSA9IDE7XG4gICAgbWF4aW11bSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgbWluaW11bSA9IHR5cGVvZiBtaW4gPT09ICdudW1iZXInID8gbWluIDogMTtcbiAgICBtYXhpbXVtID0gdHlwZW9mIG1heCA9PT0gJ251bWJlcicgPyBtYXggOiBJbmZpbml0eTtcbiAgfVxuICByZXR1cm4geyBtaW5pbXVtLCBtYXhpbXVtIH07XG59XG5cbmZ1bmN0aW9uIGNodW5rQnlUeXBlKGl0ZW1zKSB7XG4gIGxldCBjaHVuayA9IFtdO1xuICBsZXQgbGFzdFR5cGU7XG4gIHJldHVybiBpdGVtcy5yZWR1Y2UoKGNodW5rcywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZU9mKGl0ZW0pO1xuICAgIGlmICghbGFzdFR5cGUgfHwgaXRlbVR5cGUgPT09IGxhc3RUeXBlKSB7XG4gICAgICBjaHVuay5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICBjaHVuayA9IFtpdGVtXTtcbiAgICB9XG4gICAgbGFzdFR5cGUgPSBpdGVtVHlwZTtcbiAgICByZXR1cm4gY2h1bmtzO1xuICB9LCBbXSkuY29uY2F0KGNodW5rLmxlbmd0aCA+IDAgPyBbY2h1bmtdIDogW10pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNodW5rcyhzcGVjaWZpZXJzLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIC4uLnJlc3QpIHtcbiAgY29uc3QgeyBbcHJvcE5hbWVdOiBpdGVtcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNodW5rcyA9IGNodW5rQnlUeXBlKGl0ZW1zKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWNpZmllcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCB7IHZhbGlkYXRvciwgbWluLCBtYXggfSA9IHNwZWNpZmllcnNbaV07XG5cbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0gfSA9IGdldE1pbk1heCh7IG1pbiwgbWF4IH0pO1xuXG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgJiYgbWluaW11bSA9PT0gMCkge1xuICAgICAgLy8gbm8gY2h1bmtzIGxlZnQsIGJ1dCB0aGlzIHNwZWNpZmllciBkb2VzIG5vdCByZXF1aXJlIGFueSBpdGVtc1xuICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBhcnJheU9mVmFsaWRhdG9yID0gYXJyYXlPZih2YWxpZGF0b3IpLmlzUmVxdWlyZWQ7XG5cbiAgICBjb25zdCBjaHVuayA9IGNodW5rcy5zaGlmdCgpOyAvLyBleHRyYWN0IHRoZSBuZXh0IGNodW5rIHRvIHRlc3RcblxuICAgIGNvbnN0IGNodW5rRXJyb3IgPSBhcnJheU9mVmFsaWRhdG9yKFxuICAgICAgeyAuLi5wcm9wcywgW3Byb3BOYW1lXTogY2h1bmsgfSxcbiAgICAgIHByb3BOYW1lLFxuICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgIC4uLnJlc3QsXG4gICAgKTtcblxuICAgIGlmIChjaHVua0Vycm9yKSB7IC8vIHRoaXMgY2h1bmsgaXMgaW52YWxpZFxuICAgICAgaWYgKG1pbmltdW0gPT09IDApIHsgLy8gYnV0LCBzcGVjaWZpZXIgaGFzIGEgbWluIG9mIDAgYW5kIGNhbiBiZSBza2lwcGVkXG4gICAgICAgIGNodW5rcy51bnNoaWZ0KGNodW5rKTsgLy8gcHV0IHRoZSBjaHVuayBiYWNrLCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtFcnJvcjtcbiAgICB9XG5cbiAgICAvLyBjaHVuayBpcyB2YWxpZCFcblxuICAgIGlmIChjaHVuay5sZW5ndGggPCBtaW5pbXVtKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoYCR7Y29tcG9uZW50TmFtZX06IHNwZWNpZmllciBpbmRleCAke2l9IHJlcXVpcmVzIGEgbWluaW11bSBvZiAke21pbn0gaXRlbXMsIGJ1dCBvbmx5IGhhcyAke2NodW5rLmxlbmd0aH0uYCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLmxlbmd0aCA+IG1heGltdW0pIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihgJHtjb21wb25lbnROYW1lfTogc3BlY2lmaWVyIGluZGV4ICR7aX0gcmVxdWlyZXMgYSBtYXhpbXVtIG9mICR7bWF4fSBpdGVtcywgYnV0IGhhcyAke2NodW5rLmxlbmd0aH0uYCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7Y29tcG9uZW50TmFtZX06IGFmdGVyIGFsbCAke3NwZWNpZmllcnMubGVuZ3RofSBzcGVjaWZpZXJzIG1hdGNoZWQsICR7Y2h1bmtzLmxlbmd0aH0gdHlwZXMgb2YgaXRlbXMgd2VyZSByZW1haW5pbmcuYCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3Qgc3BlY2lmaWVyVmFsaWRhdG9yID0gd2l0aFNoYXBlKG9iamVjdCgpLCBzcGVjaWZpZXJTaGFwZSkuaXNSZXF1aXJlZDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVuY2VPZlZhbGlkYXRvciguLi5zcGVjaWZpZXJzKSB7XG4gIGlmIChzcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzZXF1ZW5jZU9mOiBhdCBsZWFzdCBvbmUgc3BlY2lmaWVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBjb25zdCBlcnJvcnMgPSBzcGVjaWZpZXJzLm1hcCgoc3BlY2lmaWVyLCBpKSA9PiBzcGVjaWZpZXJWYWxpZGF0b3IoXG4gICAgeyBzcGVjaWZpZXIgfSxcbiAgICAnc3BlY2lmaWVyJyxcbiAgICAnc2VxdWVuY2VPZiBzcGVjaWZpZXInLFxuICAgIGBzdWVxdWVuY2VPZiBzcGVjaWZpZXIsIGluZGV4ICR7aX1gLFxuICAgIGBzcGVjaWZpZXIsIGluZGV4ICR7aX1gLFxuICApKTtcbiAgaWYgKGVycm9ycy5zb21lKEJvb2xlYW4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXG4gICAgICBzZXF1ZW5jZU9mOiBhbGwgc3BlY2lmaWVycyBtdXN0IG1hdGNoIHRoZSBhcHByb3ByaWF0ZSBzaGFwZS5cblxuICAgICAgRXJyb3JzOlxuICAgICAgICAke2Vycm9ycy5tYXAoKGUsIGkpID0+IGAgLSBBcmd1bWVudCBpbmRleCAke2l9OiAke2UubWVzc2FnZX1gKS5qb2luKCcsXFxuICAgICAgICAnKX1cbiAgICBgKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIHNlcXVlbmNlT2YocHJvcHMsIHByb3BOYW1lLCAuLi5yZXN0KSB7XG4gICAgY29uc3QgeyBbcHJvcE5hbWVdOiBwcm9wVmFsdWUgfSA9IHByb3BzO1xuXG4gICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IGFycmF5KHByb3BzLCBwcm9wTmFtZSwgLi4ucmVzdCk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlQ2h1bmtzKHNwZWNpZmllcnMsIHByb3BzLCBwcm9wTmFtZSwgLi4ucmVzdCk7XG4gIH07XG5cbiAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBzZXF1ZW5jZU9mUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCAuLi5yZXN0KSB7XG4gICAgY29uc3QgZXJyb3IgPSBhcnJheS5pc1JlcXVpcmVkKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgLi4ucmVzdCk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlQ2h1bmtzKHNwZWNpZmllcnMsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgLi4ucmVzdCk7XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBWYWxpZGF0b3IodmFsaWRhdG9yLCAnc2VxdWVuY2VPZicsIHNwZWNpZmllcnMpO1xufVxuIl19