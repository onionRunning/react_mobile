{"version":3,"sources":["../src/sequenceOf.js"],"names":["minValidator","nonNegativeInteger","maxValidator","gte","min","specifierShape","validator","propValue","props","validateRange","max","minimum","maximum","chunk","itemType","chunks","lastType","rest","items","chunkByType","i","specifiers","getMinMax","arrayOfValidator","chunkError","specifierValidator","errors","specifier","e","error","array","validateChunks"],"mappings":"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","sourcesContent":["import { array, arrayOf } from 'prop-types';\n\nimport and from './and';\nimport between from './between';\nimport nonNegativeInteger from './nonNegativeInteger';\nimport object from './object';\nimport withShape from './withShape';\nimport typeOf from './helpers/typeOf';\nimport wrapValidator from './helpers/wrapValidator';\n\nconst minValidator = nonNegativeInteger;\nconst maxValidator = and([nonNegativeInteger, between({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nconst specifierShape = {\n  validator(props, propName) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n    return null;\n  },\n\n  min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n\n  max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  },\n};\n\nfunction getMinMax({ min, max }) {\n  let minimum;\n  let maximum;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum, maximum };\n}\n\nfunction chunkByType(items) {\n  let chunk = [];\n  let lastType;\n  return items.reduce((chunks, item) => {\n    const itemType = typeOf(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName, ...rest) {\n  const { [propName]: items } = props;\n  const chunks = chunkByType(items);\n\n  for (let i = 0; i < specifiers.length; i += 1) {\n    const { validator, min, max } = specifiers[i];\n\n    const { minimum, maximum } = getMinMax({ min, max });\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    const arrayOfValidator = arrayOf(validator).isRequired;\n\n    const chunk = chunks.shift(); // extract the next chunk to test\n\n    const chunkError = arrayOfValidator(\n      { ...props, [propName]: chunk },\n      propName,\n      componentName,\n      ...rest,\n    );\n\n    if (chunkError) { // this chunk is invalid\n      if (minimum === 0) { // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a minimum of ${min} items, but only has ${chunk.length}.`);\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a maximum of ${max} items, but has ${chunk.length}.`);\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(`${componentName}: after all ${specifiers.length} specifiers matched, ${chunks.length} types of items were remaining.`);\n  }\n\n  return null;\n}\n\nconst specifierValidator = withShape(object(), specifierShape).isRequired;\n\nexport default function sequenceOfValidator(...specifiers) {\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  const errors = specifiers.map((specifier, i) => specifierValidator(\n    { specifier },\n    'specifier',\n    'sequenceOf specifier',\n    `suequenceOf specifier, index ${i}`,\n    `specifier, index ${i}`,\n  ));\n  if (errors.some(Boolean)) {\n    throw new TypeError(`\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ${errors.map((e, i) => ` - Argument index ${i}: ${e.message}`).join(',\\n        ')}\n    `);\n  }\n\n  const validator = function sequenceOf(props, propName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return null;\n    }\n\n    const error = array(props, propName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, ...rest);\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName, ...rest) {\n    const error = array.isRequired(props, propName, componentName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, 'sequenceOf', specifiers);\n}\n"]}