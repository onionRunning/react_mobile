ba8ecca77abcd90048943f3a7877d205
/** MobX - (c) Michel Weststrate 2015 - 2020 - MIT Licensed */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

var OBFUSCATED_ERROR = "An invariant failed, however the error is obfuscated because this is an production build.";
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var mockGlobal = {};

function getGlobal() {
  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

function getNextId() {
  return ++globalState.mobxGuid;
}

function fail(message) {
  invariant(false, message);
  throw "X"; // unreachable
}

function invariant(check, message) {
  if (!check) throw new Error("[mobx] " + (message || OBFUSCATED_ERROR));
}
/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */


var deprecatedMessages = [];

function deprecated(msg, thing) {
  if (thing) {
    return deprecated("'" + msg + "', use '" + thing + "' instead.");
  }

  if (deprecatedMessages.indexOf(msg) !== -1) return false;
  deprecatedMessages.push(msg);
  console.error("[mobx] Deprecated: " + msg);
  return true;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */


function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}

var noop = function () {};

function unique(list) {
  var res = [];
  list.forEach(function (item) {
    if (res.indexOf(item) === -1) res.push(item);
  });
  return res;
}

function isObject(value) {
  return value !== null && typeof value === "object";
}

function isPlainObject(value) {
  if (value === null || typeof value !== "object") return false;
  var proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    return new Map(Object.entries(dataStructure));
  } else {
    return fail("Cannot convert to map from '" + dataStructure + "'");
  }
}

function makeNonEnumerable(object, propNames) {
  for (var i = 0; i < propNames.length; i++) {
    addHiddenProp(object, propNames[i], object[propNames[i]]);
  }
}

function addHiddenProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}

function addHiddenFinalProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}

function isPropertyConfigurable(object, prop) {
  var descriptor = Object.getOwnPropertyDescriptor(object, prop);
  return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;
}

function assertPropertyConfigurable(object, prop) {
  if (!isPropertyConfigurable(object, prop)) fail("Cannot make property '" + prop + "' observable, it is not configurable and writable in the target object");
}

function createInstanceofPredicate(name, clazz) {
  var propName = "isMobX" + name;
  clazz.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}

function areBothNaN(a, b) {
  return typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
/**
 * Returns whether the argument is an array, disregarding observability.
 */


function isArrayLike(x) {
  return Array.isArray(x) || isObservableArray(x);
}

function isES6Map(thing) {
  if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;
  return false;
}

function isES6Set(thing) {
  return thing instanceof Set;
} // use Array.from in Mobx 5


function iteratorToArray(it) {
  var res = [];

  while (true) {
    var r = it.next();
    if (r.done) break;
    res.push(r.value);
  }

  return res;
}

function primitiveSymbol() {
  // es-disable-next-line
  return typeof Symbol === "function" && Symbol.toPrimitive || "@@toPrimitive";
}

function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}

function iteratorSymbol() {
  return typeof Symbol === "function" && Symbol.iterator || "@@iterator";
}

function declareIterator(prototType, iteratorFactory) {
  addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);
}

function makeIterable(iterator) {
  iterator[iteratorSymbol()] = getSelf;
  return iterator;
}

function toStringTagSymbol() {
  return typeof Symbol === "function" && Symbol.toStringTag || "@@toStringTag";
}

function getSelf() {
  return this;
}
/**
 * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs
 *
 * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used
 * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom.
 */


var Atom =
/** @class */
function () {
  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name) {
    if (name === void 0) {
      name = "Atom@" + getNextId();
    }

    this.name = name;
    this.isPendingUnobservation = false; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

    this.isBeingObserved = false;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = exports.IDerivationState.NOT_TRACKING;
  }

  Atom.prototype.onBecomeUnobserved = function () {// noop
  };

  Atom.prototype.onBecomeObserved = function () {
    /* noop */
  };
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */


  Atom.prototype.reportObserved = function () {
    return reportObserved(this);
  };
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */


  Atom.prototype.reportChanged = function () {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  Atom.prototype.toString = function () {
    return this.name;
  };

  return Atom;
}();

var isAtom = createInstanceofPredicate("Atom", Atom);

function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name);
  onBecomeObserved(atom, onBecomeObservedHandler);
  onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  return areBothNaN(a, b) || identityComparer(a, b);
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
var enumerableDescriptorCache = {};
var nonEnumerableDescriptorCache = {};

function createPropertyInitializerDescriptor(prop, enumerable) {
  var cache = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
  return cache[prop] || (cache[prop] = {
    configurable: true,
    enumerable: enumerable,
    get: function () {
      initializeInstance(this);
      return this[prop];
    },
    set: function (value) {
      initializeInstance(this);
      this[prop] = value;
    }
  });
}

function initializeInstance(target) {
  if (target.__mobxDidRunLazyInitializers === true) return;
  var decorators = target.__mobxDecorators;

  if (decorators) {
    addHiddenProp(target, "__mobxDidRunLazyInitializers", true);

    for (var key in decorators) {
      var d = decorators[key];
      d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments);
    }
  }
}

function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
  return function decoratorFactory() {
    var decoratorArguments;

    var decorator = function decorate(target, prop, descriptor, applyImmediately // This is a special parameter to signal the direct application of a decorator, allow extendObservable to skip the entire type decoration part,
    // as the instance to apply the decorator to equals the target
    ) {
      if (applyImmediately === true) {
        propertyCreator(target, prop, descriptor, target, decoratorArguments);
        return null;
      }

      if (!quacksLikeADecorator(arguments)) fail("This function is a decorator, but it wasn't invoked like a decorator");

      if (!Object.prototype.hasOwnProperty.call(target, "__mobxDecorators")) {
        var inheritedDecorators = target.__mobxDecorators;
        addHiddenProp(target, "__mobxDecorators", __assign({}, inheritedDecorators));
      }

      target.__mobxDecorators[prop] = {
        prop: prop,
        propertyCreator: propertyCreator,
        descriptor: descriptor,
        decoratorTarget: target,
        decoratorArguments: decoratorArguments
      };
      return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
    };

    if (quacksLikeADecorator(arguments)) {
      // @decorator
      decoratorArguments = EMPTY_ARRAY;
      return decorator.apply(null, arguments);
    } else {
      // @decorator(args)
      decoratorArguments = Array.prototype.slice.call(arguments);
      return decorator;
    }
  };
}

function quacksLikeADecorator(args) {
  return (args.length === 2 || args.length === 3) && typeof args[1] === "string" || args.length === 4 && args[3] === true;
}

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });
  return v;
}

function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  return fail("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}

function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}

function refStructEnhancer(v, oldValue, name) {
  if (isObservable(v)) throw "observable.struct should not be used with observable values";
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

function createDecoratorForEnhancer(enhancer) {
  invariant(enhancer);
  var decorator = createPropDecorator(true, function (target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
    {
      invariant(!descriptor || !descriptor.get, "@observable cannot be used on getter (property \"" + propertyName + "\"), use @computed instead.");
    }
    var initialValue = descriptor ? descriptor.initializer ? descriptor.initializer.call(target) : descriptor.value : undefined;
    defineObservableProperty(target, propertyName, initialValue, enhancer);
  });
  var res = // Extra process checks, as this happens during module initialization
  typeof process !== "undefined" && process.env && "development" !== "production" ? function observableDecorator() {
    // This wrapper function is just to detect illegal decorator invocations, deprecate in a next version
    // and simply return the created prop decorator
    if (arguments.length < 2) return fail("Incorrect decorator invocation. @observable decorator doesn't expect any arguments");
    return decorator.apply(null, arguments);
  } : decorator;
  res.enhancer = enhancer;
  return res;
} // Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases


var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined
};
var shallowCreateObservableOptions = {
  deep: false,
  name: undefined,
  defaultDecorator: undefined
};
Object.freeze(defaultCreateObservableOptions);
Object.freeze(shallowCreateObservableOptions);

function assertValidOption(key) {
  if (!/^(deep|name|equals|defaultDecorator)$/.test(key)) fail("invalid option for (extend)observable: " + key);
}

function asCreateObservableOptions(thing) {
  if (thing === null || thing === undefined) return defaultCreateObservableOptions;
  if (typeof thing === "string") return {
    name: thing,
    deep: true
  };
  {
    if (typeof thing !== "object") return fail("expected options object");
    Object.keys(thing).forEach(assertValidOption);
  }
  return thing;
}

function getEnhancerFromOptions(options) {
  return options.defaultDecorator ? options.defaultDecorator.enhancer : options.deep === false ? referenceEnhancer : deepEnhancer;
}

var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (typeof arguments[1] === "string") {
    return deepDecorator.apply(null, arguments);
  } // it is an observable already, done


  if (isObservable(v)) return v; // something that can be converted and mutated?

  var res = isPlainObject(v) ? observable.object(v, arg2, arg3) : Array.isArray(v) ? observable.array(v, arg2) : isES6Map(v) ? observable.map(v, arg2) : isES6Set(v) ? observable.set(v, arg2) : v; // this value could be converted to a new observable data structure, return it

  if (res !== v) return res; // otherwise, just box it

  fail("The provided value could not be converted into an observable. If you want just create an observable reference to the object use 'observable.box(value)'");
}

var observableFactories = {
  box: function (value, options) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("box");
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  shallowBox: function (value, name) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("shallowBox");
    deprecated("observable.shallowBox", "observable.box(value, { deep: false })");
    return observable.box(value, {
      name: name,
      deep: false
    });
  },
  array: function (initialValues, options) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("array");
    var o = asCreateObservableOptions(options);
    return new ObservableArray(initialValues, getEnhancerFromOptions(o), o.name);
  },
  shallowArray: function (initialValues, name) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("shallowArray");
    deprecated("observable.shallowArray", "observable.array(values, { deep: false })");
    return observable.array(initialValues, {
      name: name,
      deep: false
    });
  },
  map: function (initialValues, options) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("map");
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  shallowMap: function (initialValues, name) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("shallowMap");
    deprecated("observable.shallowMap", "observable.map(values, { deep: false })");
    return observable.map(initialValues, {
      name: name,
      deep: false
    });
  },
  set: function (initialValues, options) {
    if (arguments.length > 2) incorrectlyUsedAsDecorator("set");
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function (props, decorators, options) {
    if (typeof arguments[1] === "string") incorrectlyUsedAsDecorator("object");
    var o = asCreateObservableOptions(options);
    return extendObservable({}, props, decorators, o);
  },
  shallowObject: function (props, name) {
    if (typeof arguments[1] === "string") incorrectlyUsedAsDecorator("shallowObject");
    deprecated("observable.shallowObject", "observable.object(values, {}, { deep: false })");
    return observable.object(props, {}, {
      name: name,
      deep: false
    });
  },
  ref: refDecorator,
  shallow: shallowDecorator,
  deep: deepDecorator,
  struct: refStructDecorator
};
var observable = createObservable; // weird trick to keep our typings nicely with our funcs, and still extend the observable function

Object.keys(observableFactories).forEach(function (name) {
  return observable[name] = observableFactories[name];
});

function incorrectlyUsedAsDecorator(methodName) {
  fail( // "development" !== "production" &&
  "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}

var computedDecorator = createPropDecorator(false, function (instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
  var get = descriptor.get,
      set = descriptor.set; // initialValue is the descriptor for get / set props
  // Optimization: faster on decorator target or instance? Assuming target
  // Optimization: find out if declaring on instance isn't just faster. (also makes the property descriptor simpler). But, more memory usage..
  // Forcing instance now, fixes hot reloadig issues on React Native:

  var options = decoratorArgs[0] || {};
  defineComputedProperty(instance, propertyName, __assign({
    get: get,
    set: set
  }, options));
});
var computedStructDecorator = computedDecorator({
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2, arg3) {
  if (typeof arg2 === "string") {
    // @computed
    return computedDecorator.apply(null, arguments);
  }

  if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) {
    // @computed({ options })
    return computedDecorator.apply(null, arguments);
  } // computed(expr, options?)


  {
    invariant(typeof arg1 === "function", "First argument to `computed` should be an expression.");
    invariant(arguments.length < 3, "Computed takes one or two arguments if used as function");
  }
  var opts = typeof arg2 === "object" ? arg2 : {};
  opts.get = arg1;
  opts.set = typeof arg2 === "function" ? arg2 : opts.set;
  opts.name = opts.name || arg1.name || "";
  /* for generated name */

  return new ComputedValue(opts);
};

computed.struct = computedStructDecorator;

(function (IDerivationState) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState[IDerivationState["NOT_TRACKING"] = -1] = "NOT_TRACKING"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState[IDerivationState["UP_TO_DATE"] = 0] = "UP_TO_DATE"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState[IDerivationState["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState[IDerivationState["STALE"] = 2] = "STALE";
})(exports.IDerivationState || (exports.IDerivationState = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException =
/** @class */
function () {
  function CaughtException(cause) {
    this.cause = cause; // Empty
  }

  return CaughtException;
}();

function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */


function shouldCompute(derivation) {
  switch (derivation.dependenciesState) {
    case exports.IDerivationState.UP_TO_DATE:
      return false;

    case exports.IDerivationState.NOT_TRACKING:
    case exports.IDerivationState.STALE:
      return true;

    case exports.IDerivationState.POSSIBLY_STALE:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState === exports.IDerivationState.STALE) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
} // function invariantShouldCompute(derivation: IDerivation) {
//     const newDepState = (derivation as any).dependenciesState
//     if (
//         "development" === "production" &&
//         (newDepState === IDerivationState.POSSIBLY_STALE ||
//             newDepState === IDerivationState.NOT_TRACKING)
//     )
//         fail("Illegal dependency state")
// }


function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}

function checkIfStateModificationsAreAllowed(atom) {
  var hasObservers = atom.observers.length > 0; // Should never be possible to change an observed observable from inside computed, see #798

  if (globalState.computationDepth > 0 && hasObservers) fail("Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: " + atom.name); // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "strict")) fail((globalState.enforceActions ? "Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: ") + atom.name);
}

function checkIfStateReadsAreAllowed(observable) {
  if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable " + observable.name + " being read outside a reactive context");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */


function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving = new Array(derivation.observing.length + 100);
  derivation.unboundDepsCount = 0;
  derivation.runId = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);

  if (derivation.observing.length === 0) {
    warnAboutDerivationWithoutDependencies(derivation);
  }

  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (globalState.reactionRequiresObservable || derivation.requiresObservable) {
    console.warn("[mobx] Derivation " + derivation.name + " is created/updated without reading any observable value");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing;
  var observing = derivation.observing = derivation.newObserving;
  var lowestNewObservingDerivationState = exports.IDerivationState.UP_TO_DATE; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState;
    }
  }

  observing.length = i0;
  derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var dep = prevObserving[l];

    if (dep.diffValue === 0) {
      removeObserver(dep, derivation);
    }

    dep.diffValue = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var dep = observing[i0];

    if (dep.diffValue === 1) {
      dep.diffValue = 0;
      addObserver(dep, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== exports.IDerivationState.UP_TO_DATE) {
    derivation.dependenciesState = lowestNewObservingDerivationState;
    derivation.onBecomeStale();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing;
  derivation.observing = [];
  var i = obs.length;

  while (i--) removeObserver(obs[i], derivation);

  derivation.dependenciesState = exports.IDerivationState.NOT_TRACKING;
}

function untracked(action) {
  var prev = untrackedStart();
  var res = action();
  untrackedEnd(prev);
  return res;
}

function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}

function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}

function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}

function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */


function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState === exports.IDerivationState.UP_TO_DATE) return;
  derivation.dependenciesState = exports.IDerivationState.UP_TO_DATE;
  var obs = derivation.observing;
  var i = obs.length;

  while (i--) obs[i].lowestObserverState = exports.IDerivationState.UP_TO_DATE;
} // we don't use globalState for these in order to avoid possible issues with multiple
// mobx versions


var currentActionId = 0;
var nextActionId = 1;
var functionNameDescriptor = Object.getOwnPropertyDescriptor(function () {}, "name");
var isFunctionNameConfigurable = functionNameDescriptor && functionNameDescriptor.configurable;

function createAction(actionName, fn) {
  {
    invariant(typeof fn === "function", "`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) fail("actions should have valid names, got: '" + actionName + "'");
  }

  var res = function () {
    return executeAction(actionName, fn, this, arguments);
  };

  {
    if (isFunctionNameConfigurable) {
      Object.defineProperty(res, "name", {
        value: actionName
      });
    }
  }
  res.isMobxAction = true;
  return res;
}

function executeAction(actionName, fn, scope, args) {
  var runInfo = _startAction(actionName, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}

function _startAction(actionName, scope, args) {
  var notifySpy = isSpyEnabled() && !!actionName;
  var startTime = 0;

  if (notifySpy) {
    startTime = Date.now();
    var l = args && args.length || 0;
    var flattendArgs = new Array(l);
    if (l > 0) for (var i = 0; i < l; i++) flattendArgs[i] = args[i];
    spyReportStart({
      type: "action",
      name: actionName,
      object: scope,
      arguments: flattendArgs
    });
  }

  var prevDerivation = untrackedStart();
  startBatch();
  var prevAllowStateChanges = allowStateChangesStart(true);
  var prevAllowStateReads = allowStateReadsStart(true);
  var runInfo = {
    prevDerivation: prevDerivation,
    prevAllowStateChanges: prevAllowStateChanges,
    prevAllowStateReads: prevAllowStateReads,
    notifySpy: notifySpy,
    startTime: startTime,
    actionId: nextActionId++,
    parentActionId: currentActionId
  };
  currentActionId = runInfo.actionId;
  return runInfo;
}

function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId) {
    fail("invalid action stack. did you forget to finish an action?");
  }

  currentActionId = runInfo.parentActionId;

  if (runInfo.error !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges);
  allowStateReadsEnd(runInfo.prevAllowStateReads);
  endBatch();
  untrackedEnd(runInfo.prevDerivation);

  if (runInfo.notifySpy) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime
    });
  }

  globalState.suppressReactionErrors = false;
}

function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);
  var res;

  try {
    res = func();
  } finally {
    allowStateChangesEnd(prev);
  }

  return res;
}

function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}

function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

function allowStateChangesInsideComputed(func) {
  var prev = globalState.computationDepth;
  globalState.computationDepth = 0;
  var res;

  try {
    res = func();
  } finally {
    globalState.computationDepth = prev;
  }

  return res;
}

var ObservableValue =
/** @class */
function (_super) {
  __extends(ObservableValue, _super);

  function ObservableValue(value, enhancer, name, notifySpy, equals) {
    if (name === void 0) {
      name = "ObservableValue@" + getNextId();
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer.default;
    }

    var _this = _super.call(this, name) || this;

    _this.enhancer = enhancer;
    _this.name = name;
    _this.equals = equals;
    _this.hasUnreportedChange = false;
    _this.value = enhancer(value, undefined, name);

    if (notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: "create",
        name: _this.name,
        newValue: "" + _this.value
      });
    }

    return _this;
  }

  ObservableValue.prototype.dehanceValue = function (value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  ObservableValue.prototype.set = function (newValue) {
    var oldValue = this.value;
    newValue = this.prepareNewValue(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if (notifySpy) {
        spyReportStart({
          type: "update",
          name: this.name,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue(newValue);
      if (notifySpy) spyReportEnd();
    }
  };

  ObservableValue.prototype.prepareNewValue = function (newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: "update",
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value, this.name);
    return this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
  };

  ObservableValue.prototype.setNewValue = function (newValue) {
    var oldValue = this.value;
    this.value = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: "update",
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  ObservableValue.prototype.get = function () {
    this.reportObserved();
    return this.dehanceValue(this.value);
  };

  ObservableValue.prototype.intercept = function (handler) {
    return registerInterceptor(this, handler);
  };

  ObservableValue.prototype.observe = function (listener, fireImmediately) {
    if (fireImmediately) listener({
      object: this,
      type: "update",
      newValue: this.value,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  ObservableValue.prototype.toJSON = function () {
    return this.get();
  };

  ObservableValue.prototype.toString = function () {
    return this.name + "[" + this.value + "]";
  };

  ObservableValue.prototype.valueOf = function () {
    return toPrimitive(this.get());
  };

  return ObservableValue;
}(Atom);

ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */

var ComputedValue =
/** @class */
function () {
  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState = exports.IDerivationState.NOT_TRACKING;
    this.observing = []; // nodes we are looking at. Our value depends on these nodes

    this.newObserving = null; // during tracking it's an array with new observed observers

    this.isBeingObserved = false;
    this.isPendingUnobservation = false;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.runId = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = exports.IDerivationState.UP_TO_DATE;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.value = new CaughtException(null);
    this.isComputing = false; // to check for cycles

    this.isRunningSetter = false;
    this.isTracing = TraceMode.NONE;
    invariant(options.get, "missing option for computed: get");
    this.derivation = options.get;
    this.name = options.name || "ComputedValue@" + getNextId();
    if (options.set) this.setter = createAction(this.name + "-setter", options.set);
    this.equals = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer.default);
    this.scope = options.context;
    this.requiresReaction = !!options.requiresReaction;
    this.keepAlive = !!options.keepAlive;
  }

  ComputedValue.prototype.onBecomeStale = function () {
    propagateMaybeChanged(this);
  };

  ComputedValue.prototype.onBecomeUnobserved = function () {};

  ComputedValue.prototype.onBecomeObserved = function () {};
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */


  ComputedValue.prototype.get = function () {
    if (this.isComputing) fail("Cycle detected in computation " + this.name + ": " + this.derivation);

    if (globalState.inBatch === 0 && this.observers.length === 0 && !this.keepAlive) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead();
        startBatch(); // See perf test 'computed memoization'

        this.value = this.computeValue(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);
    }

    var result = this.value;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  ComputedValue.prototype.peek = function () {
    var res = this.computeValue(false);
    if (isCaughtException(res)) throw res.cause;
    return res;
  };

  ComputedValue.prototype.set = function (value) {
    if (this.setter) {
      invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
      this.isRunningSetter = true;

      try {
        this.setter.call(this.scope, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else invariant(false, "[ComputedValue '" + this.name + "'] It is not possible to assign a new value to a computed value.");
  };

  ComputedValue.prototype.trackAndCompute = function () {
    if (isSpyEnabled()) {
      spyReport({
        object: this.scope,
        type: "compute",
        name: this.name
      });
    }

    var oldValue = this.value;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState === exports.IDerivationState.NOT_TRACKING;
    var newValue = this.computeValue(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue);

    if (changed) {
      this.value = newValue;
    }

    return changed;
  };

  ComputedValue.prototype.computeValue = function (track) {
    this.isComputing = true;
    globalState.computationDepth++;
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope);
      } else {
        try {
          res = this.derivation.call(this.scope);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    globalState.computationDepth--;
    this.isComputing = false;
    return res;
  };

  ComputedValue.prototype.suspend = function () {
    if (!this.keepAlive) {
      clearObserving(this);
      this.value = undefined; // don't hold on to computed value!
    }
  };

  ComputedValue.prototype.observe = function (listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          type: "update",
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  ComputedValue.prototype.warnAboutUntrackedRead = function () {
    if (this.requiresReaction === true) {
      fail("[mobx] Computed value " + this.name + " is read outside a reactive context");
    }

    if (this.isTracing !== TraceMode.NONE) {
      console.log("[mobx.trace] '" + this.name + "' is being read outside a reactive context. Doing a full recompute");
    }

    if (globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value " + this.name + " is being read outside a reactive context. Doing a full recompute");
    }
  };

  ComputedValue.prototype.toJSON = function () {
    return this.get();
  };

  ComputedValue.prototype.toString = function () {
    return this.name + "[" + this.derivation.toString() + "]";
  };

  ComputedValue.prototype.valueOf = function () {
    return toPrimitive(this.get());
  };

  return ComputedValue;
}();

ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
/**
 * These values will persist if global state is reset
 */

var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED"];

var MobXGlobals =
/** @class */
function () {
  function MobXGlobals() {
    /**
     * MobXGlobals version.
     * MobX compatiblity with other versions loaded in memory as long as this version matches.
     * It indicates that the global state still stores similar information
     *
     * N.B: this version is unrelated to the package version of MobX, and is only the version of the
     * internal state storage of MobX, and can be the same across many different package versions
     */
    this.version = 5;
    /**
     * globally unique token to signal unchanged
     */

    this.UNCHANGED = {};
    /**
     * Currently running derivation
     */

    this.trackingDerivation = null;
    /**
     * Are we running a computation currently? (not a reaction)
     */

    this.computationDepth = 0;
    /**
     * Each time a derivation is tracked, it is assigned a unique run-id
     */

    this.runId = 0;
    /**
     * 'guid' for general purpose. Will be persisted amongst resets.
     */

    this.mobxGuid = 0;
    /**
     * Are we in a batch block? (and how many of them)
     */

    this.inBatch = 0;
    /**
     * Observables that don't have observers anymore, and are about to be
     * suspended, unless somebody else accesses it in the same batch
     *
     * @type {IObservable[]}
     */

    this.pendingUnobservations = [];
    /**
     * List of scheduled, not yet executed, reactions.
     */

    this.pendingReactions = [];
    /**
     * Are we currently processing reactions?
     */

    this.isRunningReactions = false;
    /**
     * Is it allowed to change observables at this point?
     * In general, MobX doesn't allow that when running computations and React.render.
     * To ensure that those functions stay pure.
     */

    this.allowStateChanges = true;
    /**
     * Is it allowed to read observables at this point?
     * Used to hold the state needed for `observableRequiresReaction`
     */

    this.allowStateReads = true;
    /**
     * If strict mode is enabled, state changes are by default not allowed
     */

    this.enforceActions = false;
    /**
     * Spy callbacks
     */

    this.spyListeners = [];
    /**
     * Globally attached error handlers that react specifically to errors in reactions
     */

    this.globalReactionErrorHandlers = [];
    /**
     * Warn if computed values are accessed outside a reactive context
     */

    this.computedRequiresReaction = false;
    /**
     * (Experimental)
     * Warn if you try to create to derivation / reactive context without accessing any observable.
     */

    this.reactionRequiresObservable = false;
    /**
     * (Experimental)
     * Warn if observables are accessed outside a reactive context
     */

    this.observableRequiresReaction = false;
    /**
     * Allows overwriting of computed properties, useful in tests but not prod as it can cause
     * memory leaks. See https://github.com/mobxjs/mobx/issues/1867
     */

    this.computedConfigurable = false;
    /*
     * Don't catch and rethrow exceptions. This is useful for inspecting the state of
     * the stack when an exception occurs while debugging.
     */

    this.disableErrorBoundaries = false;
    /*
     * If true, we are already handling an exception in an action. Any errors in reactions should be supressed, as
     * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
     */

    this.suppressReactionErrors = false;
  }

  return MobXGlobals;
}();

var canMergeGlobalState = true;
var isolateCalled = false;

var globalState = function () {
  var global = getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        fail("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = new MobXGlobals();
  }
}();

function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) fail("isolateGlobalState should be called before MobX is running any reactions");
  isolateCalled = true;

  if (canMergeGlobalState) {
    if (--getGlobal().__mobxInstanceCount === 0) getGlobal().__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}

function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */


function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers && observable.observers.length > 0;
}

function getObservers(observable) {
  return observable.observers;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }


function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  var l = observable.observers.length;

  if (l) {
    // because object assignment is relatively expensive, let's not store data about index 0.
    observable.observersIndexes[node.__mapid] = l;
  }

  observable.observers[l] = node;
  if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}

function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  if (observable.observers.length === 1) {
    // deleting last observer
    observable.observers.length = 0;
    queueForUnobservation(observable);
  } else {
    // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element
    var list = observable.observers;
    var map = observable.observersIndexes;
    var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesn't have holes

    if (filler !== node) {
      // otherwise node was the last element, which already got removed from array
      var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map.

      if (index) {
        // map store all indexes but 0, see comment in `addObserver`
        map[filler.__mapid] = index;
      } else {
        delete map[filler.__mapid];
      }

      list[index] = filler;
    }

    delete map[node.__mapid];
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}

function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */


function startBatch() {
  globalState.inBatch++;
}

function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation = false;

      if (observable.observers.length === 0) {
        if (observable.isBeingObserved) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved = false;
          observable.onBecomeUnobserved();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}

function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId !== observable.lastAccessedBy) {
      observable.lastAccessedBy = derivation.runId;
      derivation.newObserving[derivation.unboundDepsCount++] = observable;

      if (!observable.isBeingObserved) {
        observable.isBeingObserved = true;
        observable.onBecomeObserved();
      }
    }

    return true;
  } else if (observable.observers.length === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes


function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState === exports.IDerivationState.STALE) return;
  observable.lowestObserverState = exports.IDerivationState.STALE;
  var observers = observable.observers;
  var i = observers.length;

  while (i--) {
    var d = observers[i];

    if (d.dependenciesState === exports.IDerivationState.UP_TO_DATE) {
      if (d.isTracing !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale();
    }

    d.dependenciesState = exports.IDerivationState.STALE;
  } // invariantLOS(observable, "changed end");

} // Called by ComputedValue when it recalculate and its value changed


function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState === exports.IDerivationState.STALE) return;
  observable.lowestObserverState = exports.IDerivationState.STALE;
  var observers = observable.observers;
  var i = observers.length;

  while (i--) {
    var d = observers[i];
    if (d.dependenciesState === exports.IDerivationState.POSSIBLY_STALE) d.dependenciesState = exports.IDerivationState.STALE;else if (d.dependenciesState === exports.IDerivationState.UP_TO_DATE // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) observable.lowestObserverState = exports.IDerivationState.UP_TO_DATE;
  } // invariantLOS(observable, "confirmed end");

} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.


function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState !== exports.IDerivationState.UP_TO_DATE) return;
  observable.lowestObserverState = exports.IDerivationState.POSSIBLY_STALE;
  var observers = observable.observers;
  var i = observers.length;

  while (i--) {
    var d = observers[i];

    if (d.dependenciesState === exports.IDerivationState.UP_TO_DATE) {
      d.dependenciesState = exports.IDerivationState.POSSIBLY_STALE;

      if (d.isTracing !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale();
    }
  } // invariantLOS(observable, "maybe end");

}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable.name + "'");

  if (derivation.isTracing === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction =
/** @class */
function () {
  function Reaction(name, onInvalidate, errorHandler, requiresObservable) {
    if (name === void 0) {
      name = "Reaction@" + getNextId();
    }

    if (requiresObservable === void 0) {
      requiresObservable = false;
    }

    this.name = name;
    this.onInvalidate = onInvalidate;
    this.errorHandler = errorHandler;
    this.requiresObservable = requiresObservable;
    this.observing = []; // nodes we are looking at. Our value depends on these nodes

    this.newObserving = [];
    this.dependenciesState = exports.IDerivationState.NOT_TRACKING;
    this.diffValue = 0;
    this.runId = 0;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.isDisposed = false;
    this._isScheduled = false;
    this._isTrackPending = false;
    this._isRunning = false;
    this.isTracing = TraceMode.NONE;
  }

  Reaction.prototype.onBecomeStale = function () {
    this.schedule();
  };

  Reaction.prototype.schedule = function () {
    if (!this._isScheduled) {
      this._isScheduled = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  Reaction.prototype.isScheduled = function () {
    return this._isScheduled;
  };
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */


  Reaction.prototype.runReaction = function () {
    if (!this.isDisposed) {
      startBatch();
      this._isScheduled = false;

      if (shouldCompute(this)) {
        this._isTrackPending = true;

        try {
          this.onInvalidate();

          if (this._isTrackPending && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation(e);
        }
      }

      endBatch();
    }
  };

  Reaction.prototype.track = function (fn) {
    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if (notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name,
        type: "reaction"
      });
    }

    this._isRunning = true;
    var result = trackDerivedFunction(this, fn, undefined);
    this._isRunning = false;
    this._isTrackPending = false;

    if (this.isDisposed) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);

    if (notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  Reaction.prototype.reportExceptionInDerivation = function (error) {
    var _this = this;

    if (this.errorHandler) {
      this.errorHandler(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";

    if (globalState.suppressReactionErrors) {
      console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)"); // prettier-ignore
    } else {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    }

    if (isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  Reaction.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;

      if (!this._isRunning) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  Reaction.prototype.getDisposer = function () {
    var r = this.dispose.bind(this);
    r.$mobx = this;
    return r;
  };

  Reaction.prototype.toString = function () {
    return "Reaction[" + this.name + "]";
  };

  Reaction.prototype.trace = function (enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();

function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */


var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function (f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) remainingReactions[i].runReaction();
  }

  globalState.isRunningReactions = false;
}

var isReaction = createInstanceofPredicate("Reaction", Reaction);

function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function (f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return !!globalState.spyListeners.length;
}

function spyReport(event) {
  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) listeners[i](event);
}

function spyReportStart(event) {
  var change = __assign(__assign({}, event), {
    spyReportStart: true
  });

  spyReport(change);
}

var END_EVENT = {
  spyReportEnd: true
};

function spyReportEnd(change) {
  if (change) spyReport(__assign(__assign({}, change), {
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}

function spy(listener) {
  globalState.spyListeners.push(listener);
  return once(function () {
    globalState.spyListeners = globalState.spyListeners.filter(function (l) {
      return l !== listener;
    });
  });
}

function dontReassignFields() {
  fail("@action fields are not reassignable");
}

function namedActionDecorator(name) {
  return function (target, prop, descriptor) {
    if (descriptor) {
      if (descriptor.get !== undefined) {
        return fail("@action cannot be used with getters");
      } // babel / typescript
      // @action method() { }


      if (descriptor.value) {
        // typescript
        return {
          value: createAction(name, descriptor.value),
          enumerable: false,
          configurable: true,
          writable: true // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)

        };
      } // babel only: @action method = () => {}


      var initializer_1 = descriptor.initializer;
      return {
        enumerable: false,
        configurable: true,
        writable: true,
        initializer: function () {
          // N.B: we can't immediately invoke initializer; this would be wrong
          return createAction(name, initializer_1.call(this));
        }
      };
    } // bound instance methods


    return actionFieldDecorator(name).apply(this, arguments);
  };
}

function actionFieldDecorator(name) {
  // Simple property that writes on first invocation to the current instance
  return function (target, prop, descriptor) {
    Object.defineProperty(target, prop, {
      configurable: true,
      enumerable: false,
      get: function () {
        return undefined;
      },
      set: function (value) {
        addHiddenProp(this, prop, action(name, value));
      }
    });
  };
}

function boundActionDecorator(target, propertyName, descriptor, applyToInstance) {
  if (applyToInstance === true) {
    defineBoundAction(target, propertyName, descriptor.value);
    return null;
  }

  if (descriptor) {
    // if (descriptor.value)
    // Typescript / Babel: @action.bound method() { }
    // also: babel @action.bound method = () => {}
    return {
      configurable: true,
      enumerable: false,
      get: function () {
        defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this));
        return this[propertyName];
      },
      set: dontReassignFields
    };
  } // field decorator Typescript @action.bound method = () => {}


  return {
    enumerable: false,
    configurable: true,
    set: function (v) {
      defineBoundAction(this, propertyName, v);
    },
    get: function () {
      return undefined;
    }
  };
}

var action = function action(arg1, arg2, arg3, arg4) {
  // action(fn() {})
  if (arguments.length === 1 && typeof arg1 === "function") return createAction(arg1.name || "<unnamed action>", arg1); // action("name", fn() {})

  if (arguments.length === 2 && typeof arg2 === "function") return createAction(arg1, arg2); // @action("name") fn() {}

  if (arguments.length === 1 && typeof arg1 === "string") return namedActionDecorator(arg1); // @action fn() {}

  if (arg4 === true) {
    // apply to instance immediately
    arg1[arg2] = createAction(arg1.name || arg2, arg3.value);
  } else {
    return namedActionDecorator(arg2).apply(null, arguments);
  }
};

action.bound = boundActionDecorator;

function runInAction(arg1, arg2) {
  // TODO: deprecate?
  var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
  var fn = typeof arg1 === "function" ? arg1 : arg2;
  {
    invariant(typeof fn === "function" && fn.length === 0, "`runInAction` expects a function without arguments");
    if (typeof actionName !== "string" || !actionName) fail("actions should have valid names, got: '" + actionName + "'");
  }
  return executeAction(actionName, fn, this, undefined);
}

function isAction(thing) {
  return typeof thing === "function" && thing.isMobxAction === true;
}

function defineBoundAction(target, propertyName, fn) {
  addHiddenProp(target, propertyName, createAction(propertyName, fn.bind(target)));
}
/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */


function autorun(view, opts) {
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    invariant(typeof view === "function", "Autorun expects a function as first argument");
    invariant(isAction(view) === false, "Autorun does not accept actions since actions are untrackable");
  }
  var name = opts && opts.name || view.name || "Autorun@" + getNextId();
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler_1 = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled_1 = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled_1) {
        isScheduled_1 = true;
        scheduler_1(function () {
          isScheduled_1 = false;
          if (!reaction.isDisposed) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule();
  return reaction.getDisposer();
}

var run = function (f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  if (typeof opts === "boolean") {
    opts = {
      fireImmediately: opts
    };
    deprecated("Using fireImmediately as argument is deprecated. Use '{ fireImmediately: true }' instead");
  }

  {
    invariant(typeof expression === "function", "First argument to reaction should be a function");
    invariant(typeof opts === "object", "Third argument of reactions should be an object");
  }
  var name = opts.name || "Reaction@" + getNextId();
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer.default;
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false; // Q: move into reaction runner?

    if (r.isDisposed) return;
    var changed = false;
    r.track(function () {
      var nextValue = expression(r);
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, r);
    if (!firstTime && changed === true) effectAction(value, r);
    if (firstTime) firstTime = false;
  }

  r.schedule();
  return r.getDisposer();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook("onBecomeObserved", thing, arg2, arg3);
}

function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = typeof arg3 === "function" ? arg3 : arg2;
  var orig = atom[hook];
  if (typeof orig !== "function") return fail("Not an atom that can be (un)observed");

  atom[hook] = function () {
    orig.call(this);
    cb.call(this);
  };

  return function () {
    atom[hook] = orig;
  };
}

function configure(options) {
  var enforceActions = options.enforceActions,
      computedRequiresReaction = options.computedRequiresReaction,
      computedConfigurable = options.computedConfigurable,
      disableErrorBoundaries = options.disableErrorBoundaries,
      arrayBuffer = options.arrayBuffer,
      reactionScheduler = options.reactionScheduler,
      reactionRequiresObservable = options.reactionRequiresObservable,
      observableRequiresReaction = options.observableRequiresReaction;

  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  if (enforceActions !== undefined) {
    if (typeof enforceActions === "boolean" || enforceActions === "strict") deprecated("Deprecated value for 'enforceActions', use 'false' => '\"never\"', 'true' => '\"observed\"', '\"strict\"' => \"'always'\" instead");
    var ea = void 0;

    switch (enforceActions) {
      case true:
      case "observed":
        ea = true;
        break;

      case false:
      case "never":
        ea = false;
        break;

      case "strict":
      case "always":
        ea = "strict";
        break;

      default:
        fail("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
    }

    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === "strict" ? false : true;
  }

  if (computedRequiresReaction !== undefined) {
    globalState.computedRequiresReaction = !!computedRequiresReaction;
  }

  if (reactionRequiresObservable !== undefined) {
    globalState.reactionRequiresObservable = !!reactionRequiresObservable;
  }

  if (observableRequiresReaction !== undefined) {
    globalState.observableRequiresReaction = !!observableRequiresReaction;
    globalState.allowStateReads = !globalState.observableRequiresReaction;
  }

  if (computedConfigurable !== undefined) {
    globalState.computedConfigurable = !!computedConfigurable;
  }

  if (disableErrorBoundaries !== undefined) {
    if (disableErrorBoundaries === true) console.warn("WARNING: Debug feature only. MobX will NOT recover from errors if this is on.");
    globalState.disableErrorBoundaries = !!disableErrorBoundaries;
  }

  if (typeof arrayBuffer === "number") {
    reserveArrayBuffer(arrayBuffer);
  }

  if (reactionScheduler) {
    setReactionScheduler(reactionScheduler);
  }
}

function decorate(thing, decorators) {
  if (!isPlainObject(decorators)) fail("Decorators should be a key value map");
  var target = typeof thing === "function" ? thing.prototype : thing;

  var _loop_1 = function (prop) {
    var propertyDecorators = decorators[prop];

    if (!Array.isArray(propertyDecorators)) {
      propertyDecorators = [propertyDecorators];
    } // prettier-ignore


    if (!propertyDecorators.every(function (decorator) {
      return typeof decorator === "function";
    })) fail("Decorate: expected a decorator function or array of decorator functions for '" + prop + "'");
    var descriptor = Object.getOwnPropertyDescriptor(target, prop);
    var newDescriptor = propertyDecorators.reduce(function (accDescriptor, decorator) {
      return decorator(target, prop, accDescriptor);
    }, descriptor);
    if (newDescriptor) Object.defineProperty(target, prop, newDescriptor);
  };

  for (var prop in decorators) {
    _loop_1(prop);
  }

  return thing;
}

function extendShallowObservable(target, properties, decorators) {
  deprecated("'extendShallowObservable' is deprecated, use 'extendObservable(target, props, { deep: false })' instead");
  return extendObservable(target, properties, decorators, shallowCreateObservableOptions);
}

function extendObservable(target, properties, decorators, options) {
  {
    invariant(arguments.length >= 2 && arguments.length <= 4, "'extendObservable' expected 2-4 arguments");
    invariant(typeof target === "object", "'extendObservable' expects an object as first argument");
    invariant(!isObservableMap(target), "'extendObservable' should not be used on maps, use map.merge instead");
    invariant(!isObservable(properties), "Extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540");
    if (decorators) for (var key in decorators) if (!(key in properties)) fail("Trying to declare a decorator for unspecified property '" + key + "'");
  }
  options = asCreateObservableOptions(options);
  var defaultDecorator = options.defaultDecorator || (options.deep === false ? refDecorator : deepDecorator);
  initializeInstance(target);
  asObservableObject(target, options.name, defaultDecorator.enhancer); // make sure object is observable, even without initial props

  startBatch();

  try {
    for (var key in properties) {
      var descriptor = Object.getOwnPropertyDescriptor(properties, key);
      {
        if (isComputed(descriptor.value)) fail("Passing a 'computed' as initial property value is no longer supported by extendObservable. Use a getter or decorator instead");
      }
      var decorator = decorators && key in decorators ? decorators[key] : descriptor.get ? computedDecorator : defaultDecorator;
      if (typeof decorator !== "function") return fail("Not a valid decorator for '" + key + "', got: " + decorator);
      var resultDescriptor = decorator(target, key, descriptor, true);
      if (resultDescriptor // otherwise, assume already applied, due to `applyToInstance`
      ) Object.defineProperty(target, key, resultDescriptor);
    }
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name
  };
  if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name
  };
  if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);
  return result;
}

var generatorId = 0;

function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}

FlowCancellationError.prototype = Object.create(Error.prototype);

function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}

function flow(generator) {
  if (arguments.length !== 1) fail("Flow expects one 1 argument and cannot be used as decorator");
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  return function () {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var res = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.throw).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (ret && typeof ret.then === "function") {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    res.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var res_1 = gen.return(undefined); // eat anything that promise would do, it's cancelled!

        var yieldedPromise = Promise.resolve(res_1.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return res;
  };
}

function cancelPromise(promise) {
  if (typeof promise.cancel === "function") promise.cancel();
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if (typeof propOrHandler !== "string") return fail("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else {
    return fail("Expected observable map, object or array as first array");
  }

  if (target.dehancer !== undefined) return fail("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (typeof handler === "function") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept(handler);
}

function _isComputed(value, property) {
  if (value === null || value === undefined) return false;

  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value.$mobx.values[property]) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}

function isComputed(value) {
  if (arguments.length > 1) return fail("isComputed expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isComputed(value);
}

function isComputedProp(value, propName) {
  if (typeof propName !== "string") return fail("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (value === null || value === undefined) return false;

  if (property !== undefined) {
    if (isObservableMap(value) || isObservableArray(value)) return fail("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      var o = value.$mobx;
      return o.values && !!o.values[property];
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if (arguments.length !== 1) fail("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}

function isObservableProp(value, propName) {
  if (typeof propName !== "string") return fail("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj.$mobx.getKeys();
  }

  if (isObservableMap(obj)) {
    return obj._keys.slice();
  }

  if (isObservableSet(obj)) {
    return iteratorToArray(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  return fail("'keys()' can only be used on observable objects, arrays, sets and maps");
}

function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return iteratorToArray(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  return fail("'values()' can only be used on observable objects, arrays, sets and maps");
}

function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return iteratorToArray(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  return fail("'entries()' can only be used on observable objects, arrays and maps");
}

function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var values_1 = key;

    try {
      for (var key_1 in values_1) set(obj, key_1, values_1[key_1]);
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    var adm = obj.$mobx;
    var existingObservable = adm.values[key];

    if (existingObservable) {
      adm.write(obj, key, value);
    } else {
      defineObservableProperty(obj, key, value, adm.defaultEnhancer);
    }
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    invariant(key >= 0, "Not a valid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else {
    return fail("'set()' can only be used on observable objects, arrays and maps");
  }
}

function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj.$mobx.remove(key);
  } else if (isObservableMap(obj)) {
    obj.delete(key);
  } else if (isObservableSet(obj)) {
    obj.delete(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    invariant(key >= 0, "Not a valid index: '" + key + "'");
    obj.splice(key, 1);
  } else {
    return fail("'remove()' can only be used on observable objects, arrays and maps");
  }
}

function has(obj, key) {
  if (isObservableObject(obj)) {
    // return keys(obj).indexOf(key) >= 0
    var adm = getAdministration(obj);
    adm.getKeys(); // make sure we get notified of key changes, but for performance, use the values map to look up existence

    return !!adm.values[key];
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  } else {
    return fail("'has()' can only be used on observable objects, arrays and maps");
  }
}

function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[key];
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  } else {
    return fail("'get()' can only be used on observable objects, arrays and maps");
  }
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (typeof cbOrFire === "function") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe(listener, fireImmediately);
}

var defaultOptions = {
  detectCycles: true,
  exportMapsAsObjects: true,
  recurseEverything: false
};

function cache(map, key, value, options) {
  if (options.detectCycles) map.set(key, value);
  return value;
}

function toJSHelper(source, options, __alreadySeen) {
  if (!options.recurseEverything && !isObservable(source)) return source;
  if (typeof source !== "object") return source; // Directly return null if source is null

  if (source === null) return null; // Directly return the Date object itself if contained in the observable

  if (source instanceof Date) return source;
  if (isObservableValue(source)) return toJSHelper(source.get(), options, __alreadySeen); // make sure we track the keys of the object

  if (isObservable(source)) keys(source);
  var detectCycles = options.detectCycles === true;

  if (detectCycles && source !== null && __alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source) || Array.isArray(source)) {
    var res_1 = cache(__alreadySeen, source, [], options);
    var toAdd = source.map(function (value) {
      return toJSHelper(value, options, __alreadySeen);
    });
    res_1.length = toAdd.length;

    for (var i = 0, l = toAdd.length; i < l; i++) res_1[i] = toAdd[i];

    return res_1;
  }

  if (isObservableSet(source) || Object.getPrototypeOf(source) === Set.prototype) {
    if (options.exportMapsAsObjects === false) {
      var res_2 = cache(__alreadySeen, source, new Set(), options);
      source.forEach(function (value) {
        res_2.add(toJSHelper(value, options, __alreadySeen));
      });
      return res_2;
    } else {
      var res_3 = cache(__alreadySeen, source, [], options);
      source.forEach(function (value) {
        res_3.push(toJSHelper(value, options, __alreadySeen));
      });
      return res_3;
    }
  }

  if (isObservableMap(source) || Object.getPrototypeOf(source) === Map.prototype) {
    if (options.exportMapsAsObjects === false) {
      var res_4 = cache(__alreadySeen, source, new Map(), options);
      source.forEach(function (value, key) {
        res_4.set(key, toJSHelper(value, options, __alreadySeen));
      });
      return res_4;
    } else {
      var res_5 = cache(__alreadySeen, source, {}, options);
      source.forEach(function (value, key) {
        res_5[key] = toJSHelper(value, options, __alreadySeen);
      });
      return res_5;
    }
  } // Fallback to the situation that source is an ObservableObject or a plain object


  var res = cache(__alreadySeen, source, {}, options);

  for (var key in source) {
    res[key] = toJSHelper(source[key], options, __alreadySeen);
  }

  return res;
}

function toJS(source, options) {
  // backward compatibility
  if (typeof options === "boolean") options = {
    detectCycles: options
  };
  if (!options) options = defaultOptions;
  options.detectCycles = options.detectCycles === undefined ? options.recurseEverything === true : options.detectCycles === true;

  var __alreadySeen;

  if (options.detectCycles) __alreadySeen = new Map();
  return toJSHelper(source, options, __alreadySeen);
}

function trace() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var enterBreakPoint = false;
  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return fail("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
  }

  derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}
/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */


function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    timeoutHandle = setTimeout(function () {
      if (!disposer.$mobx.isDisposed) {
        disposer();
        var error = new Error("WHEN_TIMEOUT");
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name = opts.name || "When@" + getNextId();
  var effectAction = createAction(opts.name + "-effect", effect);
  var disposer = autorun(function (r) {
    if (predicate()) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if (opts && opts.onError) return fail("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, __assign(__assign({}, opts), {
      onError: reject
    }));

    cancel = function () {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors !== undefined && interceptable.interceptors.length > 0;
}

function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}

function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    var interceptors = interceptable.interceptors;
    if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
      if (!change) break;
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners !== undefined && listenable.changeListeners.length > 0;
}

function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners || (listenable.changeListeners = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}

function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
// Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364

var safariPrototypeSetterInheritanceBug = function () {
  var v = false;
  var p = {};
  Object.defineProperty(p, "0", {
    set: function () {
      v = true;
    }
  });
  Object.create(p)["0"] = 1;
  return v === false;
}();
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */


var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray =
/** @class */
function () {
  function StubArray() {}

  return StubArray;
}();

function inherit(ctor, proto) {
  if (typeof Object["setPrototypeOf"] !== "undefined") {
    Object["setPrototypeOf"](ctor.prototype, proto);
  } else if (typeof ctor.prototype.__proto__ !== "undefined") {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor["prototype"] = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex freeze Array.prototype
// Make them writeable and configurable in prototype chain
// https://github.com/alibaba/weex/pull/1529

if (Object.isFrozen(Array)) {
  ["constructor", "push", "shift", "concat", "pop", "unshift", "replace", "find", "findIndex", "splice", "reverse", "sort"].forEach(function (key) {
    Object.defineProperty(StubArray.prototype, key, {
      configurable: true,
      writable: true,
      value: Array.prototype[key]
    });
  });
}

var ObservableArrayAdministration =
/** @class */
function () {
  function ObservableArrayAdministration(name, enhancer, array, owned) {
    this.array = array;
    this.owned = owned;
    this.values = [];
    this.lastKnownLength = 0;
    this.atom = new Atom(name || "ObservableArray@" + getNextId());

    this.enhancer = function (newV, oldV) {
      return enhancer(newV, oldV, name + "[..]");
    };
  }

  ObservableArrayAdministration.prototype.dehanceValue = function (value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  ObservableArrayAdministration.prototype.dehanceValues = function (values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  ObservableArrayAdministration.prototype.intercept = function (handler) {
    return registerInterceptor(this, handler);
  };

  ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        object: this.array,
        type: "splice",
        index: 0,
        added: this.values.slice(),
        addedCount: this.values.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  ObservableArrayAdministration.prototype.getArrayLength = function () {
    this.atom.reportObserved();
    return this.values.length;
  };

  ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
    if (typeof newLength !== "number" || newLength < 0) throw new Error("[mobx.array] Out of range: " + newLength);
    var currentLength = this.values.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) newItems[i] = undefined; // No Array.fill everywhere...


      this.spliceWithArray(currentLength, 0, newItems);
    } else this.spliceWithArray(newLength, currentLength - newLength);
  }; // adds / removes the necessary numeric properties to this object


  ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {
    if (oldLength !== this.lastKnownLength) throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?");
    this.lastKnownLength += delta;
    if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);
  };

  ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom);
    var length = this.values.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.array,
        type: "splice",
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer(v, undefined);
    });
    var lengthDelta = newItems.length - deleteCount;
    this.updateArrayLength(length, lengthDelta); // create or remove new entries

    var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);
    return this.dehanceValues(res);
  };

  ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {
    var _a;

    if (newItems.length < MAX_SPLICE_SIZE) {
      return (_a = this.values).splice.apply(_a, __spread([index, deleteCount], newItems));
    } else {
      var res = this.values.slice(index, index + deleteCount);
      this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));
      return res;
    }
  };

  ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {
    var notifySpy = !this.owned && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      object: this.array,
      type: "update",
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null;
    if (notifySpy) spyReportStart(__assign(__assign({}, change), {
      name: this.atom.name
    }));
    this.atom.reportChanged();
    if (notify) notifyListeners(this, change);
    if (notifySpy) spyReportEnd();
  };

  ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {
    var notifySpy = !this.owned && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      object: this.array,
      type: "splice",
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (notifySpy) spyReportStart(__assign(__assign({}, change), {
      name: this.atom.name
    }));
    this.atom.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if (notifySpy) spyReportEnd();
  };

  return ObservableArrayAdministration;
}();

var ObservableArray =
/** @class */
function (_super) {
  __extends(ObservableArray, _super);

  function ObservableArray(initialValues, enhancer, name, owned) {
    if (name === void 0) {
      name = "ObservableArray@" + getNextId();
    }

    if (owned === void 0) {
      owned = false;
    }

    var _this = _super.call(this) || this;

    var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);
    addHiddenFinalProp(_this, "$mobx", adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    if (safariPrototypeSetterInheritanceBug) {
      // Seems that Safari won't use numeric prototype setter untill any * numeric property is
      // defined on the instance. After that it works fine, even if this property is deleted.
      Object.defineProperty(adm.array, "0", ENTRY_0);
    }

    return _this;
  }

  ObservableArray.prototype.intercept = function (handler) {
    return this.$mobx.intercept(handler);
  };

  ObservableArray.prototype.observe = function (listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    return this.$mobx.observe(listener, fireImmediately);
  };

  ObservableArray.prototype.clear = function () {
    return this.splice(0);
  };

  ObservableArray.prototype.concat = function () {
    var arrays = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      arrays[_i] = arguments[_i];
    }

    this.$mobx.atom.reportObserved();
    return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {
      return isObservableArray(a) ? a.peek() : a;
    }));
  };

  ObservableArray.prototype.replace = function (newItems) {
    return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
  };
  /**
   * Converts this array back to a (shallow) javascript structure.
   * For a deep clone use mobx.toJS
   */


  ObservableArray.prototype.toJS = function () {
    return this.slice();
  };

  ObservableArray.prototype.toJSON = function () {
    // Used by JSON.stringify
    return this.toJS();
  };

  ObservableArray.prototype.peek = function () {
    this.$mobx.atom.reportObserved();
    return this.$mobx.dehanceValues(this.$mobx.values);
  }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find


  ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) {
      fromIndex = 0;
    }

    if (arguments.length === 3) deprecated("The array.find fromIndex argument to find will not be supported anymore in the next major");
    var idx = this.findIndex.apply(this, arguments);
    return idx === -1 ? undefined : this.get(idx);
  }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex


  ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) {
      fromIndex = 0;
    }

    if (arguments.length === 3) deprecated("The array.findIndex fromIndex argument to find will not be supported anymore in the next major");
    var items = this.peek(),
        l = items.length;

    for (var i = fromIndex; i < l; i++) if (predicate.call(thisArg, items[i], i, this)) return i;

    return -1;
  };
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */


  ObservableArray.prototype.splice = function (index, deleteCount) {
    var newItems = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      newItems[_i - 2] = arguments[_i];
    }

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return this.$mobx.spliceWithArray(index);

      case 2:
        return this.$mobx.spliceWithArray(index, deleteCount);
    }

    return this.$mobx.spliceWithArray(index, deleteCount, newItems);
  };

  ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {
    return this.$mobx.spliceWithArray(index, deleteCount, newItems);
  };

  ObservableArray.prototype.push = function () {
    var items = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }

    var adm = this.$mobx;
    adm.spliceWithArray(adm.values.length, 0, items);
    return adm.values.length;
  };

  ObservableArray.prototype.pop = function () {
    return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];
  };

  ObservableArray.prototype.shift = function () {
    return this.splice(0, 1)[0];
  };

  ObservableArray.prototype.unshift = function () {
    var items = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }

    var adm = this.$mobx;
    adm.spliceWithArray(0, 0, items);
    return adm.values.length;
  };

  ObservableArray.prototype.reverse = function () {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    // so we deviate from the default and just make it an dervitation
    var clone = this.slice();
    return clone.reverse.apply(clone, arguments);
  };

  ObservableArray.prototype.sort = function (compareFn) {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    var clone = this.slice();
    return clone.sort.apply(clone, arguments);
  };

  ObservableArray.prototype.remove = function (value) {
    var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  };

  ObservableArray.prototype.move = function (fromIndex, toIndex) {
    deprecated("observableArray.move is deprecated, use .slice() & .replace() instead");

    function checkIndex(index) {
      if (index < 0) {
        throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
      }

      var length = this.$mobx.values.length;

      if (index >= length) {
        throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
      }
    }

    checkIndex.call(this, fromIndex);
    checkIndex.call(this, toIndex);

    if (fromIndex === toIndex) {
      return;
    }

    var oldItems = this.$mobx.values;
    var newItems;

    if (fromIndex < toIndex) {
      newItems = __spread(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));
    } else {
      // toIndex < fromIndex
      newItems = __spread(oldItems.slice(0, toIndex), [oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
    }

    this.replace(newItems);
  }; // See #734, in case property accessors are unreliable...


  ObservableArray.prototype.get = function (index) {
    var impl = this.$mobx;

    if (impl) {
      if (index < impl.values.length) {
        impl.atom.reportObserved();
        return impl.dehanceValue(impl.values[index]);
      }

      console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + impl.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
    }

    return undefined;
  }; // See #734, in case property accessors are unreliable...


  ObservableArray.prototype.set = function (index, newValue) {
    var adm = this.$mobx;
    var values = adm.values;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(adm.atom);
      var oldValue = values[index];

      if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
          type: "update",
          object: this,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = adm.enhancer(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        adm.notifyArrayChildUpdate(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      adm.spliceWithArray(index, 0, [newValue]);
    } else {
      // out of bounds
      throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values.length);
    }
  };

  return ObservableArray;
}(StubArray);

declareIterator(ObservableArray.prototype, function () {
  this.$mobx.atom.reportObserved();
  var self = this;
  var nextIndex = 0;
  return makeIterable({
    next: function () {
      return nextIndex < self.length ? {
        value: self[nextIndex++],
        done: false
      } : {
        done: true,
        value: undefined
      };
    }
  });
});
Object.defineProperty(ObservableArray.prototype, "length", {
  enumerable: false,
  configurable: true,
  get: function () {
    return this.$mobx.getArrayLength();
  },
  set: function (newLength) {
    this.$mobx.setArrayLength(newLength);
  }
});
addHiddenProp(ObservableArray.prototype, toStringTagSymbol(), "Array");
["every", "filter", "forEach", "indexOf", "join", "lastIndexOf", "map", "reduce", "reduceRight", "slice", "some", "toString", "toLocaleString"].forEach(function (funcName) {
  var baseFunc = Array.prototype[funcName];
  invariant(typeof baseFunc === "function", "Base function not defined on Array prototype: '" + funcName + "'");
  addHiddenProp(ObservableArray.prototype, funcName, function () {
    return baseFunc.apply(this.peek(), arguments);
  });
});
/**
 * We don't want those to show up in `for (const key in ar)` ...
 */

makeNonEnumerable(ObservableArray.prototype, ["constructor", "intercept", "observe", "clear", "concat", "get", "replace", "toJS", "toJSON", "peek", "find", "findIndex", "splice", "spliceWithArray", "push", "pop", "set", "shift", "unshift", "reverse", "sort", "remove", "move", "toString", "toLocaleString"]); // See #364

var ENTRY_0 = createArrayEntryDescriptor(0);

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: false,
    get: function () {
      return this.get(index);
    },
    set: function (value) {
      this.set(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  Object.defineProperty(ObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) createArrayBufferItem(index);

  OBSERVABLE_ARRAY_BUFFER_SIZE = max;
}

reserveArrayBuffer(1000);
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);

function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing.$mobx);
}

var ObservableMapMarker = {};

var ObservableMap =
/** @class */
function () {
  function ObservableMap(initialData, enhancer, name) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name === void 0) {
      name = "ObservableMap@" + getNextId();
    }

    this.enhancer = enhancer;
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);

    if (typeof Map !== "function") {
      throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
    }

    this._data = new Map();
    this._hasMap = new Map();
    this.merge(initialData);
  }

  ObservableMap.prototype._has = function (key) {
    return this._data.has(key);
  };

  ObservableMap.prototype.has = function (key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this._has(key);

    var entry = this._hasMap.get(key);

    if (!entry) {
      // todo: replace with atom (breaking change)
      var newEntry = entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);

      this._hasMap.set(key, newEntry);

      onBecomeUnobserved(newEntry, function () {
        return _this._hasMap.delete(key);
      });
    }

    return entry.get();
  };

  ObservableMap.prototype.set = function (key, value) {
    var hasKey = this._has(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? "update" : "add",
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this._updateValue(key, value);
    } else {
      this._addValue(key, value);
    }

    return this;
  };

  ObservableMap.prototype.delete = function (key) {
    var _this = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: "delete",
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this._has(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "delete",
        object: this,
        oldValue: this._data.get(key).value,
        name: key
      } : null;
      if (notifySpy) spyReportStart(__assign(__assign({}, change), {
        name: this.name,
        key: key
      }));
      transaction(function () {
        _this._keys.remove(key);

        _this._updateHasMapEntry(key, false);

        var observable = _this._data.get(key);

        observable.setNewValue(undefined);

        _this._data.delete(key);
      });
      if (notify) notifyListeners(this, change);
      if (notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  ObservableMap.prototype._updateHasMapEntry = function (key, value) {
    var entry = this._hasMap.get(key);

    if (entry) {
      entry.setNewValue(value);
    }
  };

  ObservableMap.prototype._updateValue = function (key, newValue) {
    var observable = this._data.get(key);

    newValue = observable.prepareNewValue(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "update",
        object: this,
        oldValue: observable.value,
        name: key,
        newValue: newValue
      } : null;
      if (notifySpy) spyReportStart(__assign(__assign({}, change), {
        name: this.name,
        key: key
      }));
      observable.setNewValue(newValue);
      if (notify) notifyListeners(this, change);
      if (notifySpy) spyReportEnd();
    }
  };

  ObservableMap.prototype._addValue = function (key, newValue) {
    var _this = this;

    transaction(function () {
      var observable = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);

      _this._data.set(key, observable);

      newValue = observable.value; // value might have been changed

      _this._updateHasMapEntry(key, true);

      _this._keys.push(key);
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      type: "add",
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if (notifySpy) spyReportStart(__assign(__assign({}, change), {
      name: this.name,
      key: key
    }));
    if (notify) notifyListeners(this, change);
    if (notifySpy) spyReportEnd();
  };

  ObservableMap.prototype.get = function (key) {
    if (this.has(key)) return this.dehanceValue(this._data.get(key).get());
    return this.dehanceValue(undefined);
  };

  ObservableMap.prototype.dehanceValue = function (value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  ObservableMap.prototype.keys = function () {
    return this._keys[iteratorSymbol()]();
  };

  ObservableMap.prototype.values = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function () {
        return nextIndex < self._keys.length ? {
          value: self.get(self._keys[nextIndex++]),
          done: false
        } : {
          value: undefined,
          done: true
        };
      }
    });
  };

  ObservableMap.prototype.entries = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function () {
        if (nextIndex < self._keys.length) {
          var key = self._keys[nextIndex++];
          return {
            value: [key, self.get(key)],
            done: false
          };
        }

        return {
          done: true
        };
      }
    });
  };

  ObservableMap.prototype.forEach = function (callback, thisArg) {
    var _this = this;

    this._keys.forEach(function (key) {
      return callback.call(thisArg, _this.get(key), key, _this);
    });
  };
  /** Merge another object into this object, returns this. */


  ObservableMap.prototype.merge = function (other) {
    var _this = this;

    if (isObservableMap(other)) {
      other = other.toJS();
    }

    transaction(function () {
      if (isPlainObject(other)) Object.keys(other).forEach(function (key) {
        return _this.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_a) {
        var _b = __read(_a, 2),
            key = _b[0],
            value = _b[1];

        return _this.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name); // prettier-ignore
        else other.forEach(function (value, key) {
            return _this.set(key, value);
          });
      } else if (other !== null && other !== undefined) fail("Cannot initialize map from " + other);
    });
    return this;
  };

  ObservableMap.prototype.clear = function () {
    var _this = this;

    transaction(function () {
      untracked(function () {
        _this._keys.slice().forEach(function (key) {
          return _this.delete(key);
        });
      });
    });
  };

  ObservableMap.prototype.replace = function (values) {
    var _this = this;

    transaction(function () {
      var replacementMap = convertToMap(values);
      var oldKeys = _this._keys;
      var newKeys = Array.from(replacementMap.keys());
      var keysChanged = false;

      for (var i = 0; i < oldKeys.length; i++) {
        var oldKey = oldKeys[i]; // key order change

        if (oldKeys.length === newKeys.length && oldKey !== newKeys[i]) {
          keysChanged = true;
        } // deleted key


        if (!replacementMap.has(oldKey)) {
          keysChanged = true;

          _this.delete(oldKey);
        }
      }

      replacementMap.forEach(function (value, key) {
        // new key
        if (!_this._data.has(key)) {
          keysChanged = true;
        }

        _this.set(key, value);
      });

      if (keysChanged) {
        _this._keys.replace(newKeys);
      }
    });
    return this;
  };

  Object.defineProperty(ObservableMap.prototype, "size", {
    get: function () {
      return this._keys.length;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns a plain object that represents this map.
   * Note that all the keys being stringified.
   * If there are duplicating keys after converting them to strings, behaviour is undetermined.
   */

  ObservableMap.prototype.toPOJO = function () {
    var _this = this;

    var res = {};

    this._keys.forEach(function (key) {
      return res[typeof key === "symbol" ? key : stringifyKey(key)] = _this.get(key);
    });

    return res;
  };
  /**
   * Returns a shallow non observable object clone of this map.
   * Note that the values migth still be observable. For a deep clone use mobx.toJS.
   */


  ObservableMap.prototype.toJS = function () {
    var _this = this;

    var res = new Map();

    this._keys.forEach(function (key) {
      return res.set(key, _this.get(key));
    });

    return res;
  };

  ObservableMap.prototype.toJSON = function () {
    // Used by JSON.stringify
    return this.toPOJO();
  };

  ObservableMap.prototype.toString = function () {
    var _this = this;

    return this.name + "[{ " + this._keys.map(function (key) {
      return stringifyKey(key) + ": " + ("" + _this.get(key));
    }).join(", ") + " }]";
  };
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */


  ObservableMap.prototype.observe = function (listener, fireImmediately) {
    invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  ObservableMap.prototype.intercept = function (handler) {
    return registerInterceptor(this, handler);
  };

  return ObservableMap;
}();

function stringifyKey(key) {
  if (key && key.toString) return key.toString();else return new String(key).toString();
}

declareIterator(ObservableMap.prototype, function () {
  return this.entries();
});
addHiddenFinalProp(ObservableMap.prototype, toStringTagSymbol(), "Map");
/* 'var' fixes small-build issue */

var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
var ObservableSetMarker = {};

var ObservableSet =
/** @class */
function () {
  function ObservableSet(initialData, enhancer, name) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name === void 0) {
      name = "ObservableSet@" + getNextId();
    }

    this.name = name;
    this.$mobx = ObservableSetMarker;
    this._data = new Set();
    this._atom = createAtom(this.name);

    if (typeof Set !== "function") {
      throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
    }

    this.enhancer = function (newV, oldV) {
      return enhancer(newV, oldV, name);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  ObservableSet.prototype.dehanceValue = function (value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  ObservableSet.prototype.clear = function () {
    var _this = this;

    transaction(function () {
      untracked(function () {
        _this._data.forEach(function (value) {
          _this.delete(value);
        });
      });
    });
  };

  ObservableSet.prototype.forEach = function (callbackFn, thisArg) {
    var _this = this;

    this._data.forEach(function (value) {
      callbackFn.call(thisArg, value, value, _this);
    });
  };

  Object.defineProperty(ObservableSet.prototype, "size", {
    get: function () {
      this._atom.reportObserved();

      return this._data.size;
    },
    enumerable: true,
    configurable: true
  });

  ObservableSet.prototype.add = function (value) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this._atom);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: "add",
        object: this,
        newValue: value
      });
      if (!change) return this; // TODO: ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this._data.add(_this.enhancer(value, undefined));

        _this._atom.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "add",
        object: this,
        newValue: value
      } : null;
      if (notifySpy && "development" !== "production") spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  ObservableSet.prototype.delete = function (value) {
    var _this = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: "delete",
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "delete",
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && "development" !== "production") spyReportStart(__assign(__assign({}, change), {
        name: this.name
      }));
      transaction(function () {
        _this._atom.reportChanged();

        _this._data.delete(value);
      });
      if (notify) notifyListeners(this, change);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  ObservableSet.prototype.has = function (value) {
    this._atom.reportObserved();

    return this._data.has(this.dehanceValue(value));
  };

  ObservableSet.prototype.entries = function () {
    var nextIndex = 0;
    var keys = iteratorToArray(this.keys());
    var values = iteratorToArray(this.values());
    return makeIterable({
      next: function () {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  ObservableSet.prototype.keys = function () {
    return this.values();
  };

  ObservableSet.prototype.values = function () {
    this._atom.reportObserved();

    var self = this;
    var nextIndex = 0;
    var observableValues;

    if (this._data.values !== undefined) {
      observableValues = iteratorToArray(this._data.values());
    } else {
      // There is no values function in IE11
      observableValues = [];

      this._data.forEach(function (e) {
        return observableValues.push(e);
      });
    }

    return makeIterable({
      next: function () {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  ObservableSet.prototype.replace = function (other) {
    var _this = this;

    if (isObservableSet(other)) {
      other = other.toJS();
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this.clear();

        other.forEach(function (value) {
          return _this.add(value);
        });
      } else if (isES6Set(other)) {
        _this.clear();

        other.forEach(function (value) {
          return _this.add(value);
        });
      } else if (other !== null && other !== undefined) {
        fail("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  ObservableSet.prototype.observe = function (listener, fireImmediately) {
    // TODO 'fireImmediately' can be true?
    invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  ObservableSet.prototype.intercept = function (handler) {
    return registerInterceptor(this, handler);
  };

  ObservableSet.prototype.toJS = function () {
    return new Set(this);
  };

  ObservableSet.prototype.toString = function () {
    return this.name + "[ " + iteratorToArray(this.keys()).join(", ") + " ]";
  };

  return ObservableSet;
}();

declareIterator(ObservableSet.prototype, function () {
  return this.values();
});
addHiddenFinalProp(ObservableSet.prototype, toStringTagSymbol(), "Set");
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);

var ObservableObjectAdministration =
/** @class */
function () {
  function ObservableObjectAdministration(target, name, defaultEnhancer) {
    this.target = target;
    this.name = name;
    this.defaultEnhancer = defaultEnhancer;
    this.values = {};
  }

  ObservableObjectAdministration.prototype.read = function (owner, key) {
    return this.values[key].get();
  };

  ObservableObjectAdministration.prototype.write = function (owner, key, newValue) {
    var instance = this.target;
    var observable = this.values[key];

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: "update",
        object: instance,
        name: key,
        newValue: newValue
      });
      if (!change) return;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var change = notify || notifySpy ? {
        type: "update",
        object: instance,
        oldValue: observable.value,
        name: key,
        newValue: newValue
      } : null;
      if (notifySpy) spyReportStart(__assign(__assign({}, change), {
        name: this.name,
        key: key
      }));
      observable.setNewValue(newValue);
      if (notify) notifyListeners(this, change);
      if (notifySpy) spyReportEnd();
    }
  };

  ObservableObjectAdministration.prototype.remove = function (key) {
    if (!this.values[key]) return;
    var target = this.target;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: target,
        name: key,
        type: "remove"
      });
      if (!change) return;
    }

    try {
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var oldValue = this.values[key].get();
      if (this.keys) this.keys.remove(key);
      delete this.values[key];
      delete this.target[key];
      var change = notify || notifySpy ? {
        type: "remove",
        object: target,
        oldValue: oldValue,
        name: key
      } : null;
      if (notifySpy) spyReportStart(__assign(__assign({}, change), {
        name: this.name,
        key: key
      }));
      if (notify) notifyListeners(this, change);
      if (notifySpy) spyReportEnd();
    } finally {
      endBatch();
    }
  };

  ObservableObjectAdministration.prototype.illegalAccess = function (owner, propName) {
    /**
     * This happens if a property is accessed through the prototype chain, but the property was
     * declared directly as own property on the prototype.
     *
     * E.g.:
     * class A {
     * }
     * extendObservable(A.prototype, { x: 1 })
     *
     * classB extens A {
     * }
     * console.log(new B().x)
     *
     * It is unclear whether the property should be considered 'static' or inherited.
     * Either use `console.log(A.x)`
     * or: decorate(A, { x: observable })
     *
     * When using decorate, the property will always be redeclared as own property on the actual instance
     */
    console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
  };
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */


  ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {
    invariant(fireImmediately !== true, "`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  ObservableObjectAdministration.prototype.intercept = function (handler) {
    return registerInterceptor(this, handler);
  };

  ObservableObjectAdministration.prototype.getKeys = function () {
    var _this = this;

    if (this.keys === undefined) {
      this.keys = new ObservableArray(Object.keys(this.values).filter(function (key) {
        return _this.values[key] instanceof ObservableValue;
      }), referenceEnhancer, "keys(" + this.name + ")", true);
    }

    return this.keys.slice();
  };

  return ObservableObjectAdministration;
}();

function asObservableObject(target, name, defaultEnhancer) {
  if (name === void 0) {
    name = "";
  }

  if (defaultEnhancer === void 0) {
    defaultEnhancer = deepEnhancer;
  }

  var adm = target.$mobx;
  if (adm) return adm;
  invariant(Object.isExtensible(target), "Cannot make the designated object observable; it is not extensible");
  if (!isPlainObject(target)) name = (target.constructor.name || "ObservableObject") + "@" + getNextId();
  if (!name) name = "ObservableObject@" + getNextId();
  adm = new ObservableObjectAdministration(target, name, defaultEnhancer);
  addHiddenFinalProp(target, "$mobx", adm);
  return adm;
}

function defineObservableProperty(target, propName, newValue, enhancer) {
  var adm = asObservableObject(target);
  assertPropertyConfigurable(target, propName);

  if (hasInterceptors(adm)) {
    var change = interceptChange(adm, {
      object: target,
      name: propName,
      type: "add",
      newValue: newValue
    });
    if (!change) return;
    newValue = change.newValue;
  }

  var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + "." + propName, false);
  newValue = observable.value; // observableValue might have changed it

  Object.defineProperty(target, propName, generateObservablePropConfig(propName));
  if (adm.keys) adm.keys.push(propName);
  notifyPropertyAddition(adm, target, propName, newValue);
}

function defineComputedProperty(target, // which objects holds the observable and provides `this` context?
propName, options) {
  var adm = asObservableObject(target);
  options.name = adm.name + "." + propName;
  options.context = target;
  adm.values[propName] = new ComputedValue(options);
  Object.defineProperty(target, propName, generateComputedPropConfig(propName));
}

var observablePropertyConfigs = Object.create(null);
var computedPropertyConfigs = Object.create(null);

function generateObservablePropConfig(propName) {
  return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {
    configurable: true,
    enumerable: true,
    get: function () {
      return this.$mobx.read(this, propName);
    },
    set: function (v) {
      this.$mobx.write(this, propName, v);
    }
  });
}

function getAdministrationForComputedPropOwner(owner) {
  var adm = owner.$mobx;

  if (!adm) {
    // because computed props are declared on proty,
    // the current instance might not have been initialized yet
    initializeInstance(owner);
    return owner.$mobx;
  }

  return adm;
}

function generateComputedPropConfig(propName) {
  return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {
    configurable: globalState.computedConfigurable,
    enumerable: false,
    get: function () {
      return getAdministrationForComputedPropOwner(this).read(this, propName);
    },
    set: function (v) {
      getAdministrationForComputedPropOwner(this).write(this, propName, v);
    }
  });
}

function notifyPropertyAddition(adm, object, key, newValue) {
  var notify = hasListeners(adm);
  var notifySpy = isSpyEnabled();
  var change = notify || notifySpy ? {
    type: "add",
    object: object,
    name: key,
    newValue: newValue
  } : null;
  if (notifySpy) spyReportStart(__assign(__assign({}, change), {
    name: adm.name,
    key: key
  }));
  if (notify) notifyListeners(adm, change);
  if (notifySpy) spyReportEnd();
}

var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function isObservableObject(thing) {
  if (isObject(thing)) {
    // Initializers run lazily when transpiling to babel, so make sure they are run...
    initializeInstance(thing);
    return isObservableObjectAdministration(thing.$mobx);
  }

  return false;
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) fail("It is not possible to get index atoms from arrays");
      return thing.$mobx.atom;
    }

    if (isObservableSet(thing)) {
      return thing.$mobx;
    }

    if (isObservableMap(thing)) {
      var anyThing = thing;
      if (property === undefined) return getAtom(anyThing._keys);

      var observable = anyThing._data.get(property) || anyThing._hasMap.get(property);

      if (!observable) fail("the entry '" + property + "' does not exist in the observable map '" + getDebugName(thing) + "'");
      return observable;
    } // Initializers run lazily when transpiling to babel, so make sure they are run...


    initializeInstance(thing);
    if (property && !thing.$mobx) thing[property]; // See #1072

    if (isObservableObject(thing)) {
      if (!property) return fail("please specify a property");
      var observable = thing.$mobx.values[property];
      if (!observable) fail("no observable property '" + property + "' found on the observable object '" + getDebugName(thing) + "'");
      return observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (typeof thing === "function") {
    if (isReaction(thing.$mobx)) {
      // disposer function
      return thing.$mobx;
    }
  }

  return fail("Cannot obtain atom from " + thing);
}

function getAdministration(thing, property) {
  if (!thing) fail("Expecting some object");
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing; // Initializers run lazily when transpiling to babel, so make sure they are run...

  initializeInstance(thing);
  if (thing.$mobx) return thing.$mobx;
  fail("Cannot obtain administration from " + thing);
}

function getDebugName(thing, property) {
  var named;
  if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) named = getAdministration(thing);else named = getAtom(thing); // valid for arrays as well

  return named.name;
}

var toString = Object.prototype.toString;

function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.


function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false; // Unwrap any wrapped objects.

  a = unwrap(a);
  b = unwrap(b); // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return (// eslint-disable-next-line
        typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b)
      );
  }

  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(typeof aCtor === "function" && aCtor instanceof aCtor && typeof bCtor === "function" && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key = void 0;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.peek();
  if (isES6Map(a) || isObservableMap(a)) return iteratorToArray(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return iteratorToArray(a.entries());
  return a;
}

function has$1(a, key) {
  return Object.prototype.hasOwnProperty.call(a, key);
}
/*
The only reason for this file to exist is pure horror:
Without it rollup can make the bundling fail at any point in time; when it rolls up the files in the wrong order
it will cause undefined errors (for example because super classes or local variables not being hosted).
With this file that will still happen,
but at least in this file we can magically reorder the imports with trial and error until the build succeeds again.
*/

/**
 * (c) Michel Weststrate 2015 - 2019
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */


try {} catch (e) {
  var g = getGlobal();
  if (typeof process === "undefined") g.process = {};
  g.process.env = {};
}

(function () {
  function testCodeMinification() {}

  if (testCodeMinification.name !== "testCodeMinification" && "development" !== "production" && typeof process !== 'undefined' && process.env.IGNORE_MOBX_MINIFY_WARNING !== "true") {
    // trick so it doesn't get replaced
    var varName = ["process", "env", "NODE_ENV"].join(".");
    console.warn("[mobx] you are running a minified build, but '" + varName + "' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle");
  }
})(); // forward compatibility with mobx, so that packages can easily support mobx 4 & 5


var $mobx = "$mobx";

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
} // TODO: remove in some future build


if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
  var warnedAboutDefaultExport_1 = false;
  Object.defineProperty(module.exports, "default", {
    enumerable: false,
    get: function () {
      if (!warnedAboutDefaultExport_1) {
        warnedAboutDefaultExport_1 = true;
        console.warn("The MobX package does not have a default export. Use 'import { thing } from \"mobx\"' (recommended) or 'import * as mobx from \"mobx\"' instead.\"");
      }

      return undefined;
    }
  });
  ["extras", "Atom", "BaseAtom", "asFlat", "asMap", "asReference", "asStructure", "autorunAsync", "createTranformer", "expr", "isModifierDescriptor", "isStrictModeEnabled", "map", "useStrict", "whyRun"].forEach(function (prop) {
    Object.defineProperty(module.exports, prop, {
      enumerable: false,
      get: function () {
        fail("'" + prop + "' is no longer part of the public MobX api. Please consult the changelog to find out where this functionality went");
      },
      set: function () {}
    });
  });
}

exports.$mobx = $mobx;
exports.FlowCancellationError = FlowCancellationError;
exports.ObservableMap = ObservableMap;
exports.ObservableSet = ObservableSet;
exports.Reaction = Reaction;
exports._allowStateChanges = allowStateChanges;
exports._allowStateChangesInsideComputed = allowStateChangesInsideComputed;
exports._allowStateReadsEnd = allowStateReadsEnd;
exports._allowStateReadsStart = allowStateReadsStart;
exports._endAction = _endAction;
exports._getAdministration = getAdministration;
exports._getGlobalState = getGlobalState;
exports._interceptReads = interceptReads;
exports._isComputingDerivation = isComputingDerivation;
exports._resetGlobalState = resetGlobalState;
exports._startAction = _startAction;
exports.action = action;
exports.autorun = autorun;
exports.comparer = comparer;
exports.computed = computed;
exports.configure = configure;
exports.createAtom = createAtom;
exports.decorate = decorate;
exports.entries = entries;
exports.extendObservable = extendObservable;
exports.extendShallowObservable = extendShallowObservable;
exports.flow = flow;
exports.get = get;
exports.getAtom = getAtom;
exports.getDebugName = getDebugName;
exports.getDependencyTree = getDependencyTree;
exports.getObserverTree = getObserverTree;
exports.has = has;
exports.intercept = intercept;
exports.isAction = isAction;
exports.isArrayLike = isArrayLike;
exports.isBoxedObservable = isObservableValue;
exports.isComputed = isComputed;
exports.isComputedProp = isComputedProp;
exports.isFlowCancellationError = isFlowCancellationError;
exports.isObservable = isObservable;
exports.isObservableArray = isObservableArray;
exports.isObservableMap = isObservableMap;
exports.isObservableObject = isObservableObject;
exports.isObservableProp = isObservableProp;
exports.isObservableSet = isObservableSet;
exports.keys = keys;
exports.observable = observable;
exports.observe = observe;
exports.onBecomeObserved = onBecomeObserved;
exports.onBecomeUnobserved = onBecomeUnobserved;
exports.onReactionError = onReactionError;
exports.reaction = reaction;
exports.remove = remove;
exports.runInAction = runInAction;
exports.set = set;
exports.spy = spy;
exports.toJS = toJS;
exports.trace = trace;
exports.transaction = transaction;
exports.untracked = untracked;
exports.values = values;
exports.when = when;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vYnguanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsImhhc093blByb3BlcnR5IiwiX19leHRlbmRzIiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJhcHBseSIsIl9fcmVhZCIsIm8iLCJtIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJyIiwiYXIiLCJlIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiZXJyb3IiLCJfX3NwcmVhZCIsImNvbmNhdCIsIk9CRlVTQ0FURURfRVJST1IiLCJFTVBUWV9BUlJBWSIsImZyZWV6ZSIsIkVNUFRZX09CSkVDVCIsIm1vY2tHbG9iYWwiLCJnZXRHbG9iYWwiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0TmV4dElkIiwiZ2xvYmFsU3RhdGUiLCJtb2J4R3VpZCIsImZhaWwiLCJtZXNzYWdlIiwiaW52YXJpYW50IiwiY2hlY2siLCJFcnJvciIsImRlcHJlY2F0ZWRNZXNzYWdlcyIsImRlcHJlY2F0ZWQiLCJtc2ciLCJ0aGluZyIsImluZGV4T2YiLCJjb25zb2xlIiwib25jZSIsImZ1bmMiLCJpbnZva2VkIiwibm9vcCIsInVuaXF1ZSIsImxpc3QiLCJyZXMiLCJmb3JFYWNoIiwiaXRlbSIsImlzT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb252ZXJ0VG9NYXAiLCJkYXRhU3RydWN0dXJlIiwiaXNFUzZNYXAiLCJpc09ic2VydmFibGVNYXAiLCJpc0FycmF5IiwiTWFwIiwiZW50cmllcyIsIm1ha2VOb25FbnVtZXJhYmxlIiwib2JqZWN0IiwicHJvcE5hbWVzIiwiYWRkSGlkZGVuUHJvcCIsInByb3BOYW1lIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYWRkSGlkZGVuRmluYWxQcm9wIiwiaXNQcm9wZXJ0eUNvbmZpZ3VyYWJsZSIsInByb3AiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXNzZXJ0UHJvcGVydHlDb25maWd1cmFibGUiLCJjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlIiwibmFtZSIsImNsYXp6IiwieCIsImFyZUJvdGhOYU4iLCJhIiwiaXNOYU4iLCJpc0FycmF5TGlrZSIsImlzT2JzZXJ2YWJsZUFycmF5IiwidW5kZWZpbmVkIiwiaXNFUzZTZXQiLCJTZXQiLCJpdGVyYXRvclRvQXJyYXkiLCJpdCIsInByaW1pdGl2ZVN5bWJvbCIsInRvUHJpbWl0aXZlIiwiaXRlcmF0b3JTeW1ib2wiLCJkZWNsYXJlSXRlcmF0b3IiLCJwcm90b3RUeXBlIiwiaXRlcmF0b3JGYWN0b3J5IiwibWFrZUl0ZXJhYmxlIiwiZ2V0U2VsZiIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJBdG9tIiwiaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiIsImlzQmVpbmdPYnNlcnZlZCIsIm9ic2VydmVycyIsIm9ic2VydmVyc0luZGV4ZXMiLCJkaWZmVmFsdWUiLCJsYXN0QWNjZXNzZWRCeSIsImxvd2VzdE9ic2VydmVyU3RhdGUiLCJJRGVyaXZhdGlvblN0YXRlIiwiTk9UX1RSQUNLSU5HIiwib25CZWNvbWVVbm9ic2VydmVkIiwib25CZWNvbWVPYnNlcnZlZCIsInJlcG9ydE9ic2VydmVkIiwicmVwb3J0Q2hhbmdlZCIsInN0YXJ0QmF0Y2giLCJwcm9wYWdhdGVDaGFuZ2VkIiwiZW5kQmF0Y2giLCJ0b1N0cmluZyIsImlzQXRvbSIsImNyZWF0ZUF0b20iLCJvbkJlY29tZU9ic2VydmVkSGFuZGxlciIsIm9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIiLCJhdG9tIiwiaWRlbnRpdHlDb21wYXJlciIsInN0cnVjdHVyYWxDb21wYXJlciIsImRlZXBFcXVhbCIsInNoYWxsb3dDb21wYXJlciIsImRlZmF1bHRDb21wYXJlciIsImNvbXBhcmVyIiwiaWRlbnRpdHkiLCJzdHJ1Y3R1cmFsIiwiZGVmYXVsdCIsInNoYWxsb3ciLCJlbnVtZXJhYmxlRGVzY3JpcHRvckNhY2hlIiwibm9uRW51bWVyYWJsZURlc2NyaXB0b3JDYWNoZSIsImNyZWF0ZVByb3BlcnR5SW5pdGlhbGl6ZXJEZXNjcmlwdG9yIiwiY2FjaGUiLCJnZXQiLCJpbml0aWFsaXplSW5zdGFuY2UiLCJzZXQiLCJ0YXJnZXQiLCJfX21vYnhEaWRSdW5MYXp5SW5pdGlhbGl6ZXJzIiwiZGVjb3JhdG9ycyIsIl9fbW9ieERlY29yYXRvcnMiLCJrZXkiLCJwcm9wZXJ0eUNyZWF0b3IiLCJkZWNvcmF0b3JUYXJnZXQiLCJkZWNvcmF0b3JBcmd1bWVudHMiLCJjcmVhdGVQcm9wRGVjb3JhdG9yIiwicHJvcGVydHlJbml0aWFsbHlFbnVtZXJhYmxlIiwiZGVjb3JhdG9yRmFjdG9yeSIsImRlY29yYXRvciIsImRlY29yYXRlIiwiYXBwbHlJbW1lZGlhdGVseSIsInF1YWNrc0xpa2VBRGVjb3JhdG9yIiwiaW5oZXJpdGVkRGVjb3JhdG9ycyIsInNsaWNlIiwiYXJncyIsImRlZXBFbmhhbmNlciIsInYiLCJfIiwiaXNPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsImFycmF5IiwibWFwIiwic2hhbGxvd0VuaGFuY2VyIiwiaXNPYnNlcnZhYmxlT2JqZWN0IiwiaXNPYnNlcnZhYmxlU2V0IiwiZGVlcCIsInJlZmVyZW5jZUVuaGFuY2VyIiwibmV3VmFsdWUiLCJyZWZTdHJ1Y3RFbmhhbmNlciIsIm9sZFZhbHVlIiwiY3JlYXRlRGVjb3JhdG9yRm9yRW5oYW5jZXIiLCJlbmhhbmNlciIsInByb3BlcnR5TmFtZSIsIl9kZWNvcmF0b3JUYXJnZXQiLCJkZWNvcmF0b3JBcmdzIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbGl6ZXIiLCJkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHkiLCJwcm9jZXNzIiwiZW52Iiwib2JzZXJ2YWJsZURlY29yYXRvciIsImRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyIsImRlZmF1bHREZWNvcmF0b3IiLCJzaGFsbG93Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMiLCJhc3NlcnRWYWxpZE9wdGlvbiIsInRlc3QiLCJhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zIiwia2V5cyIsImdldEVuaGFuY2VyRnJvbU9wdGlvbnMiLCJvcHRpb25zIiwiZGVlcERlY29yYXRvciIsInNoYWxsb3dEZWNvcmF0b3IiLCJyZWZEZWNvcmF0b3IiLCJyZWZTdHJ1Y3REZWNvcmF0b3IiLCJjcmVhdGVPYnNlcnZhYmxlIiwiYXJnMiIsImFyZzMiLCJvYnNlcnZhYmxlRmFjdG9yaWVzIiwiYm94IiwiaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IiLCJPYnNlcnZhYmxlVmFsdWUiLCJlcXVhbHMiLCJzaGFsbG93Qm94IiwiaW5pdGlhbFZhbHVlcyIsIk9ic2VydmFibGVBcnJheSIsInNoYWxsb3dBcnJheSIsIk9ic2VydmFibGVNYXAiLCJzaGFsbG93TWFwIiwiT2JzZXJ2YWJsZVNldCIsInByb3BzIiwiZXh0ZW5kT2JzZXJ2YWJsZSIsInNoYWxsb3dPYmplY3QiLCJyZWYiLCJzdHJ1Y3QiLCJtZXRob2ROYW1lIiwiY29tcHV0ZWREZWNvcmF0b3IiLCJpbnN0YW5jZSIsImRlZmluZUNvbXB1dGVkUHJvcGVydHkiLCJjb21wdXRlZFN0cnVjdERlY29yYXRvciIsImNvbXB1dGVkIiwiYXJnMSIsIm9wdHMiLCJDb21wdXRlZFZhbHVlIiwiVHJhY2VNb2RlIiwiQ2F1Z2h0RXhjZXB0aW9uIiwiY2F1c2UiLCJpc0NhdWdodEV4Y2VwdGlvbiIsInNob3VsZENvbXB1dGUiLCJkZXJpdmF0aW9uIiwiZGVwZW5kZW5jaWVzU3RhdGUiLCJVUF9UT19EQVRFIiwiU1RBTEUiLCJQT1NTSUJMWV9TVEFMRSIsInByZXZBbGxvd1N0YXRlUmVhZHMiLCJhbGxvd1N0YXRlUmVhZHNTdGFydCIsInByZXZVbnRyYWNrZWQiLCJ1bnRyYWNrZWRTdGFydCIsIm9icyIsIm9ic2VydmluZyIsImwiLCJvYmoiLCJpc0NvbXB1dGVkVmFsdWUiLCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzIiwidW50cmFja2VkRW5kIiwiYWxsb3dTdGF0ZVJlYWRzRW5kIiwiY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAiLCJpc0NvbXB1dGluZ0Rlcml2YXRpb24iLCJ0cmFja2luZ0Rlcml2YXRpb24iLCJjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCIsImhhc09ic2VydmVycyIsImNvbXB1dGF0aW9uRGVwdGgiLCJhbGxvd1N0YXRlQ2hhbmdlcyIsImVuZm9yY2VBY3Rpb25zIiwiY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkIiwiYWxsb3dTdGF0ZVJlYWRzIiwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24iLCJ3YXJuIiwidHJhY2tEZXJpdmVkRnVuY3Rpb24iLCJmIiwiY29udGV4dCIsIm5ld09ic2VydmluZyIsInVuYm91bmREZXBzQ291bnQiLCJydW5JZCIsInByZXZUcmFja2luZyIsInJlc3VsdCIsImJpbmREZXBlbmRlbmNpZXMiLCJ3YXJuQWJvdXREZXJpdmF0aW9uV2l0aG91dERlcGVuZGVuY2llcyIsInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlIiwicmVxdWlyZXNPYnNlcnZhYmxlIiwicHJldk9ic2VydmluZyIsImxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSIsImkwIiwiZGVwIiwicmVtb3ZlT2JzZXJ2ZXIiLCJhZGRPYnNlcnZlciIsIm9uQmVjb21lU3RhbGUiLCJjbGVhck9ic2VydmluZyIsInVudHJhY2tlZCIsImFjdGlvbiIsInByZXYiLCJjdXJyZW50QWN0aW9uSWQiLCJuZXh0QWN0aW9uSWQiLCJmdW5jdGlvbk5hbWVEZXNjcmlwdG9yIiwiaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUiLCJjcmVhdGVBY3Rpb24iLCJhY3Rpb25OYW1lIiwiZm4iLCJleGVjdXRlQWN0aW9uIiwiaXNNb2J4QWN0aW9uIiwic2NvcGUiLCJydW5JbmZvIiwiX3N0YXJ0QWN0aW9uIiwiZXJyIiwiX2VuZEFjdGlvbiIsIm5vdGlmeVNweSIsImlzU3B5RW5hYmxlZCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJmbGF0dGVuZEFyZ3MiLCJzcHlSZXBvcnRTdGFydCIsInR5cGUiLCJwcmV2RGVyaXZhdGlvbiIsInByZXZBbGxvd1N0YXRlQ2hhbmdlcyIsImFsbG93U3RhdGVDaGFuZ2VzU3RhcnQiLCJhY3Rpb25JZCIsInBhcmVudEFjdGlvbklkIiwic3VwcHJlc3NSZWFjdGlvbkVycm9ycyIsImFsbG93U3RhdGVDaGFuZ2VzRW5kIiwic3B5UmVwb3J0RW5kIiwidGltZSIsImFsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQiLCJfc3VwZXIiLCJfdGhpcyIsImhhc1VucmVwb3J0ZWRDaGFuZ2UiLCJzcHlSZXBvcnQiLCJkZWhhbmNlVmFsdWUiLCJkZWhhbmNlciIsInByZXBhcmVOZXdWYWx1ZSIsIlVOQ0hBTkdFRCIsInNldE5ld1ZhbHVlIiwiaGFzSW50ZXJjZXB0b3JzIiwiY2hhbmdlIiwiaW50ZXJjZXB0Q2hhbmdlIiwiaGFzTGlzdGVuZXJzIiwibm90aWZ5TGlzdGVuZXJzIiwiaW50ZXJjZXB0IiwiaGFuZGxlciIsInJlZ2lzdGVySW50ZXJjZXB0b3IiLCJvYnNlcnZlIiwibGlzdGVuZXIiLCJmaXJlSW1tZWRpYXRlbHkiLCJyZWdpc3Rlckxpc3RlbmVyIiwidG9KU09OIiwidmFsdWVPZiIsImlzT2JzZXJ2YWJsZVZhbHVlIiwiX19tYXBpZCIsImlzQ29tcHV0aW5nIiwiaXNSdW5uaW5nU2V0dGVyIiwiaXNUcmFjaW5nIiwiTk9ORSIsInNldHRlciIsImNvbXBhcmVTdHJ1Y3R1cmFsIiwicmVxdWlyZXNSZWFjdGlvbiIsImtlZXBBbGl2ZSIsInByb3BhZ2F0ZU1heWJlQ2hhbmdlZCIsImluQmF0Y2giLCJ3YXJuQWJvdXRVbnRyYWNrZWRSZWFkIiwiY29tcHV0ZVZhbHVlIiwidHJhY2tBbmRDb21wdXRlIiwicHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkIiwicGVlayIsIndhc1N1c3BlbmRlZCIsImNoYW5nZWQiLCJ0cmFjayIsInN1c3BlbmQiLCJmaXJzdFRpbWUiLCJwcmV2VmFsdWUiLCJhdXRvcnVuIiwicHJldlUiLCJsb2ciLCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24iLCJwZXJzaXN0ZW50S2V5cyIsIk1vYlhHbG9iYWxzIiwidmVyc2lvbiIsInBlbmRpbmdVbm9ic2VydmF0aW9ucyIsInBlbmRpbmdSZWFjdGlvbnMiLCJpc1J1bm5pbmdSZWFjdGlvbnMiLCJzcHlMaXN0ZW5lcnMiLCJnbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMiLCJjb21wdXRlZENvbmZpZ3VyYWJsZSIsImNhbk1lcmdlR2xvYmFsU3RhdGUiLCJpc29sYXRlQ2FsbGVkIiwiX19tb2J4SW5zdGFuY2VDb3VudCIsIl9fbW9ieEdsb2JhbHMiLCJzZXRUaW1lb3V0IiwiaXNvbGF0ZUdsb2JhbFN0YXRlIiwiZ2V0R2xvYmFsU3RhdGUiLCJyZXNldEdsb2JhbFN0YXRlIiwiZGVmYXVsdEdsb2JhbHMiLCJnZXRPYnNlcnZlcnMiLCJub2RlIiwicXVldWVGb3JVbm9ic2VydmF0aW9uIiwiZmlsbGVyIiwicG9wIiwiaW5kZXgiLCJydW5SZWFjdGlvbnMiLCJsb2dUcmFjZUluZm8iLCJCUkVBSyIsImxpbmVzIiwicHJpbnREZXBUcmVlIiwiZ2V0RGVwZW5kZW5jeVRyZWUiLCJGdW5jdGlvbiIsInJlcGxhY2UiLCJqb2luIiwidHJlZSIsImRlcHRoIiwiZGVwZW5kZW5jaWVzIiwiY2hpbGQiLCJSZWFjdGlvbiIsIm9uSW52YWxpZGF0ZSIsImVycm9ySGFuZGxlciIsImlzRGlzcG9zZWQiLCJfaXNTY2hlZHVsZWQiLCJfaXNUcmFja1BlbmRpbmciLCJfaXNSdW5uaW5nIiwic2NoZWR1bGUiLCJpc1NjaGVkdWxlZCIsInJ1blJlYWN0aW9uIiwicmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uIiwibm90aWZ5IiwiZGlzcG9zZSIsImdldERpc3Bvc2VyIiwiYmluZCIsIiRtb2J4IiwidHJhY2UiLCJlbnRlckJyZWFrUG9pbnQiLCJvblJlYWN0aW9uRXJyb3IiLCJpZHgiLCJzcGxpY2UiLCJNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyIsInJlYWN0aW9uU2NoZWR1bGVyIiwicnVuUmVhY3Rpb25zSGVscGVyIiwiYWxsUmVhY3Rpb25zIiwiaXRlcmF0aW9ucyIsInJlbWFpbmluZ1JlYWN0aW9ucyIsImlzUmVhY3Rpb24iLCJzZXRSZWFjdGlvblNjaGVkdWxlciIsImJhc2VTY2hlZHVsZXIiLCJldmVudCIsImxpc3RlbmVycyIsIkVORF9FVkVOVCIsInNweSIsImZpbHRlciIsImRvbnRSZWFzc2lnbkZpZWxkcyIsIm5hbWVkQWN0aW9uRGVjb3JhdG9yIiwiaW5pdGlhbGl6ZXJfMSIsImFjdGlvbkZpZWxkRGVjb3JhdG9yIiwiYm91bmRBY3Rpb25EZWNvcmF0b3IiLCJhcHBseVRvSW5zdGFuY2UiLCJkZWZpbmVCb3VuZEFjdGlvbiIsImFyZzQiLCJib3VuZCIsInJ1bkluQWN0aW9uIiwiaXNBY3Rpb24iLCJ2aWV3IiwicnVuU3luYyIsInNjaGVkdWxlciIsImRlbGF5IiwicmVhY3Rpb24iLCJyZWFjdGlvblJ1bm5lciIsIm9uRXJyb3IiLCJzY2hlZHVsZXJfMSIsImNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zIiwiaXNTY2hlZHVsZWRfMSIsInJ1biIsImV4cHJlc3Npb24iLCJlZmZlY3QiLCJlZmZlY3RBY3Rpb24iLCJ3cmFwRXJyb3JIYW5kbGVyIiwibmV4dFZhbHVlIiwiYmFzZUZuIiwiaW50ZXJjZXB0SG9vayIsImhvb2siLCJnZXRBdG9tIiwiY2IiLCJvcmlnIiwiY29uZmlndXJlIiwiYXJyYXlCdWZmZXIiLCJlYSIsInJlc2VydmVBcnJheUJ1ZmZlciIsIl9sb29wXzEiLCJwcm9wZXJ0eURlY29yYXRvcnMiLCJldmVyeSIsIm5ld0Rlc2NyaXB0b3IiLCJyZWR1Y2UiLCJhY2NEZXNjcmlwdG9yIiwiZXh0ZW5kU2hhbGxvd09ic2VydmFibGUiLCJwcm9wZXJ0aWVzIiwiYXNPYnNlcnZhYmxlT2JqZWN0IiwiaXNDb21wdXRlZCIsInJlc3VsdERlc2NyaXB0b3IiLCJwcm9wZXJ0eSIsIm5vZGVUb0RlcGVuZGVuY3lUcmVlIiwiZ2V0T2JzZXJ2ZXJUcmVlIiwibm9kZVRvT2JzZXJ2ZXJUcmVlIiwiZ2VuZXJhdG9ySWQiLCJGbG93Q2FuY2VsbGF0aW9uRXJyb3IiLCJpc0Zsb3dDYW5jZWxsYXRpb25FcnJvciIsImZsb3ciLCJnZW5lcmF0b3IiLCJjdHgiLCJnZW4iLCJyZWplY3RvciIsInBlbmRpbmdQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzdGVwSWQiLCJvbkZ1bGZpbGxlZCIsInJldCIsIm9uUmVqZWN0ZWQiLCJ0aHJvdyIsInRoZW4iLCJjYW5jZWwiLCJjYW5jZWxQcm9taXNlIiwicmVzXzEiLCJyZXR1cm4iLCJ5aWVsZGVkUHJvbWlzZSIsInByb21pc2UiLCJpbnRlcmNlcHRSZWFkcyIsInByb3BPckhhbmRsZXIiLCJnZXRBZG1pbmlzdHJhdGlvbiIsImludGVyY2VwdFByb3BlcnR5IiwiaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSIsIl9pc0NvbXB1dGVkIiwidmFsdWVzIiwiaXNDb21wdXRlZFByb3AiLCJfaXNPYnNlcnZhYmxlIiwiaXNPYnNlcnZhYmxlUHJvcCIsImdldEtleXMiLCJfa2V5cyIsInZhbHVlc18xIiwia2V5XzEiLCJhZG0iLCJleGlzdGluZ09ic2VydmFibGUiLCJ3cml0ZSIsImRlZmF1bHRFbmhhbmNlciIsImFkZCIsInBhcnNlSW50IiwicmVtb3ZlIiwiZGVsZXRlIiwiaGFzIiwicHJvcE9yQ2IiLCJjYk9yRmlyZSIsIm9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkiLCJvYnNlcnZlT2JzZXJ2YWJsZSIsImRlZmF1bHRPcHRpb25zIiwiZGV0ZWN0Q3ljbGVzIiwiZXhwb3J0TWFwc0FzT2JqZWN0cyIsInJlY3Vyc2VFdmVyeXRoaW5nIiwidG9KU0hlbHBlciIsInNvdXJjZSIsIl9fYWxyZWFkeVNlZW4iLCJ0b0FkZCIsInJlc18yIiwicmVzXzMiLCJyZXNfNCIsInJlc181IiwidG9KUyIsIl9pIiwiZ2V0QXRvbUZyb21BcmdzIiwiTE9HIiwidHJhbnNhY3Rpb24iLCJ0aGlzQXJnIiwid2hlbiIsInByZWRpY2F0ZSIsIndoZW5Qcm9taXNlIiwiX3doZW4iLCJ0aW1lb3V0SGFuZGxlIiwidGltZW91dCIsImRpc3Bvc2VyIiwiY2xlYXJUaW1lb3V0IiwiaW50ZXJjZXB0YWJsZSIsImludGVyY2VwdG9ycyIsImxpc3RlbmFibGUiLCJjaGFuZ2VMaXN0ZW5lcnMiLCJNQVhfU1BMSUNFX1NJWkUiLCJzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1ZyIsIk9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUiLCJTdHViQXJyYXkiLCJpbmhlcml0IiwiY3RvciIsImlzRnJvemVuIiwiT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24iLCJvd25lZCIsImxhc3RLbm93bkxlbmd0aCIsIm5ld1YiLCJvbGRWIiwiZGVoYW5jZVZhbHVlcyIsImFkZGVkIiwiYWRkZWRDb3VudCIsInJlbW92ZWQiLCJyZW1vdmVkQ291bnQiLCJnZXRBcnJheUxlbmd0aCIsInNldEFycmF5TGVuZ3RoIiwibmV3TGVuZ3RoIiwiY3VycmVudExlbmd0aCIsIm5ld0l0ZW1zIiwic3BsaWNlV2l0aEFycmF5IiwidXBkYXRlQXJyYXlMZW5ndGgiLCJvbGRMZW5ndGgiLCJkZWx0YSIsImRlbGV0ZUNvdW50IiwiTWF0aCIsIm1heCIsIm1pbiIsImxlbmd0aERlbHRhIiwic3BsaWNlSXRlbXNJbnRvVmFsdWVzIiwibm90aWZ5QXJyYXlTcGxpY2UiLCJfYSIsIm5vdGlmeUFycmF5Q2hpbGRVcGRhdGUiLCJFTlRSWV8wIiwiY2xlYXIiLCJhcnJheXMiLCJmaW5kIiwiZnJvbUluZGV4IiwiZmluZEluZGV4IiwiaXRlbXMiLCJzaGlmdCIsInVuc2hpZnQiLCJyZXZlcnNlIiwiY2xvbmUiLCJzb3J0IiwiY29tcGFyZUZuIiwibW92ZSIsInRvSW5kZXgiLCJjaGVja0luZGV4Iiwib2xkSXRlbXMiLCJpbXBsIiwibmV4dEluZGV4IiwiZnVuY05hbWUiLCJiYXNlRnVuYyIsImNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yIiwiY3JlYXRlQXJyYXlCdWZmZXJJdGVtIiwiaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiIsIk9ic2VydmFibGVNYXBNYXJrZXIiLCJpbml0aWFsRGF0YSIsIl9kYXRhIiwiX2hhc01hcCIsIm1lcmdlIiwiX2hhcyIsImVudHJ5IiwibmV3RW50cnkiLCJzdHJpbmdpZnlLZXkiLCJoYXNLZXkiLCJfdXBkYXRlVmFsdWUiLCJfYWRkVmFsdWUiLCJfdXBkYXRlSGFzTWFwRW50cnkiLCJjYWxsYmFjayIsIm90aGVyIiwiX2IiLCJyZXBsYWNlbWVudE1hcCIsIm9sZEtleXMiLCJuZXdLZXlzIiwiZnJvbSIsImtleXNDaGFuZ2VkIiwib2xkS2V5IiwidG9QT0pPIiwiU3RyaW5nIiwiT2JzZXJ2YWJsZVNldE1hcmtlciIsIl9hdG9tIiwiY2FsbGJhY2tGbiIsInNpemUiLCJvYnNlcnZhYmxlVmFsdWVzIiwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uIiwicmVhZCIsIm93bmVyIiwiaWxsZWdhbEFjY2VzcyIsImlzRXh0ZW5zaWJsZSIsImdlbmVyYXRlT2JzZXJ2YWJsZVByb3BDb25maWciLCJub3RpZnlQcm9wZXJ0eUFkZGl0aW9uIiwiZ2VuZXJhdGVDb21wdXRlZFByb3BDb25maWciLCJvYnNlcnZhYmxlUHJvcGVydHlDb25maWdzIiwiY29tcHV0ZWRQcm9wZXJ0eUNvbmZpZ3MiLCJnZXRBZG1pbmlzdHJhdGlvbkZvckNvbXB1dGVkUHJvcE93bmVyIiwiaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24iLCJhbnlUaGluZyIsImdldERlYnVnTmFtZSIsIm5hbWVkIiwiZXEiLCJhU3RhY2siLCJiU3RhY2siLCJ1bndyYXAiLCJjbGFzc05hbWUiLCJhcmVBcnJheXMiLCJhQ3RvciIsImJDdG9yIiwiaGFzJDEiLCJnIiwidGVzdENvZGVNaW5pZmljYXRpb24iLCJJR05PUkVfTU9CWF9NSU5JRllfV0FSTklORyIsInZhck5hbWUiLCJfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImluamVjdE1vYngiLCJleHRyYXMiLCJtb2R1bGUiLCJ3YXJuZWRBYm91dERlZmF1bHRFeHBvcnRfMSIsIl9hbGxvd1N0YXRlQ2hhbmdlcyIsIl9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkIiwiX2FsbG93U3RhdGVSZWFkc0VuZCIsIl9hbGxvd1N0YXRlUmVhZHNTdGFydCIsIl9nZXRBZG1pbmlzdHJhdGlvbiIsIl9nZXRHbG9iYWxTdGF0ZSIsIl9pbnRlcmNlcHRSZWFkcyIsIl9pc0NvbXB1dGluZ0Rlcml2YXRpb24iLCJfcmVzZXRHbG9iYWxTdGF0ZSIsImlzQm94ZWRPYnNlcnZhYmxlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLEVBQUFBLEtBQUssRUFBRTtBQUFULENBQTdDO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBOztBQUVBLElBQUlDLGFBQWEsR0FBRyxVQUFTQyxDQUFULEVBQVlDLENBQVosRUFBZTtBQUMvQkYsRUFBQUEsYUFBYSxHQUFHSixNQUFNLENBQUNPLGNBQVAsSUFDWDtBQUFFQyxJQUFBQSxTQUFTLEVBQUU7QUFBYixlQUE2QkMsS0FBN0IsSUFBc0MsVUFBVUosQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQUVELElBQUFBLENBQUMsQ0FBQ0csU0FBRixHQUFjRixDQUFkO0FBQWtCLEdBRC9ELElBRVosVUFBVUQsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQUUsU0FBSyxJQUFJSSxDQUFULElBQWNKLENBQWQsRUFBaUIsSUFBSUEsQ0FBQyxDQUFDSyxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCTCxDQUFDLENBQUNLLENBQUQsQ0FB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QUFSLEdBQTBCQSxlQUExQjtBQUNBeGIsT0FBTyxDQUFDd2QsUUFBUixHQUFtQkEsUUFBbkI7QUFDQXhkLE9BQU8sQ0FBQ3lpQixNQUFSLEdBQWlCQSxNQUFqQjtBQUNBemlCLE9BQU8sQ0FBQ2tkLFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0FsZCxPQUFPLENBQUMrSixHQUFSLEdBQWNBLEdBQWQ7QUFDQS9KLE9BQU8sQ0FBQ3VjLEdBQVIsR0FBY0EsR0FBZDtBQUNBdmMsT0FBTyxDQUFDNGpCLElBQVIsR0FBZUEsSUFBZjtBQUNBNWpCLE9BQU8sQ0FBQ3NiLEtBQVIsR0FBZ0JBLEtBQWhCO0FBQ0F0YixPQUFPLENBQUNna0IsV0FBUixHQUFzQkEsV0FBdEI7QUFDQWhrQixPQUFPLENBQUM0UyxTQUFSLEdBQW9CQSxTQUFwQjtBQUNBNVMsT0FBTyxDQUFDMmhCLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0EzaEIsT0FBTyxDQUFDa2tCLElBQVIsR0FBZUEsSUFBZiIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBNb2JYIC0gKGMpIE1pY2hlbCBXZXN0c3RyYXRlIDIwMTUgLSAyMDIwIC0gTUlUIExpY2Vuc2VkICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxuXG52YXIgT0JGVVNDQVRFRF9FUlJPUiA9IFwiQW4gaW52YXJpYW50IGZhaWxlZCwgaG93ZXZlciB0aGUgZXJyb3IgaXMgb2JmdXNjYXRlZCBiZWNhdXNlIHRoaXMgaXMgYW4gcHJvZHVjdGlvbiBidWlsZC5cIjtcclxudmFyIEVNUFRZX0FSUkFZID0gW107XHJcbk9iamVjdC5mcmVlemUoRU1QVFlfQVJSQVkpO1xyXG52YXIgRU1QVFlfT0JKRUNUID0ge307XHJcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcclxudmFyIG1vY2tHbG9iYWwgPSB7fTtcclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9ja0dsb2JhbDtcclxufVxyXG5mdW5jdGlvbiBnZXROZXh0SWQoKSB7XHJcbiAgICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcclxufVxyXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcclxuICAgIGludmFyaWFudChmYWxzZSwgbWVzc2FnZSk7XHJcbiAgICB0aHJvdyBcIlhcIjsgLy8gdW5yZWFjaGFibGVcclxufVxyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgIGlmICghY2hlY2spXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIFwiICsgKG1lc3NhZ2UgfHwgT0JGVVNDQVRFRF9FUlJPUikpO1xyXG59XHJcbi8qKlxyXG4gKiBQcmludHMgYSBkZXByZWNhdGlvbiBtZXNzYWdlLCBidXQgb25seSBvbmUgdGltZS5cclxuICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZGVwcmVjYXRlZCBtZXNzYWdlIHdhcyBhbHJlYWR5IHByaW50ZWQgYmVmb3JlXHJcbiAqL1xyXG52YXIgZGVwcmVjYXRlZE1lc3NhZ2VzID0gW107XHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobXNnLCB0aGluZykge1xyXG4gICAgaWYgKHRoaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWQoXCInXCIgKyBtc2cgKyBcIicsIHVzZSAnXCIgKyB0aGluZyArIFwiJyBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuICAgIGlmIChkZXByZWNhdGVkTWVzc2FnZXMuaW5kZXhPZihtc2cpICE9PSAtMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkZXByZWNhdGVkTWVzc2FnZXMucHVzaChtc2cpO1xyXG4gICAgY29uc29sZS5lcnJvcihcIlttb2J4XSBEZXByZWNhdGVkOiBcIiArIG1zZyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBpbnZva2VkIGF0IG1vc3Qgb25jZS5cclxuICovXHJcbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xyXG4gICAgdmFyIGludm9rZWQgPSBmYWxzZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGludm9rZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpbnZva2VkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihpdGVtKSA9PT0gLTEpXHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcclxuICAgIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAoZGF0YVN0cnVjdHVyZSkge1xyXG4gICAgaWYgKGlzRVM2TWFwKGRhdGFTdHJ1Y3R1cmUpIHx8IGlzT2JzZXJ2YWJsZU1hcChkYXRhU3RydWN0dXJlKSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhU3RydWN0dXJlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhU3RydWN0dXJlKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFwKGRhdGFTdHJ1Y3R1cmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChkYXRhU3RydWN0dXJlKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGRhdGFTdHJ1Y3R1cmUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKFwiQ2Fubm90IGNvbnZlcnQgdG8gbWFwIGZyb20gJ1wiICsgZGF0YVN0cnVjdHVyZSArIFwiJ1wiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYWtlTm9uRW51bWVyYWJsZShvYmplY3QsIHByb3BOYW1lcykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWVzW2ldLCBvYmplY3RbcHJvcE5hbWVzW2ldXSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkSGlkZGVuUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBhZGRIaWRkZW5GaW5hbFByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJvcGVydHlDb25maWd1cmFibGUob2JqZWN0LCBwcm9wKSB7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcclxuICAgIHJldHVybiAhZGVzY3JpcHRvciB8fCAoZGVzY3JpcHRvci5jb25maWd1cmFibGUgIT09IGZhbHNlICYmIGRlc2NyaXB0b3Iud3JpdGFibGUgIT09IGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRQcm9wZXJ0eUNvbmZpZ3VyYWJsZShvYmplY3QsIHByb3ApIHtcclxuICAgIGlmICghaXNQcm9wZXJ0eUNvbmZpZ3VyYWJsZShvYmplY3QsIHByb3ApKVxyXG4gICAgICAgIGZhaWwoXCJDYW5ub3QgbWFrZSBwcm9wZXJ0eSAnXCIgKyBwcm9wICsgXCInIG9ic2VydmFibGUsIGl0IGlzIG5vdCBjb25maWd1cmFibGUgYW5kIHdyaXRhYmxlIGluIHRoZSB0YXJnZXQgb2JqZWN0XCIpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUobmFtZSwgY2xhenopIHtcclxuICAgIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xyXG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BOYW1lXSA9IHRydWU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeFtwcm9wTmFtZV0gPT09IHRydWU7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFyZUJvdGhOYU4oYSwgYikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiICYmIGlzTmFOKGEpICYmIGlzTmFOKGIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCBkaXNyZWdhcmRpbmcgb2JzZXJ2YWJpbGl0eS5cclxuICovXHJcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHgpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHgpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRVM2TWFwKHRoaW5nKSB7XHJcbiAgICBpZiAoZ2V0R2xvYmFsKCkuTWFwICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgaW5zdGFuY2VvZiBnZXRHbG9iYWwoKS5NYXApXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNFUzZTZXQodGhpbmcpIHtcclxuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIFNldDtcclxufVxyXG4vLyB1c2UgQXJyYXkuZnJvbSBpbiBNb2J4IDVcclxuZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0KSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByID0gaXQubmV4dCgpO1xyXG4gICAgICAgIGlmIChyLmRvbmUpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHJlcy5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBwcmltaXRpdmVTeW1ib2woKSB7XHJcbiAgICAvLyBlcy1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgcmV0dXJuICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBcIkBAdG9QcmltaXRpdmVcIjtcclxufVxyXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gbnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IFwiXCIgKyB2YWx1ZSA6IHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yU3ltYm9sKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fCBcIkBAaXRlcmF0b3JcIjtcclxufVxyXG5mdW5jdGlvbiBkZWNsYXJlSXRlcmF0b3IocHJvdG90VHlwZSwgaXRlcmF0b3JGYWN0b3J5KSB7XHJcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AocHJvdG90VHlwZSwgaXRlcmF0b3JTeW1ib2woKSwgaXRlcmF0b3JGYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpIHtcclxuICAgIGl0ZXJhdG9yW2l0ZXJhdG9yU3ltYm9sKCldID0gZ2V0U2VsZjtcclxuICAgIHJldHVybiBpdGVyYXRvcjtcclxufVxyXG5mdW5jdGlvbiB0b1N0cmluZ1RhZ1N5bWJvbCgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZykgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VsZigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XG5cbi8qKlxyXG4gKiBBbnl0aGluZyB0aGF0IGNhbiBiZSB1c2VkIHRvIF9zdG9yZV8gc3RhdGUgaXMgYW4gQXRvbSBpbiBtb2J4LiBBdG9tcyBoYXZlIHR3byBpbXBvcnRhbnQgam9ic1xyXG4gKlxyXG4gKiAxKSBkZXRlY3Qgd2hlbiB0aGV5IGFyZSBiZWluZyBfdXNlZF8gYW5kIHJlcG9ydCB0aGlzICh1c2luZyByZXBvcnRPYnNlcnZlZCkuIFRoaXMgYWxsb3dzIG1vYnggdG8gbWFrZSB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIHJ1bm5pbmcgZnVuY3Rpb25zIGFuZCB0aGUgZGF0YSB0aGV5IHVzZWRcclxuICogMikgdGhleSBzaG91bGQgbm90aWZ5IG1vYnggd2hlbmV2ZXIgdGhleSBoYXZlIF9jaGFuZ2VkXy4gVGhpcyB3YXkgbW9ieCBjYW4gcmUtcnVuIGFueSBmdW5jdGlvbnMgKGRlcml2YXRpb25zKSB0aGF0IGFyZSB1c2luZyB0aGlzIGF0b20uXHJcbiAqL1xyXG52YXIgQXRvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXHJcbiAgICAgKiBUaGUgb25CZWNvbWVPYnNlcnZlZCBhbmQgb25CZWNvbWVVbm9ic2VydmVkIGNhbGxiYWNrcyBjYW4gYmUgdXNlZCBmb3IgcmVzb3VyY2UgbWFuYWdlbWVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQXRvbShuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJBdG9tQFwiICsgZ2V0TmV4dElkKCk7IH1cclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiA9IGZhbHNlOyAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcclxuICAgICAgICB0aGlzLmlzQmVpbmdPYnNlcnZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNJbmRleGVzID0ge307XHJcbiAgICAgICAgdGhpcy5kaWZmVmFsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdEFjY2Vzc2VkQnkgPSAwO1xyXG4gICAgICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkc7XHJcbiAgICB9XHJcbiAgICBBdG9tLnByb3RvdHlwZS5vbkJlY29tZVVub2JzZXJ2ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbm9vcFxyXG4gICAgfTtcclxuICAgIEF0b20ucHJvdG90eXBlLm9uQmVjb21lT2JzZXJ2ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyogbm9vcCAqL1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIG5vdGlmeSBtb2J4IHRoYXQgeW91ciBhdG9tIGhhcyBiZWVuIHVzZWQgc29tZWhvdy5cclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSByZWFjdGl2ZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBBdG9tLnByb3RvdHlwZS5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgX2FmdGVyXyB0aGlzIG1ldGhvZCBoYXMgY2hhbmdlZCB0byBzaWduYWwgbW9ieCB0aGF0IGFsbCBpdHMgb2JzZXJ2ZXJzIHNob3VsZCBpbnZhbGlkYXRlLlxyXG4gICAgICovXHJcbiAgICBBdG9tLnByb3RvdHlwZS5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgICAgICBwcm9wYWdhdGVDaGFuZ2VkKHRoaXMpO1xyXG4gICAgICAgIGVuZEJhdGNoKCk7XHJcbiAgICB9O1xyXG4gICAgQXRvbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXRvbTtcclxufSgpKTtcclxudmFyIGlzQXRvbSA9IGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJBdG9tXCIsIEF0b20pO1xyXG5mdW5jdGlvbiBjcmVhdGVBdG9tKG5hbWUsIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKSB7XHJcbiAgICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkgeyBvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9IG5vb3A7IH1cclxuICAgIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHsgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9IG5vb3A7IH1cclxuICAgIHZhciBhdG9tID0gbmV3IEF0b20obmFtZSk7XHJcbiAgICBvbkJlY29tZU9ic2VydmVkKGF0b20sIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyKTtcclxuICAgIG9uQmVjb21lVW5vYnNlcnZlZChhdG9tLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKTtcclxuICAgIHJldHVybiBhdG9tO1xyXG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5Q29tcGFyZXIoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuZnVuY3Rpb24gc3RydWN0dXJhbENvbXBhcmVyKGEsIGIpIHtcclxuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmVyKGEsIGIpIHtcclxuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgMSk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVyKGEsIGIpIHtcclxuICAgIHJldHVybiBhcmVCb3RoTmFOKGEsIGIpIHx8IGlkZW50aXR5Q29tcGFyZXIoYSwgYik7XHJcbn1cclxudmFyIGNvbXBhcmVyID0ge1xyXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5Q29tcGFyZXIsXHJcbiAgICBzdHJ1Y3R1cmFsOiBzdHJ1Y3R1cmFsQ29tcGFyZXIsXHJcbiAgICBkZWZhdWx0OiBkZWZhdWx0Q29tcGFyZXIsXHJcbiAgICBzaGFsbG93OiBzaGFsbG93Q29tcGFyZXJcclxufTtcblxudmFyIGVudW1lcmFibGVEZXNjcmlwdG9yQ2FjaGUgPSB7fTtcclxudmFyIG5vbkVudW1lcmFibGVEZXNjcmlwdG9yQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlJbml0aWFsaXplckRlc2NyaXB0b3IocHJvcCwgZW51bWVyYWJsZSkge1xyXG4gICAgdmFyIGNhY2hlID0gZW51bWVyYWJsZSA/IGVudW1lcmFibGVEZXNjcmlwdG9yQ2FjaGUgOiBub25FbnVtZXJhYmxlRGVzY3JpcHRvckNhY2hlO1xyXG4gICAgcmV0dXJuIChjYWNoZVtwcm9wXSB8fFxyXG4gICAgICAgIChjYWNoZVtwcm9wXSA9IHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRpYWxpemVJbnN0YW5jZSh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQuX19tb2J4RGlkUnVuTGF6eUluaXRpYWxpemVycyA9PT0gdHJ1ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgZGVjb3JhdG9ycyA9IHRhcmdldC5fX21vYnhEZWNvcmF0b3JzO1xyXG4gICAgaWYgKGRlY29yYXRvcnMpIHtcclxuICAgICAgICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgXCJfX21vYnhEaWRSdW5MYXp5SW5pdGlhbGl6ZXJzXCIsIHRydWUpO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZWNvcmF0b3JzKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gZGVjb3JhdG9yc1trZXldO1xyXG4gICAgICAgICAgICBkLnByb3BlcnR5Q3JlYXRvcih0YXJnZXQsIGQucHJvcCwgZC5kZXNjcmlwdG9yLCBkLmRlY29yYXRvclRhcmdldCwgZC5kZWNvcmF0b3JBcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQcm9wRGVjb3JhdG9yKHByb3BlcnR5SW5pdGlhbGx5RW51bWVyYWJsZSwgcHJvcGVydHlDcmVhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yRmFjdG9yeSgpIHtcclxuICAgICAgICB2YXIgZGVjb3JhdG9yQXJndW1lbnRzO1xyXG4gICAgICAgIHZhciBkZWNvcmF0b3IgPSBmdW5jdGlvbiBkZWNvcmF0ZSh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IsIGFwcGx5SW1tZWRpYXRlbHlcclxuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBwYXJhbWV0ZXIgdG8gc2lnbmFsIHRoZSBkaXJlY3QgYXBwbGljYXRpb24gb2YgYSBkZWNvcmF0b3IsIGFsbG93IGV4dGVuZE9ic2VydmFibGUgdG8gc2tpcCB0aGUgZW50aXJlIHR5cGUgZGVjb3JhdGlvbiBwYXJ0LFxyXG4gICAgICAgIC8vIGFzIHRoZSBpbnN0YW5jZSB0byBhcHBseSB0aGUgZGVjb3JhdG9yIHRvIGVxdWFscyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChhcHBseUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUNyZWF0b3IodGFyZ2V0LCBwcm9wLCBkZXNjcmlwdG9yLCB0YXJnZXQsIGRlY29yYXRvckFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXF1YWNrc0xpa2VBRGVjb3JhdG9yKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICAgICBmYWlsKFwiVGhpcyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciwgYnV0IGl0IHdhc24ndCBpbnZva2VkIGxpa2UgYSBkZWNvcmF0b3JcIik7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgXCJfX21vYnhEZWNvcmF0b3JzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGVkRGVjb3JhdG9ycyA9IHRhcmdldC5fX21vYnhEZWNvcmF0b3JzO1xyXG4gICAgICAgICAgICAgICAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsIFwiX19tb2J4RGVjb3JhdG9yc1wiLCBfX2Fzc2lnbih7fSwgaW5oZXJpdGVkRGVjb3JhdG9ycykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fX21vYnhEZWNvcmF0b3JzW3Byb3BdID0ge1xyXG4gICAgICAgICAgICAgICAgcHJvcDogcHJvcCxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5Q3JlYXRvcjogcHJvcGVydHlDcmVhdG9yLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcclxuICAgICAgICAgICAgICAgIGRlY29yYXRvclRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yQXJndW1lbnRzOiBkZWNvcmF0b3JBcmd1bWVudHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3BlcnR5SW5pdGlhbGl6ZXJEZXNjcmlwdG9yKHByb3AsIHByb3BlcnR5SW5pdGlhbGx5RW51bWVyYWJsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocXVhY2tzTGlrZUFEZWNvcmF0b3IoYXJndW1lbnRzKSkge1xyXG4gICAgICAgICAgICAvLyBAZGVjb3JhdG9yXHJcbiAgICAgICAgICAgIGRlY29yYXRvckFyZ3VtZW50cyA9IEVNUFRZX0FSUkFZO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBAZGVjb3JhdG9yKGFyZ3MpXHJcbiAgICAgICAgICAgIGRlY29yYXRvckFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBxdWFja3NMaWtlQURlY29yYXRvcihhcmdzKSB7XHJcbiAgICByZXR1cm4gKCgoYXJncy5sZW5ndGggPT09IDIgfHwgYXJncy5sZW5ndGggPT09IDMpICYmIHR5cGVvZiBhcmdzWzFdID09PSBcInN0cmluZ1wiKSB8fFxyXG4gICAgICAgIChhcmdzLmxlbmd0aCA9PT0gNCAmJiBhcmdzWzNdID09PSB0cnVlKSk7XHJcbn1cblxuZnVuY3Rpb24gZGVlcEVuaGFuY2VyKHYsIF8sIG5hbWUpIHtcclxuICAgIC8vIGl0IGlzIGFuIG9ic2VydmFibGUgYWxyZWFkeSwgZG9uZVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh2KSlcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIC8vIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgYW5kIG11dGF0ZWQ/XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSlcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7IG5hbWU6IG5hbWUgfSk7XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2KSlcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7IG5hbWU6IG5hbWUgfSk7XHJcbiAgICBpZiAoaXNFUzZNYXAodikpXHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHsgbmFtZTogbmFtZSB9KTtcclxuICAgIGlmIChpc0VTNlNldCh2KSlcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwgeyBuYW1lOiBuYW1lIH0pO1xyXG4gICAgcmV0dXJuIHY7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd0VuaGFuY2VyKHYsIF8sIG5hbWUpIHtcclxuICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodikgfHwgaXNPYnNlcnZhYmxlQXJyYXkodikgfHwgaXNPYnNlcnZhYmxlTWFwKHYpIHx8IGlzT2JzZXJ2YWJsZVNldCh2KSlcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKVxyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHsgbmFtZTogbmFtZSwgZGVlcDogZmFsc2UgfSk7XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2KSlcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7IG5hbWU6IG5hbWUsIGRlZXA6IGZhbHNlIH0pO1xyXG4gICAgaWYgKGlzRVM2TWFwKHYpKVxyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7IG5hbWU6IG5hbWUsIGRlZXA6IGZhbHNlIH0pO1xyXG4gICAgaWYgKGlzRVM2U2V0KHYpKVxyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7IG5hbWU6IG5hbWUsIGRlZXA6IGZhbHNlIH0pO1xyXG4gICAgcmV0dXJuIGZhaWwoXCJUaGUgc2hhbGxvdyBtb2RpZmllciAvIGRlY29yYXRvciBjYW4gb25seSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYXJyYXlzLCBvYmplY3RzLCBtYXBzIGFuZCBzZXRzXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZmVyZW5jZUVuaGFuY2VyKG5ld1ZhbHVlKSB7XHJcbiAgICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxyXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlZlN0cnVjdEVuaGFuY2VyKHYsIG9sZFZhbHVlLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHYpKVxyXG4gICAgICAgIHRocm93IFwib2JzZXJ2YWJsZS5zdHJ1Y3Qgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggb2JzZXJ2YWJsZSB2YWx1ZXNcIjtcclxuICAgIGlmIChkZWVwRXF1YWwodiwgb2xkVmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBvbGRWYWx1ZTtcclxuICAgIHJldHVybiB2O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKGVuaGFuY2VyKSB7XHJcbiAgICBpbnZhcmlhbnQoZW5oYW5jZXIpO1xyXG4gICAgdmFyIGRlY29yYXRvciA9IGNyZWF0ZVByb3BEZWNvcmF0b3IodHJ1ZSwgZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLCBfZGVjb3JhdG9yVGFyZ2V0LCBkZWNvcmF0b3JBcmdzKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnZhcmlhbnQoIWRlc2NyaXB0b3IgfHwgIWRlc2NyaXB0b3IuZ2V0LCBcIkBvYnNlcnZhYmxlIGNhbm5vdCBiZSB1c2VkIG9uIGdldHRlciAocHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHlOYW1lICsgXCJcXFwiKSwgdXNlIEBjb21wdXRlZCBpbnN0ZWFkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IGRlc2NyaXB0b3JcclxuICAgICAgICAgICAgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyXHJcbiAgICAgICAgICAgICAgICA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbCh0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICA6IGRlc2NyaXB0b3IudmFsdWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlOYW1lLCBpbml0aWFsVmFsdWUsIGVuaGFuY2VyKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIHJlcyA9IFxyXG4gICAgLy8gRXh0cmEgcHJvY2VzcyBjaGVja3MsIGFzIHRoaXMgaGFwcGVucyBkdXJpbmcgbW9kdWxlIGluaXRpYWxpemF0aW9uXHJcbiAgICB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiXHJcbiAgICAgICAgPyBmdW5jdGlvbiBvYnNlcnZhYmxlRGVjb3JhdG9yKCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gaXMganVzdCB0byBkZXRlY3QgaWxsZWdhbCBkZWNvcmF0b3IgaW52b2NhdGlvbnMsIGRlcHJlY2F0ZSBpbiBhIG5leHQgdmVyc2lvblxyXG4gICAgICAgICAgICAvLyBhbmQgc2ltcGx5IHJldHVybiB0aGUgY3JlYXRlZCBwcm9wIGRlY29yYXRvclxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcIkluY29ycmVjdCBkZWNvcmF0b3IgaW52b2NhdGlvbi4gQG9ic2VydmFibGUgZGVjb3JhdG9yIGRvZXNuJ3QgZXhwZWN0IGFueSBhcmd1bWVudHNcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBkZWNvcmF0b3I7XHJcbiAgICByZXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcclxuICAgIHJldHVybiByZXM7XHJcbn1cblxuLy8gUHJlZGVmaW5lZCBiYWdzIG9mIGNyZWF0ZSBvYnNlcnZhYmxlIG9wdGlvbnMsIHRvIGF2b2lkIGFsbG9jYXRpbmcgdGVtcG9yYXJpbHkgb3B0aW9uIG9iamVjdHNcclxuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXHJcbnZhciBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XHJcbiAgICBkZWVwOiB0cnVlLFxyXG4gICAgbmFtZTogdW5kZWZpbmVkLFxyXG4gICAgZGVmYXVsdERlY29yYXRvcjogdW5kZWZpbmVkXHJcbn07XHJcbnZhciBzaGFsbG93Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XHJcbiAgICBkZWVwOiBmYWxzZSxcclxuICAgIG5hbWU6IHVuZGVmaW5lZCxcclxuICAgIGRlZmF1bHREZWNvcmF0b3I6IHVuZGVmaW5lZFxyXG59O1xyXG5PYmplY3QuZnJlZXplKGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyk7XHJcbk9iamVjdC5mcmVlemUoc2hhbGxvd0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKTtcclxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRPcHRpb24oa2V5KSB7XHJcbiAgICBpZiAoIS9eKGRlZXB8bmFtZXxlcXVhbHN8ZGVmYXVsdERlY29yYXRvcikkLy50ZXN0KGtleSkpXHJcbiAgICAgICAgZmFpbChcImludmFsaWQgb3B0aW9uIGZvciAoZXh0ZW5kKW9ic2VydmFibGU6IFwiICsga2V5KTtcclxufVxyXG5mdW5jdGlvbiBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKHRoaW5nKSB7XHJcbiAgICBpZiAodGhpbmcgPT09IG51bGwgfHwgdGhpbmcgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zO1xyXG4gICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGluZywgZGVlcDogdHJ1ZSB9O1xyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpbmcgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKFwiZXhwZWN0ZWQgb3B0aW9ucyBvYmplY3RcIik7XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpbmcpLmZvckVhY2goYXNzZXJ0VmFsaWRPcHRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaW5nO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdERlY29yYXRvclxyXG4gICAgICAgID8gb3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yLmVuaGFuY2VyXHJcbiAgICAgICAgOiBvcHRpb25zLmRlZXAgPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8gcmVmZXJlbmNlRW5oYW5jZXJcclxuICAgICAgICAgICAgOiBkZWVwRW5oYW5jZXI7XHJcbn1cclxudmFyIGRlZXBEZWNvcmF0b3IgPSBjcmVhdGVEZWNvcmF0b3JGb3JFbmhhbmNlcihkZWVwRW5oYW5jZXIpO1xyXG52YXIgc2hhbGxvd0RlY29yYXRvciA9IGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKHNoYWxsb3dFbmhhbmNlcik7XHJcbnZhciByZWZEZWNvcmF0b3IgPSBjcmVhdGVEZWNvcmF0b3JGb3JFbmhhbmNlcihyZWZlcmVuY2VFbmhhbmNlcik7XHJcbnZhciByZWZTdHJ1Y3REZWNvcmF0b3IgPSBjcmVhdGVEZWNvcmF0b3JGb3JFbmhhbmNlcihyZWZTdHJ1Y3RFbmhhbmNlcik7XHJcbi8qKlxyXG4gKiBUdXJucyBhbiBvYmplY3QsIGFycmF5IG9yIGZ1bmN0aW9uIGludG8gYSByZWFjdGl2ZSBzdHJ1Y3R1cmUuXHJcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmVjb21lIG9ic2VydmFibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHYsIGFyZzIsIGFyZzMpIHtcclxuICAgIC8vIEBvYnNlcnZhYmxlIHNvbWVQcm9wO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gZGVlcERlY29yYXRvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHYpKVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgLy8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCBhbmQgbXV0YXRlZD9cclxuICAgIHZhciByZXMgPSBpc1BsYWluT2JqZWN0KHYpXHJcbiAgICAgICAgPyBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKVxyXG4gICAgICAgIDogQXJyYXkuaXNBcnJheSh2KVxyXG4gICAgICAgICAgICA/IG9ic2VydmFibGUuYXJyYXkodiwgYXJnMilcclxuICAgICAgICAgICAgOiBpc0VTNk1hcCh2KVxyXG4gICAgICAgICAgICAgICAgPyBvYnNlcnZhYmxlLm1hcCh2LCBhcmcyKVxyXG4gICAgICAgICAgICAgICAgOiBpc0VTNlNldCh2KVxyXG4gICAgICAgICAgICAgICAgICAgID8gb2JzZXJ2YWJsZS5zZXQodiwgYXJnMilcclxuICAgICAgICAgICAgICAgICAgICA6IHY7XHJcbiAgICAvLyB0aGlzIHZhbHVlIGNvdWxkIGJlIGNvbnZlcnRlZCB0byBhIG5ldyBvYnNlcnZhYmxlIGRhdGEgc3RydWN0dXJlLCByZXR1cm4gaXRcclxuICAgIGlmIChyZXMgIT09IHYpXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIC8vIG90aGVyd2lzZSwganVzdCBib3ggaXRcclxuICAgIGZhaWwoXCJUaGUgcHJvdmlkZWQgdmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCBpbnRvIGFuIG9ic2VydmFibGUuIElmIHlvdSB3YW50IGp1c3QgY3JlYXRlIGFuIG9ic2VydmFibGUgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgdXNlICdvYnNlcnZhYmxlLmJveCh2YWx1ZSknXCIpO1xyXG59XHJcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xyXG4gICAgYm94OiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgICAgIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKFwiYm94XCIpO1xyXG4gICAgICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XHJcbiAgICB9LFxyXG4gICAgc2hhbGxvd0JveDogZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxyXG4gICAgICAgICAgICBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihcInNoYWxsb3dCb3hcIik7XHJcbiAgICAgICAgZGVwcmVjYXRlZChcIm9ic2VydmFibGUuc2hhbGxvd0JveFwiLCBcIm9ic2VydmFibGUuYm94KHZhbHVlLCB7IGRlZXA6IGZhbHNlIH0pXCIpO1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLmJveCh2YWx1ZSwgeyBuYW1lOiBuYW1lLCBkZWVwOiBmYWxzZSB9KTtcclxuICAgIH0sXHJcbiAgICBhcnJheTogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgICAgIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKFwiYXJyYXlcIik7XHJcbiAgICAgICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XHJcbiAgICB9LFxyXG4gICAgc2hhbGxvd0FycmF5OiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlcywgbmFtZSkge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcclxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJzaGFsbG93QXJyYXlcIik7XHJcbiAgICAgICAgZGVwcmVjYXRlZChcIm9ic2VydmFibGUuc2hhbGxvd0FycmF5XCIsIFwib2JzZXJ2YWJsZS5hcnJheSh2YWx1ZXMsIHsgZGVlcDogZmFsc2UgfSlcIik7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkoaW5pdGlhbFZhbHVlcywgeyBuYW1lOiBuYW1lLCBkZWVwOiBmYWxzZSB9KTtcclxuICAgIH0sXHJcbiAgICBtYXA6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxyXG4gICAgICAgICAgICBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihcIm1hcFwiKTtcclxuICAgICAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlTWFwKGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XHJcbiAgICB9LFxyXG4gICAgc2hhbGxvd01hcDogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG5hbWUpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgICAgIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKFwic2hhbGxvd01hcFwiKTtcclxuICAgICAgICBkZXByZWNhdGVkKFwib2JzZXJ2YWJsZS5zaGFsbG93TWFwXCIsIFwib2JzZXJ2YWJsZS5tYXAodmFsdWVzLCB7IGRlZXA6IGZhbHNlIH0pXCIpO1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcChpbml0aWFsVmFsdWVzLCB7IG5hbWU6IG5hbWUsIGRlZXA6IGZhbHNlIH0pO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgICAgIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKFwic2V0XCIpO1xyXG4gICAgICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcclxuICAgIH0sXHJcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwcm9wcywgZGVjb3JhdG9ycywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihcIm9iamVjdFwiKTtcclxuICAgICAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUoe30sIHByb3BzLCBkZWNvcmF0b3JzLCBvKTtcclxuICAgIH0sXHJcbiAgICBzaGFsbG93T2JqZWN0OiBmdW5jdGlvbiAocHJvcHMsIG5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJzaGFsbG93T2JqZWN0XCIpO1xyXG4gICAgICAgIGRlcHJlY2F0ZWQoXCJvYnNlcnZhYmxlLnNoYWxsb3dPYmplY3RcIiwgXCJvYnNlcnZhYmxlLm9iamVjdCh2YWx1ZXMsIHt9LCB7IGRlZXA6IGZhbHNlIH0pXCIpO1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdChwcm9wcywge30sIHsgbmFtZTogbmFtZSwgZGVlcDogZmFsc2UgfSk7XHJcbiAgICB9LFxyXG4gICAgcmVmOiByZWZEZWNvcmF0b3IsXHJcbiAgICBzaGFsbG93OiBzaGFsbG93RGVjb3JhdG9yLFxyXG4gICAgZGVlcDogZGVlcERlY29yYXRvcixcclxuICAgIHN0cnVjdDogcmVmU3RydWN0RGVjb3JhdG9yXHJcbn07XHJcbnZhciBvYnNlcnZhYmxlID0gY3JlYXRlT2JzZXJ2YWJsZTtcclxuLy8gd2VpcmQgdHJpY2sgdG8ga2VlcCBvdXIgdHlwaW5ncyBuaWNlbHkgd2l0aCBvdXIgZnVuY3MsIGFuZCBzdGlsbCBleHRlbmQgdGhlIG9ic2VydmFibGUgZnVuY3Rpb25cclxuT2JqZWN0LmtleXMob2JzZXJ2YWJsZUZhY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKG9ic2VydmFibGVbbmFtZV0gPSBvYnNlcnZhYmxlRmFjdG9yaWVzW25hbWVdKTsgfSk7XHJcbmZ1bmN0aW9uIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKG1ldGhvZE5hbWUpIHtcclxuICAgIGZhaWwoXHJcbiAgICAvLyBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmXHJcbiAgICBcIkV4cGVjdGVkIG9uZSBvciB0d28gYXJndW1lbnRzIHRvIG9ic2VydmFibGUuXCIgKyBtZXRob2ROYW1lICsgXCIuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHRyeSB0byB1c2Ugb2JzZXJ2YWJsZS5cIiArIG1ldGhvZE5hbWUgKyBcIiBhcyBkZWNvcmF0b3I/XCIpO1xyXG59XG5cbnZhciBjb21wdXRlZERlY29yYXRvciA9IGNyZWF0ZVByb3BEZWNvcmF0b3IoZmFsc2UsIGZ1bmN0aW9uIChpbnN0YW5jZSwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLCBkZWNvcmF0b3JUYXJnZXQsIGRlY29yYXRvckFyZ3MpIHtcclxuICAgIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCwgc2V0ID0gZGVzY3JpcHRvci5zZXQ7IC8vIGluaXRpYWxWYWx1ZSBpcyB0aGUgZGVzY3JpcHRvciBmb3IgZ2V0IC8gc2V0IHByb3BzXHJcbiAgICAvLyBPcHRpbWl6YXRpb246IGZhc3RlciBvbiBkZWNvcmF0b3IgdGFyZ2V0IG9yIGluc3RhbmNlPyBBc3N1bWluZyB0YXJnZXRcclxuICAgIC8vIE9wdGltaXphdGlvbjogZmluZCBvdXQgaWYgZGVjbGFyaW5nIG9uIGluc3RhbmNlIGlzbid0IGp1c3QgZmFzdGVyLiAoYWxzbyBtYWtlcyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBzaW1wbGVyKS4gQnV0LCBtb3JlIG1lbW9yeSB1c2FnZS4uXHJcbiAgICAvLyBGb3JjaW5nIGluc3RhbmNlIG5vdywgZml4ZXMgaG90IHJlbG9hZGlnIGlzc3VlcyBvbiBSZWFjdCBOYXRpdmU6XHJcbiAgICB2YXIgb3B0aW9ucyA9IGRlY29yYXRvckFyZ3NbMF0gfHwge307XHJcbiAgICBkZWZpbmVDb21wdXRlZFByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eU5hbWUsIF9fYXNzaWduKHsgZ2V0OiBnZXQsIHNldDogc2V0IH0sIG9wdGlvbnMpKTtcclxufSk7XHJcbnZhciBjb21wdXRlZFN0cnVjdERlY29yYXRvciA9IGNvbXB1dGVkRGVjb3JhdG9yKHsgZXF1YWxzOiBjb21wYXJlci5zdHJ1Y3R1cmFsIH0pO1xyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBjbGFzcyBwcm9wZXJ0aWVzOiBAY29tcHV0ZWQgZ2V0IHZhbHVlKCkgeyByZXR1cm4gZXhwcjsgfS5cclxuICogRm9yIGxlZ2FjeSBwdXJwb3NlcyBhbHNvIGludm9rYWJsZSBhcyBFUzUgb2JzZXJ2YWJsZSBjcmVhdGVkOiBgY29tcHV0ZWQoKCkgPT4gZXhwcilgO1xyXG4gKi9cclxudmFyIGNvbXB1dGVkID0gZnVuY3Rpb24gY29tcHV0ZWQoYXJnMSwgYXJnMiwgYXJnMykge1xyXG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgLy8gQGNvbXB1dGVkXHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkRGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJnMSAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIiAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gQGNvbXB1dGVkKHsgb3B0aW9ucyB9KVxyXG4gICAgICAgIHJldHVybiBjb21wdXRlZERlY29yYXRvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgLy8gY29tcHV0ZWQoZXhwciwgb3B0aW9ucz8pXHJcbiAgICB7XHJcbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIsIFwiRmlyc3QgYXJndW1lbnQgdG8gYGNvbXB1dGVkYCBzaG91bGQgYmUgYW4gZXhwcmVzc2lvbi5cIik7XHJcbiAgICAgICAgaW52YXJpYW50KGFyZ3VtZW50cy5sZW5ndGggPCAzLCBcIkNvbXB1dGVkIHRha2VzIG9uZSBvciB0d28gYXJndW1lbnRzIGlmIHVzZWQgYXMgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICB2YXIgb3B0cyA9IHR5cGVvZiBhcmcyID09PSBcIm9iamVjdFwiID8gYXJnMiA6IHt9O1xyXG4gICAgb3B0cy5nZXQgPSBhcmcxO1xyXG4gICAgb3B0cy5zZXQgPSB0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiID8gYXJnMiA6IG9wdHMuc2V0O1xyXG4gICAgb3B0cy5uYW1lID0gb3B0cy5uYW1lIHx8IGFyZzEubmFtZSB8fCBcIlwiOyAvKiBmb3IgZ2VuZXJhdGVkIG5hbWUgKi9cclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRzKTtcclxufTtcclxuY29tcHV0ZWQuc3RydWN0ID0gY29tcHV0ZWRTdHJ1Y3REZWNvcmF0b3I7XG5cbihmdW5jdGlvbiAoSURlcml2YXRpb25TdGF0ZSkge1xyXG4gICAgLy8gYmVmb3JlIGJlaW5nIHJ1biBvciAob3V0c2lkZSBiYXRjaCBhbmQgbm90IGJlaW5nIG9ic2VydmVkKVxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCBkZXJpdmF0aW9uIGlzIG5vdCBob2xkaW5nIGFueSBkYXRhIGFib3V0IGRlcGVuZGVuY3kgdHJlZVxyXG4gICAgSURlcml2YXRpb25TdGF0ZVtJRGVyaXZhdGlvblN0YXRlW1wiTk9UX1RSQUNLSU5HXCJdID0gLTFdID0gXCJOT1RfVFJBQ0tJTkdcIjtcclxuICAgIC8vIG5vIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb25cclxuICAgIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cclxuICAgIC8vIHRoaXMgaXMgd2hhdCBtYWtlcyBtb2J4IGZhc3RcclxuICAgIElEZXJpdmF0aW9uU3RhdGVbSURlcml2YXRpb25TdGF0ZVtcIlVQX1RPX0RBVEVcIl0gPSAwXSA9IFwiVVBfVE9fREFURVwiO1xyXG4gICAgLy8gc29tZSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IGRvbid0IGtub3cgaWYgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWRcclxuICAgIC8vIHdpbGwgcmVxdWlyZSB0byBjaGVjayBmaXJzdCBpZiBVUF9UT19EQVRFIG9yIFBPU1NJQkxZX1NUQUxFXHJcbiAgICAvLyBjdXJyZW50bHkgb25seSBDb21wdXRlZFZhbHVlIHdpbGwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFXHJcbiAgICAvL1xyXG4gICAgLy8gaGF2aW5nIHRoaXMgc3RhdGUgaXMgc2Vjb25kIGJpZyBvcHRpbWl6YXRpb246XHJcbiAgICAvLyBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBvbiBldmVyeSBkZXBlbmRlbmN5IGNoYW5nZSwgYnV0IG9ubHkgd2hlbiBpdCdzIG5lZWRlZFxyXG4gICAgSURlcml2YXRpb25TdGF0ZVtJRGVyaXZhdGlvblN0YXRlW1wiUE9TU0lCTFlfU1RBTEVcIl0gPSAxXSA9IFwiUE9TU0lCTFlfU1RBTEVcIjtcclxuICAgIC8vIEEgc2hhbGxvdyBkZXBlbmRlbmN5IGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb24gYW5kIHRoZSBkZXJpdmF0aW9uXHJcbiAgICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cclxuICAgIElEZXJpdmF0aW9uU3RhdGVbSURlcml2YXRpb25TdGF0ZVtcIlNUQUxFXCJdID0gMl0gPSBcIlNUQUxFXCI7XHJcbn0pKGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZSB8fCAoZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlID0ge30pKTtcclxudmFyIFRyYWNlTW9kZTtcclxuKGZ1bmN0aW9uIChUcmFjZU1vZGUpIHtcclxuICAgIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcclxuICAgIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJMT0dcIl0gPSAxXSA9IFwiTE9HXCI7XHJcbiAgICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiQlJFQUtcIl0gPSAyXSA9IFwiQlJFQUtcIjtcclxufSkoVHJhY2VNb2RlIHx8IChUcmFjZU1vZGUgPSB7fSkpO1xyXG52YXIgQ2F1Z2h0RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XHJcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xyXG4gICAgICAgIC8vIEVtcHR5XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2F1Z2h0RXhjZXB0aW9uO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBpc0NhdWdodEV4Y2VwdGlvbihlKSB7XHJcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENhdWdodEV4Y2VwdGlvbjtcclxufVxyXG4vKipcclxuICogRmluZHMgb3V0IHdoZXRoZXIgYW55IGRlcGVuZGVuY3kgb2YgdGhlIGRlcml2YXRpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAqIElmIGRlcGVuZGVuY2llc1N0YXRlIGlzIDEgdGhlbiBpdCB3aWxsIHJlY2FsY3VsYXRlIGRlcGVuZGVuY2llcyxcclxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxyXG4gKlxyXG4gKiBCeSBpdGVyYXRpbmcgb3ZlciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlcG9ydGVkIGFuZFxyXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcclxuICogdGhhdCB3aWxsIGJlIHRyYWNrZWQgYnkgZGVyaXZhdGlvbi4gVGhhdCBpcyBiZWNhdXNlIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSBmaXJzdCB4XHJcbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZGVyaXZhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGVuIHRoZSBkZXJpdmF0aW9uIHNob3VsZCBydW4gdGhlIHNhbWUgd2F5XHJcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG91bGRDb21wdXRlKGRlcml2YXRpb24pIHtcclxuICAgIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEU6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkc6XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuU1RBTEU6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlBPU1NJQkxZX1NUQUxFOiB7XHJcbiAgICAgICAgICAgIC8vIHN0YXRlIHByb3BhZ2F0aW9uIGNhbiBvY2N1ciBvdXRzaWRlIG9mIGFjdGlvbi9yZWFjdGl2ZSBjb250ZXh0ICMyMTk1XHJcbiAgICAgICAgICAgIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBwcmV2VW50cmFja2VkID0gdW50cmFja2VkU3RhcnQoKTsgLy8gbm8gbmVlZCBmb3IgdGhvc2UgY29tcHV0ZWRzIHRvIGJlIHJlcG9ydGVkLCB0aGV5IHdpbGwgYmUgcGlja2VkIHVwIGluIHRyYWNrRGVyaXZlZEZ1bmN0aW9uLlxyXG4gICAgICAgICAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmcsIGwgPSBvYnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9ic1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5nZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiB0aGUgdmFsdWUgKm9yKiBleGNlcHRpb24gYXQgdGhpcyBtb21lbnQsIGJ1dCBpZiB0aGVyZSBpcyBvbmUsIG5vdGlmeSBhbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIENvbXB1dGVkVmFsdWUgYG9iamAgYWN0dWFsbHkgY2hhbmdlZCBpdCB3aWxsIGJlIGNvbXB1dGVkIGFuZCBwcm9wYWdhdGVkIHRvIGl0cyBvYnNlcnZlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGBkZXJpdmF0aW9uYCBpcyBhbiBvYnNlcnZlciBvZiBgb2JqYFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFyaWFudFNob3VsZENvbXB1dGUoZGVyaXZhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlNUQUxFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XHJcbiAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcclxuICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGZ1bmN0aW9uIGludmFyaWFudFNob3VsZENvbXB1dGUoZGVyaXZhdGlvbjogSURlcml2YXRpb24pIHtcclxuLy8gICAgIGNvbnN0IG5ld0RlcFN0YXRlID0gKGRlcml2YXRpb24gYXMgYW55KS5kZXBlbmRlbmNpZXNTdGF0ZVxyXG4vLyAgICAgaWYgKFxyXG4vLyAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiA9PT0gXCJwcm9kdWN0aW9uXCIgJiZcclxuLy8gICAgICAgICAobmV3RGVwU3RhdGUgPT09IElEZXJpdmF0aW9uU3RhdGUuUE9TU0lCTFlfU1RBTEUgfHxcclxuLy8gICAgICAgICAgICAgbmV3RGVwU3RhdGUgPT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HKVxyXG4vLyAgICAgKVxyXG4vLyAgICAgICAgIGZhaWwoXCJJbGxlZ2FsIGRlcGVuZGVuY3kgc3RhdGVcIilcclxuLy8gfVxyXG5mdW5jdGlvbiBpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSB7XHJcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICE9PSBudWxsOyAvLyBmaWx0ZXIgb3V0IGFjdGlvbnMgaW5zaWRlIGNvbXB1dGF0aW9uc1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKGF0b20pIHtcclxuICAgIHZhciBoYXNPYnNlcnZlcnMgPSBhdG9tLm9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgLy8gU2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIGNoYW5nZSBhbiBvYnNlcnZlZCBvYnNlcnZhYmxlIGZyb20gaW5zaWRlIGNvbXB1dGVkLCBzZWUgIzc5OFxyXG4gICAgaWYgKGdsb2JhbFN0YXRlLmNvbXB1dGF0aW9uRGVwdGggPiAwICYmIGhhc09ic2VydmVycylcclxuICAgICAgICBmYWlsKFwiQ29tcHV0ZWQgdmFsdWVzIGFyZSBub3QgYWxsb3dlZCB0byBjYXVzZSBzaWRlIGVmZmVjdHMgYnkgY2hhbmdpbmcgb2JzZXJ2YWJsZXMgdGhhdCBhcmUgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIiArIGF0b20ubmFtZSk7XHJcbiAgICAvLyBTaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIGNoYW5nZSBvYnNlcnZlZCBzdGF0ZSBvdXRzaWRlIHN0cmljdCBtb2RlLCBleGNlcHQgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBzZWUgIzU2M1xyXG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyAmJiAoaGFzT2JzZXJ2ZXJzIHx8IGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID09PSBcInN0cmljdFwiKSlcclxuICAgICAgICBmYWlsKChnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgPyBcIlNpbmNlIHN0cmljdC1tb2RlIGlzIGVuYWJsZWQsIGNoYW5naW5nIG9ic2VydmVkIG9ic2VydmFibGUgdmFsdWVzIG91dHNpZGUgYWN0aW9ucyBpcyBub3QgYWxsb3dlZC4gUGxlYXNlIHdyYXAgdGhlIGNvZGUgaW4gYW4gYGFjdGlvbmAgaWYgdGhpcyBjaGFuZ2UgaXMgaW50ZW5kZWQuIFRyaWVkIHRvIG1vZGlmeTogXCJcclxuICAgICAgICAgICAgICAgIDogXCJTaWRlIGVmZmVjdHMgbGlrZSBjaGFuZ2luZyBzdGF0ZSBhcmUgbm90IGFsbG93ZWQgYXQgdGhpcyBwb2ludC4gQXJlIHlvdSB0cnlpbmcgdG8gbW9kaWZ5IHN0YXRlIGZyb20sIGZvciBleGFtcGxlLCB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50PyBUcmllZCB0byBtb2RpZnk6IFwiKSArXHJcbiAgICAgICAgICAgICAgICBhdG9tLm5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZChvYnNlcnZhYmxlKSB7XHJcbiAgICBpZiAoIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyAmJlxyXG4gICAgICAgIGdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIE9ic2VydmFibGUgXCIgKyBvYnNlcnZhYmxlLm5hbWUgKyBcIiBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0XCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gYGZgIGFuZCB0cmFja3Mgd2hpY2ggb2JzZXJ2YWJsZXMgYXJlIGJlaW5nIGFjY2Vzc2VkLlxyXG4gKiBUaGUgdHJhY2tpbmcgaW5mb3JtYXRpb24gaXMgc3RvcmVkIG9uIHRoZSBgZGVyaXZhdGlvbmAgb2JqZWN0IGFuZCB0aGUgZGVyaXZhdGlvbiBpcyByZWdpc3RlcmVkXHJcbiAqIGFzIG9ic2VydmVyIG9mIGFueSBvZiB0aGUgYWNjZXNzZWQgb2JzZXJ2YWJsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFja0Rlcml2ZWRGdW5jdGlvbihkZXJpdmF0aW9uLCBmLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xyXG4gICAgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xyXG4gICAgLy8gYXJyYXkgd2lsbCBiZSB0cmltbWVkIGJ5IGJpbmREZXBlbmRlbmNpZXNcclxuICAgIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xyXG4gICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmcgPSBuZXcgQXJyYXkoZGVyaXZhdGlvbi5vYnNlcnZpbmcubGVuZ3RoICsgMTAwKTtcclxuICAgIGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudCA9IDA7XHJcbiAgICBkZXJpdmF0aW9uLnJ1bklkID0gKytnbG9iYWxTdGF0ZS5ydW5JZDtcclxuICAgIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XHJcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBkZXJpdmF0aW9uO1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXZUcmFja2luZztcclxuICAgIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XHJcbiAgICBpZiAoZGVyaXZhdGlvbi5vYnNlcnZpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XHJcbiAgICB9XHJcbiAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcclxuICAgIGlmIChnbG9iYWxTdGF0ZS5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSB8fCBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBEZXJpdmF0aW9uIFwiICsgZGVyaXZhdGlvbi5uYW1lICsgXCIgaXMgY3JlYXRlZC91cGRhdGVkIHdpdGhvdXQgcmVhZGluZyBhbnkgb2JzZXJ2YWJsZSB2YWx1ZVwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxyXG4gKiB1cGRhdGUgb2JzZXJ2aW5nIHRvIGJlIG5ld09ic2VydmluZyB3aXRoIHVuaXF1ZSBvYnNlcnZhYmxlc1xyXG4gKiBub3RpZnkgb2JzZXJ2ZXJzIHRoYXQgYmVjb21lIG9ic2VydmVkL3Vub2JzZXJ2ZWRcclxuICovXHJcbmZ1bmN0aW9uIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbikge1xyXG4gICAgLy8gaW52YXJpYW50KGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HLCBcIklOVEVSTkFMIEVSUk9SIGJpbmREZXBlbmRlbmNpZXMgZXhwZWN0cyBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcclxuICAgIHZhciBwcmV2T2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmc7XHJcbiAgICB2YXIgb2JzZXJ2aW5nID0gKGRlcml2YXRpb24ub2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmcpO1xyXG4gICAgdmFyIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFO1xyXG4gICAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6ICh0aGlzIGxpc3QgY2FuIGNvbnRhaW4gZHVwbGljYXRlcyk6XHJcbiAgICAvLyAgIDA6IGZpcnN0IG9jY3VycmVuY2UsIGNoYW5nZSB0byAxIGFuZCBrZWVwIGl0XHJcbiAgICAvLyAgIDE6IGV4dHJhIG9jY3VycmVuY2UsIGRyb3AgaXRcclxuICAgIHZhciBpMCA9IDAsIGwgPSBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnQ7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaV07XHJcbiAgICAgICAgaWYgKGRlcC5kaWZmVmFsdWUgPT09IDApIHtcclxuICAgICAgICAgICAgZGVwLmRpZmZWYWx1ZSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChpMCAhPT0gaSlcclxuICAgICAgICAgICAgICAgIG9ic2VydmluZ1tpMF0gPSBkZXA7XHJcbiAgICAgICAgICAgIGkwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwY2FzdCBpcyAnc2FmZScgaGVyZSwgYmVjYXVzZSBpZiBkZXAgaXMgSU9ic2VydmFibGUsIGBkZXBlbmRlbmNpZXNTdGF0ZWAgd2lsbCBiZSB1bmRlZmluZWQsXHJcbiAgICAgICAgLy8gbm90IGhpdHRpbmcgdGhlIGNvbmRpdGlvblxyXG4gICAgICAgIGlmIChkZXAuZGVwZW5kZW5jaWVzU3RhdGUgPiBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUpIHtcclxuICAgICAgICAgICAgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gZGVwLmRlcGVuZGVuY2llc1N0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic2VydmluZy5sZW5ndGggPSBpMDtcclxuICAgIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nID0gbnVsbDsgLy8gbmV3T2JzZXJ2aW5nIHNob3VsZG4ndCBiZSBuZWVkZWQgb3V0c2lkZSB0cmFja2luZyAoc3RhdGVtZW50IG1vdmVkIGRvd24gdG8gd29yayBhcm91bmQgRkYgYnVnLCBzZWUgIzYxNClcclxuICAgIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAoaXQgaXMgdW5pcXVlIGFmdGVyIGxhc3QgYmluZERlcGVuZGVuY2llcylcclxuICAgIC8vICAgMDogaXQncyBub3QgaW4gbmV3IG9ic2VydmFibGVzLCB1bm9ic2VydmUgaXRcclxuICAgIC8vICAgMTogaXQga2VlcHMgYmVpbmcgb2JzZXJ2ZWQsIGRvbid0IHdhbnQgdG8gbm90aWZ5IGl0LiBjaGFuZ2UgdG8gMFxyXG4gICAgbCA9IHByZXZPYnNlcnZpbmcubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgIHZhciBkZXAgPSBwcmV2T2JzZXJ2aW5nW2xdO1xyXG4gICAgICAgIGlmIChkZXAuZGlmZlZhbHVlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZU9ic2VydmVyKGRlcCwgZGVyaXZhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcC5kaWZmVmFsdWUgPSAwO1xyXG4gICAgfVxyXG4gICAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChub3cgaXQgc2hvdWxkIGJlIHVuaXF1ZSlcclxuICAgIC8vICAgMDogaXQgd2FzIHNldCB0byAwIGluIGxhc3QgbG9vcC4gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgIC8vICAgMTogaXQgd2Fzbid0IG9ic2VydmVkLCBsZXQncyBvYnNlcnZlIGl0LiBzZXQgYmFjayB0byAwXHJcbiAgICB3aGlsZSAoaTAtLSkge1xyXG4gICAgICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaTBdO1xyXG4gICAgICAgIGlmIChkZXAuZGlmZlZhbHVlID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRlcC5kaWZmVmFsdWUgPSAwO1xyXG4gICAgICAgICAgICBhZGRPYnNlcnZlcihkZXAsIGRlcml2YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFNvbWUgbmV3IG9ic2VydmVkIGRlcml2YXRpb25zIG1heSBiZWNvbWUgc3RhbGUgZHVyaW5nIHRoaXMgZGVyaXZhdGlvbiBjb21wdXRhdGlvblxyXG4gICAgLy8gc28gdGhleSBoYXZlIGhhZCBubyBjaGFuY2UgdG8gcHJvcGFnYXRlIHN0YWxlbmVzcyAoIzkxNilcclxuICAgIGlmIChsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgIT09IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFKSB7XHJcbiAgICAgICAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSA9IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZTtcclxuICAgICAgICBkZXJpdmF0aW9uLm9uQmVjb21lU3RhbGUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbGVhck9ic2VydmluZyhkZXJpdmF0aW9uKSB7XHJcbiAgICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IgY2xlYXJPYnNlcnZpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcclxuICAgIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZztcclxuICAgIGRlcml2YXRpb24ub2JzZXJ2aW5nID0gW107XHJcbiAgICB2YXIgaSA9IG9icy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgIHJlbW92ZU9ic2VydmVyKG9ic1tpXSwgZGVyaXZhdGlvbik7XHJcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORztcclxufVxyXG5mdW5jdGlvbiB1bnRyYWNrZWQoYWN0aW9uKSB7XHJcbiAgICB2YXIgcHJldiA9IHVudHJhY2tlZFN0YXJ0KCk7XHJcbiAgICB2YXIgcmVzID0gYWN0aW9uKCk7XHJcbiAgICB1bnRyYWNrZWRFbmQocHJldik7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHVudHJhY2tlZFN0YXJ0KCkge1xyXG4gICAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XHJcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xyXG4gICAgcmV0dXJuIHByZXY7XHJcbn1cclxuZnVuY3Rpb24gdW50cmFja2VkRW5kKHByZXYpIHtcclxuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXY7XHJcbn1cclxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzU3RhcnQoYWxsb3dTdGF0ZVJlYWRzKSB7XHJcbiAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcztcclxuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkcztcclxuICAgIHJldHVybiBwcmV2O1xyXG59XHJcbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2KSB7XHJcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBwcmV2O1xyXG59XHJcbi8qKlxyXG4gKiBuZWVkZWQgdG8ga2VlcCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWAgY29ycmVjdC4gd2hlbiBjaGFuZ2luZyBmcm9tICgyIG9yIDEpIHRvIDBcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pIHtcclxuICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID09PSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEU7XHJcbiAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmc7XHJcbiAgICB2YXIgaSA9IG9icy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgIG9ic1tpXS5sb3dlc3RPYnNlcnZlclN0YXRlID0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEU7XHJcbn1cblxuLy8gd2UgZG9uJ3QgdXNlIGdsb2JhbFN0YXRlIGZvciB0aGVzZSBpbiBvcmRlciB0byBhdm9pZCBwb3NzaWJsZSBpc3N1ZXMgd2l0aCBtdWx0aXBsZVxyXG4vLyBtb2J4IHZlcnNpb25zXHJcbnZhciBjdXJyZW50QWN0aW9uSWQgPSAwO1xyXG52YXIgbmV4dEFjdGlvbklkID0gMTtcclxudmFyIGZ1bmN0aW9uTmFtZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHsgfSwgXCJuYW1lXCIpO1xyXG52YXIgaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUgPSBmdW5jdGlvbk5hbWVEZXNjcmlwdG9yICYmIGZ1bmN0aW9uTmFtZURlc2NyaXB0b3IuY29uZmlndXJhYmxlO1xyXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24oYWN0aW9uTmFtZSwgZm4pIHtcclxuICAgIHtcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIsIFwiYGFjdGlvbmAgY2FuIG9ubHkgYmUgaW52b2tlZCBvbiBmdW5jdGlvbnNcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25OYW1lICE9PSBcInN0cmluZ1wiIHx8ICFhY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICBmYWlsKFwiYWN0aW9ucyBzaG91bGQgaGF2ZSB2YWxpZCBuYW1lcywgZ290OiAnXCIgKyBhY3Rpb25OYW1lICsgXCInXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXMsIFwibmFtZVwiLCB7IHZhbHVlOiBhY3Rpb25OYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBzY29wZSwgYXJncykge1xyXG4gICAgdmFyIHJ1bkluZm8gPSBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgc2NvcGUsIGFyZ3MpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJ1bkluZm8uZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgX2VuZEFjdGlvbihydW5JbmZvKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgc2NvcGUsIGFyZ3MpIHtcclxuICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKSAmJiAhIWFjdGlvbk5hbWU7XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gMDtcclxuICAgIGlmIChub3RpZnlTcHkpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHZhciBsID0gKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgdmFyIGZsYXR0ZW5kQXJncyA9IG5ldyBBcnJheShsKTtcclxuICAgICAgICBpZiAobCA+IDApXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZmxhdHRlbmRBcmdzW2ldID0gYXJnc1tpXTtcclxuICAgICAgICBzcHlSZXBvcnRTdGFydCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYWN0aW9uXCIsXHJcbiAgICAgICAgICAgIG5hbWU6IGFjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgIG9iamVjdDogc2NvcGUsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50czogZmxhdHRlbmRBcmdzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJldkRlcml2YXRpb24gPSB1bnRyYWNrZWRTdGFydCgpO1xyXG4gICAgc3RhcnRCYXRjaCgpO1xyXG4gICAgdmFyIHByZXZBbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XHJcbiAgICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xyXG4gICAgdmFyIHJ1bkluZm8gPSB7XHJcbiAgICAgICAgcHJldkRlcml2YXRpb246IHByZXZEZXJpdmF0aW9uLFxyXG4gICAgICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlczogcHJldkFsbG93U3RhdGVDaGFuZ2VzLFxyXG4gICAgICAgIHByZXZBbGxvd1N0YXRlUmVhZHM6IHByZXZBbGxvd1N0YXRlUmVhZHMsXHJcbiAgICAgICAgbm90aWZ5U3B5OiBub3RpZnlTcHksXHJcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXHJcbiAgICAgICAgYWN0aW9uSWQ6IG5leHRBY3Rpb25JZCsrLFxyXG4gICAgICAgIHBhcmVudEFjdGlvbklkOiBjdXJyZW50QWN0aW9uSWRcclxuICAgIH07XHJcbiAgICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLmFjdGlvbklkO1xyXG4gICAgcmV0dXJuIHJ1bkluZm87XHJcbn1cclxuZnVuY3Rpb24gX2VuZEFjdGlvbihydW5JbmZvKSB7XHJcbiAgICBpZiAoY3VycmVudEFjdGlvbklkICE9PSBydW5JbmZvLmFjdGlvbklkKSB7XHJcbiAgICAgICAgZmFpbChcImludmFsaWQgYWN0aW9uIHN0YWNrLiBkaWQgeW91IGZvcmdldCB0byBmaW5pc2ggYW4gYWN0aW9uP1wiKTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8ucGFyZW50QWN0aW9uSWQ7XHJcbiAgICBpZiAocnVuSW5mby5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlQ2hhbmdlcyk7XHJcbiAgICBhbGxvd1N0YXRlUmVhZHNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZVJlYWRzKTtcclxuICAgIGVuZEJhdGNoKCk7XHJcbiAgICB1bnRyYWNrZWRFbmQocnVuSW5mby5wcmV2RGVyaXZhdGlvbik7XHJcbiAgICBpZiAocnVuSW5mby5ub3RpZnlTcHkpIHtcclxuICAgICAgICBzcHlSZXBvcnRFbmQoeyB0aW1lOiBEYXRlLm5vdygpIC0gcnVuSW5mby5zdGFydFRpbWUgfSk7XHJcbiAgICB9XHJcbiAgICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXMoYWxsb3dTdGF0ZUNoYW5nZXMsIGZ1bmMpIHtcclxuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcyk7XHJcbiAgICB2YXIgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBmdW5jKCk7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcykge1xyXG4gICAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcztcclxuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XHJcbiAgICByZXR1cm4gcHJldjtcclxufVxyXG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KSB7XHJcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IHByZXY7XHJcbn1cclxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZChmdW5jKSB7XHJcbiAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmNvbXB1dGF0aW9uRGVwdGg7XHJcbiAgICBnbG9iYWxTdGF0ZS5jb21wdXRhdGlvbkRlcHRoID0gMDtcclxuICAgIHZhciByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGZ1bmMoKTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGdsb2JhbFN0YXRlLmNvbXB1dGF0aW9uRGVwdGggPSBwcmV2O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxuXG52YXIgT2JzZXJ2YWJsZVZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9ic2VydmFibGVWYWx1ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIG5hbWUsIG5vdGlmeVNweSwgZXF1YWxzKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlVmFsdWVAXCIgKyBnZXROZXh0SWQoKTsgfVxyXG4gICAgICAgIGlmIChub3RpZnlTcHkgPT09IHZvaWQgMCkgeyBub3RpZnlTcHkgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGVxdWFscyA9PT0gdm9pZCAwKSB7IGVxdWFscyA9IGNvbXBhcmVyLmRlZmF1bHQ7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVuaGFuY2VyID0gZW5oYW5jZXI7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMuZXF1YWxzID0gZXF1YWxzO1xyXG4gICAgICAgIF90aGlzLmhhc1VucmVwb3J0ZWRDaGFuZ2UgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy52YWx1ZSA9IGVuaGFuY2VyKHZhbHVlLCB1bmRlZmluZWQsIG5hbWUpO1xyXG4gICAgICAgIGlmIChub3RpZnlTcHkgJiYgaXNTcHlFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgICAgIHNweVJlcG9ydCh7IHR5cGU6IFwiY3JlYXRlXCIsIG5hbWU6IF90aGlzLm5hbWUsIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5KSB7XHJcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRTdGFydCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5wcmVwYXJlTmV3VmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcclxuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwbHkgbW9kaWZpZXJcclxuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWUsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKHRoaXMudmFsdWUsIG5ld1ZhbHVlKSA/IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCA6IG5ld1ZhbHVlO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB0aGlzLnJlcG9ydENoYW5nZWQoKTtcclxuICAgICAgICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlcG9ydE9ic2VydmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpXHJcbiAgICAgICAgICAgIGxpc3RlbmVyKHtcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiW1wiICsgdGhpcy52YWx1ZSArIFwiXVwiO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGVWYWx1ZTtcclxufShBdG9tKSk7XHJcbk9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGVbcHJpbWl0aXZlU3ltYm9sKCldID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS52YWx1ZU9mO1xyXG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVZhbHVlXCIsIE9ic2VydmFibGVWYWx1ZSk7XG5cbi8qKlxyXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cclxuICpcclxuICogQ29tcHV0ZWRWYWx1ZSB3aWxsIHJlbWVtYmVyIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGJhdGNoLCBvclxyXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cclxuICpcclxuICogRHVyaW5nIHRoaXMgdGltZSBpdCB3aWxsIHJlY29tcHV0ZSBvbmx5IHdoZW4gb25lIG9mIGl0cyBkaXJlY3QgZGVwZW5kZW5jaWVzIGNoYW5nZWQsXHJcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9uIGRlc2NyaXB0aW9uOlxyXG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcclxuICogICAgZ2l2ZSBiYWNrIHJlbWVtYmVyZWQgcmVzdWx0IHVudGlsIDIuIGhhcHBlbnNcclxuICogMi4gRmlyc3QgdGltZSBhbnkgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZSwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHdhaXQgZm9yIDMuXHJcbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cclxuICogICAgaWYgcmVzdWx0IGNoYW5nZWQ6IHByb3BhZ2F0ZSBTVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB0aGF0IHdlcmUgUE9TU0lCTFlfU1RBTEUgZnJvbSB0aGUgbGFzdCBzdGVwLlxyXG4gKiAgICBnbyB0byBzdGVwIDIuIGVpdGhlciB3YXlcclxuICpcclxuICogSWYgYXQgYW55IHBvaW50IGl0J3Mgb3V0c2lkZSBiYXRjaCBhbmQgaXQgaXNuJ3Qgb2JzZXJ2ZWQ6IHJlc2V0IGV2ZXJ5dGhpbmcgYW5kIGdvIHRvIDEuXHJcbiAqL1xyXG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXB1dGVkIHZhbHVlIGJhc2VkIG9uIGEgZnVuY3Rpb24gZXhwcmVzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGZvciBkZWJ1ZyBwdXJwb3NlcyBvbmx5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxyXG4gICAgICogdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyB2YWx1ZS4gVHdvIGNvbXBhcmVycyBhcmUgcHJvdmlkZWQgaW4gdGhlIGxpYnJhcnk7IGBkZWZhdWx0Q29tcGFyZXJgXHJcbiAgICAgKiBjb21wYXJlcyBiYXNlZCBvbiBpZGVudGl0eSBjb21wYXJpc29uICg9PT0pLCBhbmQgYHN0cnVjdHVhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cclxuICAgICAqIFN0cnVjdHVyYWwgY29tcGFyaXNvbiBjYW4gYmUgY29udmVuaWVudCBpZiB5b3UgYWx3YXlzIHByb2R1Y2UgYSBuZXcgYWdncmVnYXRlZCBvYmplY3QgYW5kXHJcbiAgICAgKiBkb24ndCB3YW50IHRvIG5vdGlmeSBvYnNlcnZlcnMgaWYgaXQgaXMgc3RydWN0dXJhbGx5IHRoZSBzYW1lLlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGUgPSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2aW5nID0gW107IC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xyXG4gICAgICAgIHRoaXMubmV3T2JzZXJ2aW5nID0gbnVsbDsgLy8gZHVyaW5nIHRyYWNraW5nIGl0J3MgYW4gYXJyYXkgd2l0aCBuZXcgb2JzZXJ2ZWQgb2JzZXJ2ZXJzXHJcbiAgICAgICAgdGhpcy5pc0JlaW5nT2JzZXJ2ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzSW5kZXhlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGlmZlZhbHVlID0gMDtcclxuICAgICAgICB0aGlzLnJ1bklkID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RBY2Nlc3NlZEJ5ID0gMDtcclxuICAgICAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURTtcclxuICAgICAgICB0aGlzLnVuYm91bmREZXBzQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX19tYXBpZCA9IFwiI1wiICsgZ2V0TmV4dElkKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XHJcbiAgICAgICAgdGhpcy5pc0NvbXB1dGluZyA9IGZhbHNlOyAvLyB0byBjaGVjayBmb3IgY3ljbGVzXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVHJhY2luZyA9IFRyYWNlTW9kZS5OT05FO1xyXG4gICAgICAgIGludmFyaWFudChvcHRpb25zLmdldCwgXCJtaXNzaW5nIG9wdGlvbiBmb3IgY29tcHV0ZWQ6IGdldFwiKTtcclxuICAgICAgICB0aGlzLmRlcml2YXRpb24gPSBvcHRpb25zLmdldDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgXCJDb21wdXRlZFZhbHVlQFwiICsgZ2V0TmV4dElkKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2V0KVxyXG4gICAgICAgICAgICB0aGlzLnNldHRlciA9IGNyZWF0ZUFjdGlvbih0aGlzLm5hbWUgKyBcIi1zZXR0ZXJcIiwgb3B0aW9ucy5zZXQpO1xyXG4gICAgICAgIHRoaXMuZXF1YWxzID1cclxuICAgICAgICAgICAgb3B0aW9ucy5lcXVhbHMgfHxcclxuICAgICAgICAgICAgICAgIChvcHRpb25zLmNvbXBhcmVTdHJ1Y3R1cmFsIHx8IG9wdGlvbnMuc3RydWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wYXJlci5zdHJ1Y3R1cmFsXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjb21wYXJlci5kZWZhdWx0KTtcclxuICAgICAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5jb250ZXh0O1xyXG4gICAgICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbiA9ICEhb3B0aW9ucy5yZXF1aXJlc1JlYWN0aW9uO1xyXG4gICAgICAgIHRoaXMua2VlcEFsaXZlID0gISFvcHRpb25zLmtlZXBBbGl2ZTtcclxuICAgIH1cclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLm9uQmVjb21lU3RhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLm9uQmVjb21lVW5vYnNlcnZlZCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLm9uQmVjb21lT2JzZXJ2ZWQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cclxuICAgICAqIFdpbGwgZXZhbHVhdGUgaXRzIGNvbXB1dGF0aW9uIGZpcnN0IGlmIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcHV0aW5nKVxyXG4gICAgICAgICAgICBmYWlsKFwiQ3ljbGUgZGV0ZWN0ZWQgaW4gY29tcHV0YXRpb24gXCIgKyB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLmRlcml2YXRpb24pO1xyXG4gICAgICAgIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwICYmIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5rZWVwQWxpdmUpIHtcclxuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybkFib3V0VW50cmFja2VkUmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRCYXRjaCgpOyAvLyBTZWUgcGVyZiB0ZXN0ICdjb21wdXRlZCBtZW1vaXphdGlvbidcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBlbmRCYXRjaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXBvcnRPYnNlcnZlZCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0FuZENvbXB1dGUoKSlcclxuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKVxyXG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuY2F1c2U7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNvbXB1dGVWYWx1ZShmYWxzZSk7XHJcbiAgICAgICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlcykpXHJcbiAgICAgICAgICAgIHRocm93IHJlcy5jYXVzZTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNldHRlcikge1xyXG4gICAgICAgICAgICBpbnZhcmlhbnQoIXRoaXMuaXNSdW5uaW5nU2V0dGVyLCBcIlRoZSBzZXR0ZXIgb2YgY29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lICsgXCInIGlzIHRyeWluZyB0byB1cGRhdGUgaXRzZWxmLiBEaWQgeW91IGludGVuZCB0byB1cGRhdGUgYW4gX29ic2VydmFibGVfIHZhbHVlLCBpbnN0ZWFkIG9mIHRoZSBjb21wdXRlZCBwcm9wZXJ0eT9cIik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyLmNhbGwodGhpcy5zY29wZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyB0aGlzLm5hbWUgKyBcIiddIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBhc3NpZ24gYSBuZXcgdmFsdWUgdG8gYSBjb21wdXRlZCB2YWx1ZS5cIik7XHJcbiAgICB9O1xyXG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUudHJhY2tBbmRDb21wdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChpc1NweUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICBzcHlSZXBvcnQoe1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLnNjb3BlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21wdXRlXCIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgdmFyIHdhc1N1c3BlbmRlZCA9IFxyXG4gICAgICAgIC8qIHNlZSAjMTIwOCAqLyB0aGlzLmRlcGVuZGVuY2llc1N0YXRlID09PSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HO1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlKHRydWUpO1xyXG4gICAgICAgIHZhciBjaGFuZ2VkID0gd2FzU3VzcGVuZGVkIHx8XHJcbiAgICAgICAgICAgIGlzQ2F1Z2h0RXhjZXB0aW9uKG9sZFZhbHVlKSB8fFxyXG4gICAgICAgICAgICBpc0NhdWdodEV4Y2VwdGlvbihuZXdWYWx1ZSkgfHxcclxuICAgICAgICAgICAgIXRoaXMuZXF1YWxzKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcclxuICAgIH07XHJcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5jb21wdXRlVmFsdWUgPSBmdW5jdGlvbiAodHJhY2spIHtcclxuICAgICAgICB0aGlzLmlzQ29tcHV0aW5nID0gdHJ1ZTtcclxuICAgICAgICBnbG9iYWxTdGF0ZS5jb21wdXRhdGlvbkRlcHRoKys7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBpZiAodHJhY2spIHtcclxuICAgICAgICAgICAgcmVzID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgdGhpcy5kZXJpdmF0aW9uLCB0aGlzLnNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5zY29wZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuY29tcHV0YXRpb25EZXB0aC0tO1xyXG4gICAgICAgIHRoaXMuaXNDb21wdXRpbmcgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLnN1c3BlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDsgLy8gZG9uJ3QgaG9sZCBvbiB0byBjb21wdXRlZCB2YWx1ZSFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcHJldlZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBhdXRvcnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmICghZmlyc3RUaW1lIHx8IGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogX3RoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcHJldlZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUud2FybkFib3V0VW50cmFja2VkUmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1JlYWN0aW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZhaWwoXCJbbW9ieF0gQ29tcHV0ZWQgdmFsdWUgXCIgKyB0aGlzLm5hbWUgKyBcIiBpcyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1RyYWNpbmcgIT09IFRyYWNlTW9kZS5OT05FKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIHRoaXMubmFtZSArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBDb21wdXRlZCB2YWx1ZSBcIiArIHRoaXMubmFtZSArIFwiIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoKTtcclxuICAgIH07XHJcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCJbXCIgKyB0aGlzLmRlcml2YXRpb24udG9TdHJpbmcoKSArIFwiXVwiO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wdXRlZFZhbHVlO1xyXG59KCkpO1xyXG5Db21wdXRlZFZhbHVlLnByb3RvdHlwZVtwcmltaXRpdmVTeW1ib2woKV0gPSBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS52YWx1ZU9mO1xyXG52YXIgaXNDb21wdXRlZFZhbHVlID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkNvbXB1dGVkVmFsdWVcIiwgQ29tcHV0ZWRWYWx1ZSk7XG5cbi8qKlxyXG4gKiBUaGVzZSB2YWx1ZXMgd2lsbCBwZXJzaXN0IGlmIGdsb2JhbCBzdGF0ZSBpcyByZXNldFxyXG4gKi9cclxudmFyIHBlcnNpc3RlbnRLZXlzID0gW1xyXG4gICAgXCJtb2J4R3VpZFwiLFxyXG4gICAgXCJzcHlMaXN0ZW5lcnNcIixcclxuICAgIFwiZW5mb3JjZUFjdGlvbnNcIixcclxuICAgIFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsXHJcbiAgICBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsXHJcbiAgICBcIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uXCIsXHJcbiAgICBcImFsbG93U3RhdGVSZWFkc1wiLFxyXG4gICAgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsXHJcbiAgICBcInJ1bklkXCIsXHJcbiAgICBcIlVOQ0hBTkdFRFwiXHJcbl07XHJcbnZhciBNb2JYR2xvYmFscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vYlhHbG9iYWxzKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1vYlhHbG9iYWxzIHZlcnNpb24uXHJcbiAgICAgICAgICogTW9iWCBjb21wYXRpYmxpdHkgd2l0aCBvdGhlciB2ZXJzaW9ucyBsb2FkZWQgaW4gbWVtb3J5IGFzIGxvbmcgYXMgdGhpcyB2ZXJzaW9uIG1hdGNoZXMuXHJcbiAgICAgICAgICogSXQgaW5kaWNhdGVzIHRoYXQgdGhlIGdsb2JhbCBzdGF0ZSBzdGlsbCBzdG9yZXMgc2ltaWxhciBpbmZvcm1hdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTi5COiB0aGlzIHZlcnNpb24gaXMgdW5yZWxhdGVkIHRvIHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgTW9iWCwgYW5kIGlzIG9ubHkgdGhlIHZlcnNpb24gb2YgdGhlXHJcbiAgICAgICAgICogaW50ZXJuYWwgc3RhdGUgc3RvcmFnZSBvZiBNb2JYLCBhbmQgY2FuIGJlIHRoZSBzYW1lIGFjcm9zcyBtYW55IGRpZmZlcmVudCBwYWNrYWdlIHZlcnNpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnbG9iYWxseSB1bmlxdWUgdG9rZW4gdG8gc2lnbmFsIHVuY2hhbmdlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuVU5DSEFOR0VEID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudGx5IHJ1bm5pbmcgZGVyaXZhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcmUgd2UgcnVubmluZyBhIGNvbXB1dGF0aW9uIGN1cnJlbnRseT8gKG5vdCBhIHJlYWN0aW9uKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcHV0YXRpb25EZXB0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRWFjaCB0aW1lIGEgZGVyaXZhdGlvbiBpcyB0cmFja2VkLCBpdCBpcyBhc3NpZ25lZCBhIHVuaXF1ZSBydW4taWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJ1bklkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAnZ3VpZCcgZm9yIGdlbmVyYWwgcHVycG9zZS4gV2lsbCBiZSBwZXJzaXN0ZWQgYW1vbmdzdCByZXNldHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tb2J4R3VpZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJlIHdlIGluIGEgYmF0Y2ggYmxvY2s/IChhbmQgaG93IG1hbnkgb2YgdGhlbSlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluQmF0Y2ggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9ic2VydmFibGVzIHRoYXQgZG9uJ3QgaGF2ZSBvYnNlcnZlcnMgYW55bW9yZSwgYW5kIGFyZSBhYm91dCB0byBiZVxyXG4gICAgICAgICAqIHN1c3BlbmRlZCwgdW5sZXNzIHNvbWVib2R5IGVsc2UgYWNjZXNzZXMgaXQgaW4gdGhlIHNhbWUgYmF0Y2hcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJT2JzZXJ2YWJsZVtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBzY2hlZHVsZWQsIG5vdCB5ZXQgZXhlY3V0ZWQsIHJlYWN0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdSZWFjdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcmUgd2UgY3VycmVudGx5IHByb2Nlc3NpbmcgcmVhY3Rpb25zP1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXMgaXQgYWxsb3dlZCB0byBjaGFuZ2Ugb2JzZXJ2YWJsZXMgYXQgdGhpcyBwb2ludD9cclxuICAgICAgICAgKiBJbiBnZW5lcmFsLCBNb2JYIGRvZXNuJ3QgYWxsb3cgdGhhdCB3aGVuIHJ1bm5pbmcgY29tcHV0YXRpb25zIGFuZCBSZWFjdC5yZW5kZXIuXHJcbiAgICAgICAgICogVG8gZW5zdXJlIHRoYXQgdGhvc2UgZnVuY3Rpb25zIHN0YXkgcHVyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFsbG93U3RhdGVDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJcyBpdCBhbGxvd2VkIHRvIHJlYWQgb2JzZXJ2YWJsZXMgYXQgdGhpcyBwb2ludD9cclxuICAgICAgICAgKiBVc2VkIHRvIGhvbGQgdGhlIHN0YXRlIG5lZWRlZCBmb3IgYG9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxsb3dTdGF0ZVJlYWRzID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkLCBzdGF0ZSBjaGFuZ2VzIGFyZSBieSBkZWZhdWx0IG5vdCBhbGxvd2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmZvcmNlQWN0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNweSBjYWxsYmFja3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNweUxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdsb2JhbGx5IGF0dGFjaGVkIGVycm9yIGhhbmRsZXJzIHRoYXQgcmVhY3Qgc3BlY2lmaWNhbGx5IHRvIGVycm9ycyBpbiByZWFjdGlvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdhcm4gaWYgY29tcHV0ZWQgdmFsdWVzIGFyZSBhY2Nlc3NlZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogKEV4cGVyaW1lbnRhbClcclxuICAgICAgICAgKiBXYXJuIGlmIHlvdSB0cnkgdG8gY3JlYXRlIHRvIGRlcml2YXRpb24gLyByZWFjdGl2ZSBjb250ZXh0IHdpdGhvdXQgYWNjZXNzaW5nIGFueSBvYnNlcnZhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAoRXhwZXJpbWVudGFsKVxyXG4gICAgICAgICAqIFdhcm4gaWYgb2JzZXJ2YWJsZXMgYXJlIGFjY2Vzc2VkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbG93cyBvdmVyd3JpdGluZyBvZiBjb21wdXRlZCBwcm9wZXJ0aWVzLCB1c2VmdWwgaW4gdGVzdHMgYnV0IG5vdCBwcm9kIGFzIGl0IGNhbiBjYXVzZVxyXG4gICAgICAgICAqIG1lbW9yeSBsZWFrcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTg2N1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRDb25maWd1cmFibGUgPSBmYWxzZTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIERvbid0IGNhdGNoIGFuZCByZXRocm93IGV4Y2VwdGlvbnMuIFRoaXMgaXMgdXNlZnVsIGZvciBpbnNwZWN0aW5nIHRoZSBzdGF0ZSBvZlxyXG4gICAgICAgICAqIHRoZSBzdGFjayB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgZGVidWdnaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9IGZhbHNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogSWYgdHJ1ZSwgd2UgYXJlIGFscmVhZHkgaGFuZGxpbmcgYW4gZXhjZXB0aW9uIGluIGFuIGFjdGlvbi4gQW55IGVycm9ycyBpbiByZWFjdGlvbnMgc2hvdWxkIGJlIHN1cHJlc3NlZCwgYXNcclxuICAgICAgICAgKiB0aGV5IGFyZSBub3QgdGhlIGNhdXNlLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTgzNlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1vYlhHbG9iYWxzO1xyXG59KCkpO1xyXG52YXIgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IHRydWU7XHJcbnZhciBpc29sYXRlQ2FsbGVkID0gZmFsc2U7XHJcbnZhciBnbG9iYWxTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XHJcbiAgICBpZiAoZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPiAwICYmICFnbG9iYWwuX19tb2J4R2xvYmFscylcclxuICAgICAgICBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XHJcbiAgICBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMgJiYgZ2xvYmFsLl9fbW9ieEdsb2JhbHMudmVyc2lvbiAhPT0gbmV3IE1vYlhHbG9iYWxzKCkudmVyc2lvbilcclxuICAgICAgICBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XHJcbiAgICBpZiAoIWNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFpc29sYXRlQ2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsKFwiVGhlcmUgYXJlIG11bHRpcGxlLCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgTW9iWCBhY3RpdmUuIE1ha2Ugc3VyZSBNb2JYIGlzIGxvYWRlZCBvbmx5IG9uY2Ugb3IgdXNlIGBjb25maWd1cmUoeyBpc29sYXRlR2xvYmFsU3RhdGU6IHRydWUgfSlgXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNb2JYR2xvYmFscygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcclxuICAgICAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xyXG4gICAgICAgIGlmICghZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEKVxyXG4gICAgICAgICAgICBnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQgPSB7fTsgLy8gbWFrZSBtZXJnZSBiYWNrd2FyZCBjb21wYXRpYmxlXHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPSAxO1xyXG4gICAgICAgIHJldHVybiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMgPSBuZXcgTW9iWEdsb2JhbHMoKSk7XHJcbiAgICB9XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGlzb2xhdGVHbG9iYWxTdGF0ZSgpIHtcclxuICAgIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fFxyXG4gICAgICAgIGdsb2JhbFN0YXRlLmluQmF0Y2ggfHxcclxuICAgICAgICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpXHJcbiAgICAgICAgZmFpbChcImlzb2xhdGVHbG9iYWxTdGF0ZSBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBNb2JYIGlzIHJ1bm5pbmcgYW55IHJlYWN0aW9uc1wiKTtcclxuICAgIGlzb2xhdGVDYWxsZWQgPSB0cnVlO1xyXG4gICAgaWYgKGNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcclxuICAgICAgICBpZiAoLS1nZXRHbG9iYWwoKS5fX21vYnhJbnN0YW5jZUNvdW50ID09PSAwKVxyXG4gICAgICAgICAgICBnZXRHbG9iYWwoKS5fX21vYnhHbG9iYWxzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGdsb2JhbFN0YXRlID0gbmV3IE1vYlhHbG9iYWxzKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0R2xvYmFsU3RhdGUoKSB7XHJcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGU7XHJcbn1cclxuLyoqXHJcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHk7IHRoaXMgd2lsbCBicmVhayB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgZXhpc3Rpbmcgb2JzZXJ2YWJsZXMsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCB0byBnZXQgYmFjayBhdCBhIHN0YWJsZSBzdGF0ZSBhZnRlciB0aHJvd2luZyBlcnJvcnNcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XHJcbiAgICB2YXIgZGVmYXVsdEdsb2JhbHMgPSBuZXcgTW9iWEdsb2JhbHMoKTtcclxuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscylcclxuICAgICAgICBpZiAocGVyc2lzdGVudEtleXMuaW5kZXhPZihrZXkpID09PSAtMSlcclxuICAgICAgICAgICAgZ2xvYmFsU3RhdGVba2V5XSA9IGRlZmF1bHRHbG9iYWxzW2tleV07XHJcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9ICFnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucztcclxufVxuXG5mdW5jdGlvbiBoYXNPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xyXG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzICYmIG9ic2VydmFibGUub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcclxuICAgIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVycztcclxufVxyXG4vLyBmdW5jdGlvbiBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZTogSU9ic2VydmFibGUpIHtcclxuLy8gICAgIGNvbnN0IGxpc3QgPSBvYnNlcnZhYmxlLm9ic2VydmVyc1xyXG4vLyAgICAgY29uc3QgbWFwID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNJbmRleGVzXHJcbi8vICAgICBjb25zdCBsID0gbGlzdC5sZW5ndGhcclxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbi8vICAgICAgICAgY29uc3QgaWQgPSBsaXN0W2ldLl9fbWFwaWRcclxuLy8gICAgICAgICBpZiAoaSkge1xyXG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQobWFwW2lkXSA9PT0gaSwgXCJJTlRFUk5BTCBFUlJPUiBtYXBzIGRlcml2YXRpb24uX19tYXBpZCB0byBpbmRleCBpbiBsaXN0XCIpIC8vIGZvciBwZXJmb3JtYW5jZVxyXG4vLyAgICAgICAgIH0gZWxzZSB7XHJcbi8vICAgICAgICAgICAgIGludmFyaWFudCghKGlkIGluIG1hcCksIFwiSU5URVJOQUwgRVJST1Igb2JzZXJ2ZXIgb24gaW5kZXggMCBzaG91bGRuJ3QgYmUgaGVsZCBpbiBtYXAuXCIpIC8vIGZvciBwZXJmb3JtYW5jZVxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICAgIGludmFyaWFudChcclxuLy8gICAgICAgICBsaXN0Lmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gbGlzdC5sZW5ndGggLSAxLFxyXG4vLyAgICAgICAgIFwiSU5URVJOQUwgRVJST1IgdGhlcmUgaXMgbm8ganVuayBpbiBtYXBcIlxyXG4vLyAgICAgKVxyXG4vLyB9XHJcbmZ1bmN0aW9uIGFkZE9ic2VydmVyKG9ic2VydmFibGUsIG5vZGUpIHtcclxuICAgIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcclxuICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgYWRkIGFscmVhZHkgYWRkZWQgbm9kZVwiKTtcclxuICAgIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcclxuICAgIHZhciBsID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoO1xyXG4gICAgaWYgKGwpIHtcclxuICAgICAgICAvLyBiZWNhdXNlIG9iamVjdCBhc3NpZ25tZW50IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlLCBsZXQncyBub3Qgc3RvcmUgZGF0YSBhYm91dCBpbmRleCAwLlxyXG4gICAgICAgIG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlc1tub2RlLl9fbWFwaWRdID0gbDtcclxuICAgIH1cclxuICAgIG9ic2VydmFibGUub2JzZXJ2ZXJzW2xdID0gbm9kZTtcclxuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPiBub2RlLmRlcGVuZGVuY2llc1N0YXRlKVxyXG4gICAgICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGU7XHJcbiAgICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XHJcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XHJcbiAgICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IsIHJlbW92ZSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xyXG4gICAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGVcIik7XHJcbiAgICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XHJcbiAgICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gZGVsZXRpbmcgbGFzdCBvYnNlcnZlclxyXG4gICAgICAgIG9ic2VydmFibGUub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGVsZXRpbmcgZnJvbSBfb2JzZXJ2ZXJzSW5kZXhlcyBpcyBzdHJhaWdodCBmb3J3YXJkLCB0byBkZWxldGUgZnJvbSBfb2JzZXJ2ZXJzLCBsZXQncyBzd2FwIGBub2RlYCB3aXRoIGxhc3QgZWxlbWVudFxyXG4gICAgICAgIHZhciBsaXN0ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnM7XHJcbiAgICAgICAgdmFyIG1hcCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlcztcclxuICAgICAgICB2YXIgZmlsbGVyID0gbGlzdC5wb3AoKTsgLy8gZ2V0IGxhc3QgZWxlbWVudCwgd2hpY2ggc2hvdWxkIGZpbGwgdGhlIHBsYWNlIG9mIGBub2RlYCwgc28gdGhlIGFycmF5IGRvZXNuJ3QgaGF2ZSBob2xlc1xyXG4gICAgICAgIGlmIChmaWxsZXIgIT09IG5vZGUpIHtcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG5vZGUgd2FzIHRoZSBsYXN0IGVsZW1lbnQsIHdoaWNoIGFscmVhZHkgZ290IHJlbW92ZWQgZnJvbSBhcnJheVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBtYXBbbm9kZS5fX21hcGlkXSB8fCAwOyAvLyBnZXR0aW5nIGluZGV4IG9mIGBub2RlYC4gdGhpcyBpcyB0aGUgb25seSBwbGFjZSB3ZSBhY3R1YWxseSB1c2UgbWFwLlxyXG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1hcCBzdG9yZSBhbGwgaW5kZXhlcyBidXQgMCwgc2VlIGNvbW1lbnQgaW4gYGFkZE9ic2VydmVyYFxyXG4gICAgICAgICAgICAgICAgbWFwW2ZpbGxlci5fX21hcGlkXSA9IGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtmaWxsZXIuX19tYXBpZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGlzdFtpbmRleF0gPSBmaWxsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBtYXBbbm9kZS5fX21hcGlkXTtcclxuICAgIH1cclxuICAgIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcclxuICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlMlwiKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xyXG4gICAgaWYgKG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcclxuICAgICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSB0cnVlO1xyXG4gICAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKG9ic2VydmFibGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXRjaCBzdGFydHMgYSB0cmFuc2FjdGlvbiwgYXQgbGVhc3QgZm9yIHB1cnBvc2VzIG9mIG1lbW9pemluZyBDb21wdXRlZFZhbHVlcyB3aGVuIG5vdGhpbmcgZWxzZSBkb2VzLlxyXG4gKiBEdXJpbmcgYSBiYXRjaCBgb25CZWNvbWVVbm9ic2VydmVkYCB3aWxsIGJlIGNhbGxlZCBhdCBtb3N0IG9uY2UgcGVyIG9ic2VydmFibGUuXHJcbiAqIEF2b2lkcyB1bm5lY2Vzc2FyeSByZWNhbGN1bGF0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XHJcbiAgICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XHJcbn1cclxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XHJcbiAgICBpZiAoLS1nbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwKSB7XHJcbiAgICAgICAgcnVuUmVhY3Rpb25zKCk7XHJcbiAgICAgICAgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cclxuICAgICAgICB2YXIgbGlzdCA9IGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBsaXN0W2ldO1xyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBvYnNlcnZhYmxlIGhhZCByZWFjdGl2ZSBvYnNlcnZlcnMsIHRyaWdnZXIgdGhlIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLm9uQmVjb21lVW5vYnNlcnZlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHRlYXJlZCBkb3duIHdoZW4gdGhlIGxhc3Qgb2JzZXJ2ZXIgbGVhdmVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwcm9jZXNzIGhhcHBlbnMgcmVjdXJzaXZlbHksIHRoaXMgY29tcHV0ZWQgbWlnaHQgYmUgdGhlIGxhc3Qgb2JzZXJ2YWJlIG9mIGFub3RoZXIsIGV0Yy4uXHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5zdXNwZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQob2JzZXJ2YWJsZSkge1xyXG4gICAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xyXG4gICAgdmFyIGRlcml2YXRpb24gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XHJcbiAgICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNpbXBsZSBvcHRpbWl6YXRpb24sIGdpdmUgZWFjaCBkZXJpdmF0aW9uIHJ1biBhbiB1bmlxdWUgaWQgKHJ1bklkKVxyXG4gICAgICAgICAqIENoZWNrIGlmIGxhc3QgdGltZSB0aGlzIG9ic2VydmFibGUgd2FzIGFjY2Vzc2VkIHRoZSBzYW1lIHJ1bklkIGlzIHVzZWRcclxuICAgICAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChkZXJpdmF0aW9uLnJ1bklkICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnkgPSBkZXJpdmF0aW9uLnJ1bklkO1xyXG4gICAgICAgICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ1tkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnQrK10gPSBvYnNlcnZhYmxlO1xyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLm9uQmVjb21lT2JzZXJ2ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCAmJiBnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCkge1xyXG4gICAgICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBmdW5jdGlvbiBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZTogSU9ic2VydmFibGUsIG1zZzogc3RyaW5nKSB7XHJcbi8vICAgICAvLyBpdCdzIGV4cGVuc2l2ZSBzbyBiZXR0ZXIgbm90IHJ1biBpdCBpbiBwcm9kdWNpdG9uLiBidXQgdGVtcG9yYXJpbHkgaGVscGZ1bCBmb3IgdGVzdGluZ1xyXG4vLyAgICAgY29uc3QgbWluID0gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYi5kZXBlbmRlbmNpZXNTdGF0ZSksIDIpXHJcbi8vICAgICBpZiAobWluID49IG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSkgcmV0dXJuIC8vIDwtIHRoZSBvbmx5IGFzc3VtcHRpb24gYWJvdXQgYGxvd2VzdE9ic2VydmVyU3RhdGVgXHJcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbi8vICAgICAgICAgXCJsb3dlc3RPYnNlcnZlclN0YXRlIGlzIHdyb25nIGZvciBcIiArXHJcbi8vICAgICAgICAgICAgIG1zZyArXHJcbi8vICAgICAgICAgICAgIFwiIGJlY2F1c2UgXCIgK1xyXG4vLyAgICAgICAgICAgICBtaW4gK1xyXG4vLyAgICAgICAgICAgICBcIiA8IFwiICtcclxuLy8gICAgICAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXHJcbi8vICAgICApXHJcbi8vIH1cclxuLyoqXHJcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcclxuICogSXQgd2lsbCBwcm9wYWdhdGUgY2hhbmdlcyB0byBvYnNlcnZlcnMgZnJvbSBwcmV2aW91cyBydW5cclxuICogSXQncyBoYXJkIG9yIG1heWJlIGltcG9zc2libGUgKHdpdGggcmVhc29uYWJsZSBwZXJmKSB0byBnZXQgaXQgcmlnaHQgd2l0aCBjdXJyZW50IGFwcHJvYWNoXHJcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cclxuICogQWxzbyBtb3N0IGJhc2ljIHVzZSBjYXNlcyBzaG91bGQgYmUgb2tcclxuICovXHJcbi8vIENhbGxlZCBieSBBdG9tIHdoZW4gaXRzIHZhbHVlIGNoYW5nZXNcclxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XHJcbiAgICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIHN0YXJ0XCIpO1xyXG4gICAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9PT0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlNUQUxFKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5TVEFMRTtcclxuICAgIHZhciBvYnNlcnZlcnMgPSBvYnNlcnZhYmxlLm9ic2VydmVycztcclxuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB2YXIgZCA9IG9ic2VydmVyc1tpXTtcclxuICAgICAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEUpIHtcclxuICAgICAgICAgICAgaWYgKGQuaXNUcmFjaW5nICE9PSBUcmFjZU1vZGUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGQub25CZWNvbWVTdGFsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkLmRlcGVuZGVuY2llc1N0YXRlID0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlNUQUxFO1xyXG4gICAgfVxyXG4gICAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBlbmRcIik7XHJcbn1cclxuLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcclxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKG9ic2VydmFibGUpIHtcclxuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBzdGFydFwiKTtcclxuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPT09IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5TVEFMRSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuU1RBTEU7XHJcbiAgICB2YXIgb2JzZXJ2ZXJzID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnM7XHJcbiAgICB2YXIgaSA9IG9ic2VydmVycy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdmFyIGQgPSBvYnNlcnZlcnNbaV07XHJcbiAgICAgICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGUgPT09IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5QT1NTSUJMWV9TVEFMRSlcclxuICAgICAgICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5TVEFMRTtcclxuICAgICAgICBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlID09PSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURSAvLyB0aGlzIGhhcHBlbnMgZHVyaW5nIGNvbXB1dGluZyBvZiBgZGAsIGp1c3Qga2VlcCBsb3dlc3RPYnNlcnZlclN0YXRlIHVwIHRvIGRhdGUuXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBleHBvcnRzLklEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURTtcclxuICAgIH1cclxuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBlbmRcIik7XHJcbn1cclxuLy8gVXNlZCBieSBjb21wdXRlZCB3aGVuIGl0cyBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCB3ZSBkb24ndCB3YW4ndCB0byBpbW1lZGlhdGVseSByZWNvbXB1dGUuXHJcbmZ1bmN0aW9uIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XHJcbiAgICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBzdGFydFwiKTtcclxuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgIT09IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5QT1NTSUJMWV9TVEFMRTtcclxuICAgIHZhciBvYnNlcnZlcnMgPSBvYnNlcnZhYmxlLm9ic2VydmVycztcclxuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB2YXIgZCA9IG9ic2VydmVyc1tpXTtcclxuICAgICAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEUpIHtcclxuICAgICAgICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZSA9IGV4cG9ydHMuSURlcml2YXRpb25TdGF0ZS5QT1NTSUJMWV9TVEFMRTtcclxuICAgICAgICAgICAgaWYgKGQuaXNUcmFjaW5nICE9PSBUcmFjZU1vZGUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGQub25CZWNvbWVTdGFsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIGVuZFwiKTtcclxufVxyXG5mdW5jdGlvbiBsb2dUcmFjZUluZm8oZGVyaXZhdGlvbiwgb2JzZXJ2YWJsZSkge1xyXG4gICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiICsgZGVyaXZhdGlvbi5uYW1lICsgXCInIGlzIGludmFsaWRhdGVkIGR1ZSB0byBhIGNoYW5nZSBpbjogJ1wiICsgb2JzZXJ2YWJsZS5uYW1lICsgXCInXCIpO1xyXG4gICAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nID09PSBUcmFjZU1vZGUuQlJFQUspIHtcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICBwcmludERlcFRyZWUoZ2V0RGVwZW5kZW5jeVRyZWUoZGVyaXZhdGlvbiksIGxpbmVzLCAxKTtcclxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICBuZXcgRnVuY3Rpb24oXCJkZWJ1Z2dlcjtcXG4vKlxcblRyYWNpbmcgJ1wiICsgZGVyaXZhdGlvbi5uYW1lICsgXCInXFxuXFxuWW91IGFyZSBlbnRlcmluZyB0aGlzIGJyZWFrIHBvaW50IGJlY2F1c2UgZGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWUgKyBcIicgaXMgYmVpbmcgdHJhY2VkIGFuZCAnXCIgKyBvYnNlcnZhYmxlLm5hbWUgKyBcIicgaXMgbm93IGZvcmNpbmcgaXQgdG8gdXBkYXRlLlxcbkp1c3QgZm9sbG93IHRoZSBzdGFja3RyYWNlIHlvdSBzaG91bGQgbm93IHNlZSBpbiB0aGUgZGV2dG9vbHMgdG8gc2VlIHByZWNpc2VseSB3aGF0IHBpZWNlIG9mIHlvdXIgY29kZSBpcyBjYXVzaW5nIHRoaXMgdXBkYXRlXFxuVGhlIHN0YWNrZnJhbWUgeW91IGFyZSBsb29raW5nIGZvciBpcyBhdCBsZWFzdCB+Ni04IHN0YWNrLWZyYW1lcyB1cC5cXG5cXG5cIiArIChkZXJpdmF0aW9uIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSA/IGRlcml2YXRpb24uZGVyaXZhdGlvbi50b1N0cmluZygpLnJlcGxhY2UoL1sqXVxcLy9nLCBcIi9cIikgOiBcIlwiKSArIFwiXFxuXFxuVGhlIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBkZXJpdmF0aW9uIGFyZTpcXG5cXG5cIiArIGxpbmVzLmpvaW4oXCJcXG5cIikgKyBcIlxcbiovXFxuICAgIFwiKSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByaW50RGVwVHJlZSh0cmVlLCBsaW5lcywgZGVwdGgpIHtcclxuICAgIGlmIChsaW5lcy5sZW5ndGggPj0gMTAwMCkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGluZXMucHVzaChcIlwiICsgbmV3IEFycmF5KGRlcHRoKS5qb2luKFwiXFx0XCIpICsgdHJlZS5uYW1lKTsgLy8gTVdFOiBub3QgdGhlIGZhc3Rlc3QsIGJ1dCB0aGUgZWFzaWVzdCB3YXkgOilcclxuICAgIGlmICh0cmVlLmRlcGVuZGVuY2llcylcclxuICAgICAgICB0cmVlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gcHJpbnREZXBUcmVlKGNoaWxkLCBsaW5lcywgZGVwdGggKyAxKTsgfSk7XHJcbn1cblxudmFyIFJlYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZSwgb25JbnZhbGlkYXRlLCBlcnJvckhhbmRsZXIsIHJlcXVpcmVzT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiUmVhY3Rpb25AXCIgKyBnZXROZXh0SWQoKTsgfVxyXG4gICAgICAgIGlmIChyZXF1aXJlc09ic2VydmFibGUgPT09IHZvaWQgMCkgeyByZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5vbkludmFsaWRhdGUgPSBvbkludmFsaWRhdGU7XHJcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGUgPSByZXF1aXJlc09ic2VydmFibGU7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBbXTsgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXHJcbiAgICAgICAgdGhpcy5uZXdPYnNlcnZpbmcgPSBbXTtcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlID0gZXhwb3J0cy5JRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORztcclxuICAgICAgICB0aGlzLmRpZmZWYWx1ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5ydW5JZCA9IDA7XHJcbiAgICAgICAgdGhpcy51bmJvdW5kRGVwc0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9fbWFwaWQgPSBcIiNcIiArIGdldE5leHRJZCgpO1xyXG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzU2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNUcmFja1BlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVHJhY2luZyA9IFRyYWNlTW9kZS5OT05FO1xyXG4gICAgfVxyXG4gICAgUmVhY3Rpb24ucHJvdG90eXBlLm9uQmVjb21lU3RhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xyXG4gICAgfTtcclxuICAgIFJlYWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzU2NoZWR1bGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2NoZWR1bGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICBydW5SZWFjdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVhY3Rpb24ucHJvdG90eXBlLmlzU2NoZWR1bGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NjaGVkdWxlZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cclxuICAgICAqL1xyXG4gICAgUmVhY3Rpb24ucHJvdG90eXBlLnJ1blJlYWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgICAgICAgICAgdGhpcy5faXNTY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzVHJhY2tQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkludmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUcmFja1BlbmRpbmcgJiYgaXNTcHlFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHlSZXBvcnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVuZEJhdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlYWN0aW9uLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgICAgICB2YXIgbm90aWZ5ID0gaXNTcHlFbmFibGVkKCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZTtcclxuICAgICAgICBpZiAobm90aWZ5KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgZm4sIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNUcmFja1BlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc3Bvc2VkIGR1cmluZyBsYXN0IHJ1bi4gQ2xlYW4gdXAgZXZlcnl0aGluZyB0aGF0IHdhcyBib3VuZCBhZnRlciB0aGUgZGlzcG9zZSBjYWxsLlxyXG4gICAgICAgICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uKHJlc3VsdC5jYXVzZSk7XHJcbiAgICAgICAgaWYgKG5vdGlmeSkge1xyXG4gICAgICAgICAgICBzcHlSZXBvcnRFbmQoe1xyXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kQmF0Y2goKTtcclxuICAgIH07XHJcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5lcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIoZXJyb3IsIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCI7XHJcbiAgICAgICAgaWYgKGdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIChlcnJvciBpbiByZWFjdGlvbiAnXCIgKyB0aGlzLm5hbWUgKyBcIicgc3VwcHJlc3NlZCwgZml4IGVycm9yIG9mIGNhdXNpbmcgYWN0aW9uIGJlbG93KVwiKTsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcclxuICAgICAgICAgICAgLyoqIElmIGRlYnVnZ2luZyBicm91Z2h0IHlvdSBoZXJlLCBwbGVhc2UsIHJlYWQgdGhlIGFib3ZlIG1lc3NhZ2UgOi0pLiBUbnghICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NweUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICBzcHlSZXBvcnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBcIlwiICsgZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKGVycm9yLCBfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIFJlYWN0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBkaXNwb3NlZCB3aGlsZSBydW5uaW5nLCBjbGVhbiB1cCBsYXRlci4gTWF5YmUgbm90IG9wdGltYWwsIGJ1dCByYXJlIGNhc2VcclxuICAgICAgICAgICAgICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgICAgICAgICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZW5kQmF0Y2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUuZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmRpc3Bvc2UuYmluZCh0aGlzKTtcclxuICAgICAgICByLiRtb2J4ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiUmVhY3Rpb25bXCIgKyB0aGlzLm5hbWUgKyBcIl1cIjtcclxuICAgIH07XHJcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAoZW50ZXJCcmVha1BvaW50KSB7XHJcbiAgICAgICAgaWYgKGVudGVyQnJlYWtQb2ludCA9PT0gdm9pZCAwKSB7IGVudGVyQnJlYWtQb2ludCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdHJhY2UodGhpcywgZW50ZXJCcmVha1BvaW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVhY3Rpb247XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIG9uUmVhY3Rpb25FcnJvcihoYW5kbGVyKSB7XHJcbiAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChpZHggPj0gMClcclxuICAgICAgICAgICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogTWFnaWMgbnVtYmVyIGFsZXJ0IVxyXG4gKiBEZWZpbmVzIHdpdGhpbiBob3cgbWFueSB0aW1lcyBhIHJlYWN0aW9uIGlzIGFsbG93ZWQgdG8gcmUtdHJpZ2dlciBpdHNlbGZcclxuICogdW50aWwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgaXMgZ29ubmEgYmUgYSBuZXZlciBlbmRpbmcgbG9vcC4uLlxyXG4gKi9cclxudmFyIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TID0gMTAwO1xyXG52YXIgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9O1xyXG5mdW5jdGlvbiBydW5SZWFjdGlvbnMoKSB7XHJcbiAgICAvLyBUcmFtcG9saW5pbmcsIGlmIHJ1blJlYWN0aW9ucyBhcmUgYWxyZWFkeSBydW5uaW5nLCBuZXcgcmVhY3Rpb25zIHdpbGwgYmUgcGlja2VkIHVwXHJcbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XHJcbn1cclxuZnVuY3Rpb24gcnVuUmVhY3Rpb25zSGVscGVyKCkge1xyXG4gICAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gdHJ1ZTtcclxuICAgIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xyXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgLy8gV2hpbGUgcnVubmluZyByZWFjdGlvbnMsIG5ldyByZWFjdGlvbnMgbWlnaHQgYmUgdHJpZ2dlcmVkLlxyXG4gICAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcclxuICAgIC8vIHdlIGNvbnZlcmdlIHRvIG5vIHJlbWFpbmluZyByZWFjdGlvbnMgYWZ0ZXIgYSB3aGlsZS5cclxuICAgIHdoaWxlIChhbGxSZWFjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPT09IE1BWF9SRUFDVElPTl9JVEVSQVRJT05TKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdGlvbiBkb2Vzbid0IGNvbnZlcmdlIHRvIGEgc3RhYmxlIHN0YXRlIGFmdGVyIFwiICsgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgKyBcIiBpdGVyYXRpb25zLlwiICtcclxuICAgICAgICAgICAgICAgIChcIiBQcm9iYWJseSB0aGVyZSBpcyBhIGN5Y2xlIGluIHRoZSByZWFjdGl2ZSBmdW5jdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pKTtcclxuICAgICAgICAgICAgYWxsUmVhY3Rpb25zLnNwbGljZSgwKTsgLy8gY2xlYXIgcmVhY3Rpb25zXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1haW5pbmdSZWFjdGlvbnMgPSBhbGxSZWFjdGlvbnMuc3BsaWNlKDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtYWluaW5nUmVhY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgcmVtYWluaW5nUmVhY3Rpb25zW2ldLnJ1blJlYWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcclxufVxyXG52YXIgaXNSZWFjdGlvbiA9IGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJSZWFjdGlvblwiLCBSZWFjdGlvbik7XHJcbmZ1bmN0aW9uIHNldFJlYWN0aW9uU2NoZWR1bGVyKGZuKSB7XHJcbiAgICB2YXIgYmFzZVNjaGVkdWxlciA9IHJlYWN0aW9uU2NoZWR1bGVyO1xyXG4gICAgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZm4oZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZVNjaGVkdWxlcihmKTsgfSk7IH07XHJcbn1cblxuZnVuY3Rpb24gaXNTcHlFbmFibGVkKCkge1xyXG4gICAgcmV0dXJuICEhZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aDtcclxufVxyXG5mdW5jdGlvbiBzcHlSZXBvcnQoZXZlbnQpIHtcclxuICAgIGlmICghZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGxpc3RlbmVyc1tpXShldmVudCk7XHJcbn1cclxuZnVuY3Rpb24gc3B5UmVwb3J0U3RhcnQoZXZlbnQpIHtcclxuICAgIHZhciBjaGFuZ2UgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnQpLCB7IHNweVJlcG9ydFN0YXJ0OiB0cnVlIH0pO1xyXG4gICAgc3B5UmVwb3J0KGNoYW5nZSk7XHJcbn1cclxudmFyIEVORF9FVkVOVCA9IHsgc3B5UmVwb3J0RW5kOiB0cnVlIH07XHJcbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcclxuICAgIGlmIChjaGFuZ2UpXHJcbiAgICAgICAgc3B5UmVwb3J0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IHNweVJlcG9ydEVuZDogdHJ1ZSB9KSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgc3B5UmVwb3J0KEVORF9FVkVOVCk7XHJcbn1cclxuZnVuY3Rpb24gc3B5KGxpc3RlbmVyKSB7XHJcbiAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gZG9udFJlYXNzaWduRmllbGRzKCkge1xyXG4gICAgZmFpbChcIkBhY3Rpb24gZmllbGRzIGFyZSBub3QgcmVhc3NpZ25hYmxlXCIpO1xyXG59XHJcbmZ1bmN0aW9uIG5hbWVkQWN0aW9uRGVjb3JhdG9yKG5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwiQGFjdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIGdldHRlcnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYmFiZWwgLyB0eXBlc2NyaXB0XHJcbiAgICAgICAgICAgIC8vIEBhY3Rpb24gbWV0aG9kKCkgeyB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0eXBlc2NyaXB0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjcmVhdGVBY3Rpb24obmFtZSwgZGVzY3JpcHRvci52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlIC8vIGZvciB0eXBlc2NyaXB0LCB0aGlzIG11c3QgYmUgd3JpdGFibGUsIG90aGVyd2lzZSBpdCBjYW5ub3QgaW5oZXJpdCA6LyAoc2VlIGluaGVyaXRhYmxlIGFjdGlvbnMgdGVzdClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYmFiZWwgb25seTogQGFjdGlvbiBtZXRob2QgPSAoKSA9PiB7fVxyXG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXJfMSA9IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOLkI6IHdlIGNhbid0IGltbWVkaWF0ZWx5IGludm9rZSBpbml0aWFsaXplcjsgdGhpcyB3b3VsZCBiZSB3cm9uZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24obmFtZSwgaW5pdGlhbGl6ZXJfMS5jYWxsKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm91bmQgaW5zdGFuY2UgbWV0aG9kc1xyXG4gICAgICAgIHJldHVybiBhY3Rpb25GaWVsZERlY29yYXRvcihuYW1lKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBhY3Rpb25GaWVsZERlY29yYXRvcihuYW1lKSB7XHJcbiAgICAvLyBTaW1wbGUgcHJvcGVydHkgdGhhdCB3cml0ZXMgb24gZmlyc3QgaW52b2NhdGlvbiB0byB0aGUgY3VycmVudCBpbnN0YW5jZVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZEhpZGRlblByb3AodGhpcywgcHJvcCwgYWN0aW9uKG5hbWUsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYm91bmRBY3Rpb25EZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IsIGFwcGx5VG9JbnN0YW5jZSkge1xyXG4gICAgaWYgKGFwcGx5VG9JbnN0YW5jZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGRlZmluZUJvdW5kQWN0aW9uKHRhcmdldCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLnZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgLy8gaWYgKGRlc2NyaXB0b3IudmFsdWUpXHJcbiAgICAgICAgLy8gVHlwZXNjcmlwdCAvIEJhYmVsOiBAYWN0aW9uLmJvdW5kIG1ldGhvZCgpIHsgfVxyXG4gICAgICAgIC8vIGFsc286IGJhYmVsIEBhY3Rpb24uYm91bmQgbWV0aG9kID0gKCkgPT4ge31cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZUJvdW5kQWN0aW9uKHRoaXMsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvci52YWx1ZSB8fCBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBkb250UmVhc3NpZ25GaWVsZHNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gZmllbGQgZGVjb3JhdG9yIFR5cGVzY3JpcHQgQGFjdGlvbi5ib3VuZCBtZXRob2QgPSAoKSA9PiB7fVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBkZWZpbmVCb3VuZEFjdGlvbih0aGlzLCBwcm9wZXJ0eU5hbWUsIHYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG52YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcclxuICAgIC8vIGFjdGlvbihmbigpIHt9KVxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEubmFtZSB8fCBcIjx1bm5hbWVkIGFjdGlvbj5cIiwgYXJnMSk7XHJcbiAgICAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMik7XHJcbiAgICAvLyBAYWN0aW9uKFwibmFtZVwiKSBmbigpIHt9XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4gbmFtZWRBY3Rpb25EZWNvcmF0b3IoYXJnMSk7XHJcbiAgICAvLyBAYWN0aW9uIGZuKCkge31cclxuICAgIGlmIChhcmc0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgdG8gaW5zdGFuY2UgaW1tZWRpYXRlbHlcclxuICAgICAgICBhcmcxW2FyZzJdID0gY3JlYXRlQWN0aW9uKGFyZzEubmFtZSB8fCBhcmcyLCBhcmczLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuYW1lZEFjdGlvbkRlY29yYXRvcihhcmcyKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG59O1xyXG5hY3Rpb24uYm91bmQgPSBib3VuZEFjdGlvbkRlY29yYXRvcjtcclxuZnVuY3Rpb24gcnVuSW5BY3Rpb24oYXJnMSwgYXJnMikge1xyXG4gICAgLy8gVE9ETzogZGVwcmVjYXRlP1xyXG4gICAgdmFyIGFjdGlvbk5hbWUgPSB0eXBlb2YgYXJnMSA9PT0gXCJzdHJpbmdcIiA/IGFyZzEgOiBhcmcxLm5hbWUgfHwgXCI8dW5uYW1lZCBhY3Rpb24+XCI7XHJcbiAgICB2YXIgZm4gPSB0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiID8gYXJnMSA6IGFyZzI7XHJcbiAgICB7XHJcbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiICYmIGZuLmxlbmd0aCA9PT0gMCwgXCJgcnVuSW5BY3Rpb25gIGV4cGVjdHMgYSBmdW5jdGlvbiB3aXRob3V0IGFyZ3VtZW50c1wiKTtcclxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgIGZhaWwoXCJhY3Rpb25zIHNob3VsZCBoYXZlIHZhbGlkIG5hbWVzLCBnb3Q6ICdcIiArIGFjdGlvbk5hbWUgKyBcIidcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgdGhpcywgdW5kZWZpbmVkKTtcclxufVxyXG5mdW5jdGlvbiBpc0FjdGlvbih0aGluZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gXCJmdW5jdGlvblwiICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVCb3VuZEFjdGlvbih0YXJnZXQsIHByb3BlcnR5TmFtZSwgZm4pIHtcclxuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIGNyZWF0ZUFjdGlvbihwcm9wZXJ0eU5hbWUsIGZuLmJpbmQodGFyZ2V0KSkpO1xyXG59XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmFtZWQgcmVhY3RpdmUgdmlldyBhbmQga2VlcHMgaXQgYWxpdmUsIHNvIHRoYXQgdGhlIHZpZXcgaXMgYWx3YXlzXHJcbiAqIHVwZGF0ZWQgaWYgb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcywgZXZlbiB3aGVuIHRoZSB2aWV3IGlzIG5vdCBmdXJ0aGVyIHVzZWQgYnkgc29tZXRoaW5nIGVsc2UuXHJcbiAqIEBwYXJhbSB2aWV3IFRoZSByZWFjdGl2ZSB2aWV3XHJcbiAqIEByZXR1cm5zIGRpc3Bvc2VyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzdG9wIHRoZSB2aWV3IGZyb20gYmVpbmcgdXBkYXRlZCBpbiB0aGUgZnV0dXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXV0b3J1bih2aWV3LCBvcHRzKSB7XHJcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSBFTVBUWV9PQkpFQ1Q7IH1cclxuICAgIHtcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHZpZXcgPT09IFwiZnVuY3Rpb25cIiwgXCJBdXRvcnVuIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudFwiKTtcclxuICAgICAgICBpbnZhcmlhbnQoaXNBY3Rpb24odmlldykgPT09IGZhbHNlLCBcIkF1dG9ydW4gZG9lcyBub3QgYWNjZXB0IGFjdGlvbnMgc2luY2UgYWN0aW9ucyBhcmUgdW50cmFja2FibGVcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgbmFtZSA9IChvcHRzICYmIG9wdHMubmFtZSkgfHwgdmlldy5uYW1lIHx8IFwiQXV0b3J1bkBcIiArIGdldE5leHRJZCgpO1xyXG4gICAgdmFyIHJ1blN5bmMgPSAhb3B0cy5zY2hlZHVsZXIgJiYgIW9wdHMuZGVsYXk7XHJcbiAgICB2YXIgcmVhY3Rpb247XHJcbiAgICBpZiAocnVuU3luYykge1xyXG4gICAgICAgIC8vIG5vcm1hbCBhdXRvcnVuXHJcbiAgICAgICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcclxuICAgICAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBzY2hlZHVsZXJfMSA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xyXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdXRvcnVuXHJcbiAgICAgICAgdmFyIGlzU2NoZWR1bGVkXzEgPSBmYWxzZTtcclxuICAgICAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTY2hlZHVsZWRfMSkge1xyXG4gICAgICAgICAgICAgICAgaXNTY2hlZHVsZWRfMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJfMShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTY2hlZHVsZWRfMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVhY3Rpb24uaXNEaXNwb3NlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhY3Rpb24udHJhY2socmVhY3Rpb25SdW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlYWN0aW9uUnVubmVyKCkge1xyXG4gICAgICAgIHZpZXcocmVhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgcmVhY3Rpb24uc2NoZWR1bGUoKTtcclxuICAgIHJldHVybiByZWFjdGlvbi5nZXREaXNwb3NlcigpO1xyXG59XHJcbnZhciBydW4gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9O1xyXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKSB7XHJcbiAgICByZXR1cm4gb3B0cy5zY2hlZHVsZXJcclxuICAgICAgICA/IG9wdHMuc2NoZWR1bGVyXHJcbiAgICAgICAgOiBvcHRzLmRlbGF5XHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgb3B0cy5kZWxheSk7IH1cclxuICAgICAgICAgICAgOiBydW47XHJcbn1cclxuZnVuY3Rpb24gcmVhY3Rpb24oZXhwcmVzc2lvbiwgZWZmZWN0LCBvcHRzKSB7XHJcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSBFTVBUWV9PQkpFQ1Q7IH1cclxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBvcHRzID0geyBmaXJlSW1tZWRpYXRlbHk6IG9wdHMgfTtcclxuICAgICAgICBkZXByZWNhdGVkKFwiVXNpbmcgZmlyZUltbWVkaWF0ZWx5IGFzIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuIFVzZSAneyBmaXJlSW1tZWRpYXRlbHk6IHRydWUgfScgaW5zdGVhZFwiKTtcclxuICAgIH1cclxuICAgIHtcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIiwgXCJGaXJzdCBhcmd1bWVudCB0byByZWFjdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIG9wdHMgPT09IFwib2JqZWN0XCIsIFwiVGhpcmQgYXJndW1lbnQgb2YgcmVhY3Rpb25zIHNob3VsZCBiZSBhbiBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgbmFtZSA9IG9wdHMubmFtZSB8fCBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCk7XHJcbiAgICB2YXIgZWZmZWN0QWN0aW9uID0gYWN0aW9uKG5hbWUsIG9wdHMub25FcnJvciA/IHdyYXBFcnJvckhhbmRsZXIob3B0cy5vbkVycm9yLCBlZmZlY3QpIDogZWZmZWN0KTtcclxuICAgIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xyXG4gICAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xyXG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XHJcbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciBlcXVhbHMgPSBvcHRzLmNvbXBhcmVTdHJ1Y3R1cmFsXHJcbiAgICAgICAgPyBjb21wYXJlci5zdHJ1Y3R1cmFsXHJcbiAgICAgICAgOiBvcHRzLmVxdWFscyB8fCBjb21wYXJlci5kZWZhdWx0O1xyXG4gICAgdmFyIHIgPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChmaXJzdFRpbWUgfHwgcnVuU3luYykge1xyXG4gICAgICAgICAgICByZWFjdGlvblJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcclxuICAgICAgICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzY2hlZHVsZXIocmVhY3Rpb25SdW5uZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xyXG4gICAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XHJcbiAgICAgICAgaXNTY2hlZHVsZWQgPSBmYWxzZTsgLy8gUTogbW92ZSBpbnRvIHJlYWN0aW9uIHJ1bm5lcj9cclxuICAgICAgICBpZiAoci5pc0Rpc3Bvc2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICByLnRyYWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGV4cHJlc3Npb24ocik7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSBmaXJzdFRpbWUgfHwgIWVxdWFscyh2YWx1ZSwgbmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGZpcnN0VGltZSAmJiBvcHRzLmZpcmVJbW1lZGlhdGVseSlcclxuICAgICAgICAgICAgZWZmZWN0QWN0aW9uKHZhbHVlLCByKTtcclxuICAgICAgICBpZiAoIWZpcnN0VGltZSAmJiBjaGFuZ2VkID09PSB0cnVlKVxyXG4gICAgICAgICAgICBlZmZlY3RBY3Rpb24odmFsdWUsIHIpO1xyXG4gICAgICAgIGlmIChmaXJzdFRpbWUpXHJcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgci5zY2hlZHVsZSgpO1xyXG4gICAgcmV0dXJuIHIuZ2V0RGlzcG9zZXIoKTtcclxufVxyXG5mdW5jdGlvbiB3cmFwRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgYmFzZUZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBvbkJlY29tZU9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XHJcbiAgICByZXR1cm4gaW50ZXJjZXB0SG9vayhcIm9uQmVjb21lT2JzZXJ2ZWRcIiwgdGhpbmcsIGFyZzIsIGFyZzMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQmVjb21lVW5vYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xyXG4gICAgcmV0dXJuIGludGVyY2VwdEhvb2soXCJvbkJlY29tZVVub2JzZXJ2ZWRcIiwgdGhpbmcsIGFyZzIsIGFyZzMpO1xyXG59XHJcbmZ1bmN0aW9uIGludGVyY2VwdEhvb2soaG9vaywgdGhpbmcsIGFyZzIsIGFyZzMpIHtcclxuICAgIHZhciBhdG9tID0gdHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIiA/IGdldEF0b20odGhpbmcsIGFyZzIpIDogZ2V0QXRvbSh0aGluZyk7XHJcbiAgICB2YXIgY2IgPSB0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiID8gYXJnMyA6IGFyZzI7XHJcbiAgICB2YXIgb3JpZyA9IGF0b21baG9va107XHJcbiAgICBpZiAodHlwZW9mIG9yaWcgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICByZXR1cm4gZmFpbChcIk5vdCBhbiBhdG9tIHRoYXQgY2FuIGJlICh1bilvYnNlcnZlZFwiKTtcclxuICAgIGF0b21baG9va10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3JpZy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGNiLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhdG9tW2hvb2tdID0gb3JpZztcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcclxuICAgIHZhciBlbmZvcmNlQWN0aW9ucyA9IG9wdGlvbnMuZW5mb3JjZUFjdGlvbnMsIGNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiA9IG9wdGlvbnMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uLCBjb21wdXRlZENvbmZpZ3VyYWJsZSA9IG9wdGlvbnMuY29tcHV0ZWRDb25maWd1cmFibGUsIGRpc2FibGVFcnJvckJvdW5kYXJpZXMgPSBvcHRpb25zLmRpc2FibGVFcnJvckJvdW5kYXJpZXMsIGFycmF5QnVmZmVyID0gb3B0aW9ucy5hcnJheUJ1ZmZlciwgcmVhY3Rpb25TY2hlZHVsZXIgPSBvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyLCByZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSA9IG9wdGlvbnMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUsIG9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uID0gb3B0aW9ucy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcclxuICAgIGlmIChvcHRpb25zLmlzb2xhdGVHbG9iYWxTdGF0ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGlzb2xhdGVHbG9iYWxTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVuZm9yY2VBY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZm9yY2VBY3Rpb25zID09PSBcImJvb2xlYW5cIiB8fCBlbmZvcmNlQWN0aW9ucyA9PT0gXCJzdHJpY3RcIilcclxuICAgICAgICAgICAgZGVwcmVjYXRlZChcIkRlcHJlY2F0ZWQgdmFsdWUgZm9yICdlbmZvcmNlQWN0aW9ucycsIHVzZSAnZmFsc2UnID0+ICdcXFwibmV2ZXJcXFwiJywgJ3RydWUnID0+ICdcXFwib2JzZXJ2ZWRcXFwiJywgJ1xcXCJzdHJpY3RcXFwiJyA9PiBcXFwiJ2Fsd2F5cydcXFwiIGluc3RlYWRcIik7XHJcbiAgICAgICAgdmFyIGVhID0gdm9pZCAwO1xyXG4gICAgICAgIHN3aXRjaCAoZW5mb3JjZUFjdGlvbnMpIHtcclxuICAgICAgICAgICAgY2FzZSB0cnVlOlxyXG4gICAgICAgICAgICBjYXNlIFwib2JzZXJ2ZWRcIjpcclxuICAgICAgICAgICAgICAgIGVhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGZhbHNlOlxyXG4gICAgICAgICAgICBjYXNlIFwibmV2ZXJcIjpcclxuICAgICAgICAgICAgICAgIGVhID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0cmljdFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYWx3YXlzXCI6XHJcbiAgICAgICAgICAgICAgICBlYSA9IFwic3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGZhaWwoXCJJbnZhbGlkIHZhbHVlIGZvciAnZW5mb3JjZUFjdGlvbnMnOiAnXCIgKyBlbmZvcmNlQWN0aW9ucyArIFwiJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPSBlYTtcclxuICAgICAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGVhID09PSB0cnVlIHx8IGVhID09PSBcInN0cmljdFwiID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uID0gISFjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb247XHJcbiAgICB9XHJcbiAgICBpZiAocmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGdsb2JhbFN0YXRlLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlID0gISFyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZTtcclxuICAgIH1cclxuICAgIGlmIChvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24gPSAhIW9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uO1xyXG4gICAgICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9ICFnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcclxuICAgIH1cclxuICAgIGlmIChjb21wdXRlZENvbmZpZ3VyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZ2xvYmFsU3RhdGUuY29tcHV0ZWRDb25maWd1cmFibGUgPSAhIWNvbXB1dGVkQ29uZmlndXJhYmxlO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc2FibGVFcnJvckJvdW5kYXJpZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChkaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBEZWJ1ZyBmZWF0dXJlIG9ubHkuIE1vYlggd2lsbCBOT1QgcmVjb3ZlciBmcm9tIGVycm9ycyBpZiB0aGlzIGlzIG9uLlwiKTtcclxuICAgICAgICBnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID0gISFkaXNhYmxlRXJyb3JCb3VuZGFyaWVzO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBhcnJheUJ1ZmZlciA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHJlc2VydmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBpZiAocmVhY3Rpb25TY2hlZHVsZXIpIHtcclxuICAgICAgICBzZXRSZWFjdGlvblNjaGVkdWxlcihyZWFjdGlvblNjaGVkdWxlcik7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGUodGhpbmcsIGRlY29yYXRvcnMpIHtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdChkZWNvcmF0b3JzKSlcclxuICAgICAgICBmYWlsKFwiRGVjb3JhdG9ycyBzaG91bGQgYmUgYSBrZXkgdmFsdWUgbWFwXCIpO1xyXG4gICAgdmFyIHRhcmdldCA9IHR5cGVvZiB0aGluZyA9PT0gXCJmdW5jdGlvblwiID8gdGhpbmcucHJvdG90eXBlIDogdGhpbmc7XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5RGVjb3JhdG9ycyA9IGRlY29yYXRvcnNbcHJvcF07XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5RGVjb3JhdG9ycykpIHtcclxuICAgICAgICAgICAgcHJvcGVydHlEZWNvcmF0b3JzID0gW3Byb3BlcnR5RGVjb3JhdG9yc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgIGlmICghcHJvcGVydHlEZWNvcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChkZWNvcmF0b3IpIHsgcmV0dXJuIHR5cGVvZiBkZWNvcmF0b3IgPT09IFwiZnVuY3Rpb25cIjsgfSkpXHJcbiAgICAgICAgICAgIGZhaWwoXCJEZWNvcmF0ZTogZXhwZWN0ZWQgYSBkZWNvcmF0b3IgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZGVjb3JhdG9yIGZ1bmN0aW9ucyBmb3IgJ1wiICsgcHJvcCArIFwiJ1wiKTtcclxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcclxuICAgICAgICB2YXIgbmV3RGVzY3JpcHRvciA9IHByb3BlcnR5RGVjb3JhdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKGFjY0Rlc2NyaXB0b3IsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcCwgYWNjRGVzY3JpcHRvcik7IH0sIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGlmIChuZXdEZXNjcmlwdG9yKVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCBuZXdEZXNjcmlwdG9yKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGRlY29yYXRvcnMpIHtcclxuICAgICAgICBfbG9vcF8xKHByb3ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaW5nO1xyXG59XG5cbmZ1bmN0aW9uIGV4dGVuZFNoYWxsb3dPYnNlcnZhYmxlKHRhcmdldCwgcHJvcGVydGllcywgZGVjb3JhdG9ycykge1xyXG4gICAgZGVwcmVjYXRlZChcIidleHRlbmRTaGFsbG93T2JzZXJ2YWJsZScgaXMgZGVwcmVjYXRlZCwgdXNlICdleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgcHJvcHMsIHsgZGVlcDogZmFsc2UgfSknIGluc3RlYWRcIik7XHJcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHByb3BlcnRpZXMsIGRlY29yYXRvcnMsIHNoYWxsb3dDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHByb3BlcnRpZXMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcclxuICAgIHtcclxuICAgICAgICBpbnZhcmlhbnQoYXJndW1lbnRzLmxlbmd0aCA+PSAyICYmIGFyZ3VtZW50cy5sZW5ndGggPD0gNCwgXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0ZWQgMi00IGFyZ3VtZW50c1wiKTtcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiwgXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIik7XHJcbiAgICAgICAgaW52YXJpYW50KCFpc09ic2VydmFibGVNYXAodGFyZ2V0KSwgXCInZXh0ZW5kT2JzZXJ2YWJsZScgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIG1hcHMsIHVzZSBtYXAubWVyZ2UgaW5zdGVhZFwiKTtcclxuICAgICAgICBpbnZhcmlhbnQoIWlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSwgXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjb25zdHJ1Y3QgYW4gZXhwbGljaXQgcHJvcGVydHltYXAsIHVzaW5nIGB0b0pTYCBpZiBuZWVkLiBTZWUgaXNzdWUgIzU0MFwiKTtcclxuICAgICAgICBpZiAoZGVjb3JhdG9ycylcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRlY29yYXRvcnMpXHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcHJvcGVydGllcykpXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbChcIlRyeWluZyB0byBkZWNsYXJlIGEgZGVjb3JhdG9yIGZvciB1bnNwZWNpZmllZCBwcm9wZXJ0eSAnXCIgKyBrZXkgKyBcIidcIik7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIHZhciBkZWZhdWx0RGVjb3JhdG9yID0gb3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yIHx8IChvcHRpb25zLmRlZXAgPT09IGZhbHNlID8gcmVmRGVjb3JhdG9yIDogZGVlcERlY29yYXRvcik7XHJcbiAgICBpbml0aWFsaXplSW5zdGFuY2UodGFyZ2V0KTtcclxuICAgIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMubmFtZSwgZGVmYXVsdERlY29yYXRvci5lbmhhbmNlcik7IC8vIG1ha2Ugc3VyZSBvYmplY3QgaXMgb2JzZXJ2YWJsZSwgZXZlbiB3aXRob3V0IGluaXRpYWwgcHJvcHNcclxuICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXMsIGtleSk7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkKGRlc2NyaXB0b3IudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwoXCJQYXNzaW5nIGEgJ2NvbXB1dGVkJyBhcyBpbml0aWFsIHByb3BlcnR5IHZhbHVlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgZXh0ZW5kT2JzZXJ2YWJsZS4gVXNlIGEgZ2V0dGVyIG9yIGRlY29yYXRvciBpbnN0ZWFkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzICYmIGtleSBpbiBkZWNvcmF0b3JzXHJcbiAgICAgICAgICAgICAgICA/IGRlY29yYXRvcnNba2V5XVxyXG4gICAgICAgICAgICAgICAgOiBkZXNjcmlwdG9yLmdldFxyXG4gICAgICAgICAgICAgICAgICAgID8gY29tcHV0ZWREZWNvcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHREZWNvcmF0b3I7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVjb3JhdG9yICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcIk5vdCBhIHZhbGlkIGRlY29yYXRvciBmb3IgJ1wiICsga2V5ICsgXCInLCBnb3Q6IFwiICsgZGVjb3JhdG9yKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdERlc2NyaXB0b3IgPSBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0RGVzY3JpcHRvciAvLyBvdGhlcndpc2UsIGFzc3VtZSBhbHJlYWR5IGFwcGxpZWQsIGR1ZSB0byBgYXBwbHlUb0luc3RhbmNlYFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHJlc3VsdERlc2NyaXB0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGVuZEJhdGNoKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xyXG4gICAgcmV0dXJuIG5vZGVUb0RlcGVuZGVuY3lUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XHJcbn1cclxuZnVuY3Rpb24gbm9kZVRvRGVwZW5kZW5jeVRyZWUobm9kZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICBuYW1lOiBub2RlLm5hbWVcclxuICAgIH07XHJcbiAgICBpZiAobm9kZS5vYnNlcnZpbmcgJiYgbm9kZS5vYnNlcnZpbmcubGVuZ3RoID4gMClcclxuICAgICAgICByZXN1bHQuZGVwZW5kZW5jaWVzID0gdW5pcXVlKG5vZGUub2JzZXJ2aW5nKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRPYnNlcnZlclRyZWUodGhpbmcsIHByb3BlcnR5KSB7XHJcbiAgICByZXR1cm4gbm9kZVRvT2JzZXJ2ZXJUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XHJcbn1cclxuZnVuY3Rpb24gbm9kZVRvT2JzZXJ2ZXJUcmVlKG5vZGUpIHtcclxuICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgbmFtZTogbm9kZS5uYW1lXHJcbiAgICB9O1xyXG4gICAgaWYgKGhhc09ic2VydmVycyhub2RlKSlcclxuICAgICAgICByZXN1bHQub2JzZXJ2ZXJzID0gZ2V0T2JzZXJ2ZXJzKG5vZGUpLm1hcChub2RlVG9PYnNlcnZlclRyZWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG52YXIgZ2VuZXJhdG9ySWQgPSAwO1xyXG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIkZMT1dfQ0FOQ0VMTEVEXCI7XHJcbn1cclxuRmxvd0NhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuZnVuY3Rpb24gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcclxuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEZsb3dDYW5jZWxsYXRpb25FcnJvcjtcclxufVxyXG5mdW5jdGlvbiBmbG93KGdlbmVyYXRvcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXHJcbiAgICAgICAgZmFpbChcIkZsb3cgZXhwZWN0cyBvbmUgMSBhcmd1bWVudCBhbmQgY2Fubm90IGJlIHVzZWQgYXMgZGVjb3JhdG9yXCIpO1xyXG4gICAgdmFyIG5hbWUgPSBnZW5lcmF0b3IubmFtZSB8fCBcIjx1bm5hbWVkIGZsb3c+XCI7XHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdGovY28vYmxvYi9tYXN0ZXIvaW5kZXguanNcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgdmFyIHJ1bklkID0gKytnZW5lcmF0b3JJZDtcclxuICAgICAgICB2YXIgZ2VuID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBpbml0XCIsIGdlbmVyYXRvcikuYXBwbHkoY3R4LCBhcmdzKTtcclxuICAgICAgICB2YXIgcmVqZWN0b3I7XHJcbiAgICAgICAgdmFyIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGVwSWQgPSAwO1xyXG4gICAgICAgICAgICByZWplY3RvciA9IHJlamVjdDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHZhciByZXQ7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dChyZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHZhciByZXQ7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuLnRocm93KS5jYWxsKGdlbiwgZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQocmV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldCAmJiB0eXBlb2YgcmV0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFzeW5jIGl0ZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRoZW4obmV4dCwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0LmRvbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmV0LnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJldC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25GdWxmaWxsZWQodW5kZWZpbmVkKTsgLy8ga2ljayBvZmYgdGhlIHByb2Nlc3NcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXMuY2FuY2VsID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBjYW5jZWxcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdQcm9taXNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbFByb21pc2UocGVuZGluZ1Byb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSBibG9jayBjYW4gcmV0dXJuIChvciB5aWVsZCkgc3R1ZmYuLlxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc18xID0gZ2VuLnJldHVybih1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZWF0IGFueXRoaW5nIHRoYXQgcHJvbWlzZSB3b3VsZCBkbywgaXQncyBjYW5jZWxsZWQhXHJcbiAgICAgICAgICAgICAgICB2YXIgeWllbGRlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmVzXzEudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcclxuICAgICAgICAgICAgICAgIGNhbmNlbFByb21pc2UoeWllbGRlZFByb21pc2UpOyAvLyBtYXliZSBpdCBjYW4gYmUgY2FuY2VsbGVkIDopXHJcbiAgICAgICAgICAgICAgICAvLyByZWplY3Qgb3VyIG9yaWdpbmFsIHByb21pc2VcclxuICAgICAgICAgICAgICAgIHJlamVjdG9yKG5ldyBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdG9yKGUpOyAvLyB0aGVyZSBjb3VsZCBiZSBhIHRocm93aW5nIGZpbmFsbHkgYmxvY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNhbmNlbFByb21pc2UocHJvbWlzZSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHByb21pc2UuY2FuY2VsKCk7XHJcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UmVhZHModGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcclxuICAgIHZhciB0YXJnZXQ7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVBcnJheSh0aGluZykgfHwgaXNPYnNlcnZhYmxlVmFsdWUodGhpbmcpKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcE9ySGFuZGxlciAhPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XHJcbiAgICAgICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BPckhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoXCJFeHBlY3RlZCBvYnNlcnZhYmxlIG1hcCwgb2JqZWN0IG9yIGFycmF5IGFzIGZpcnN0IGFycmF5XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBmYWlsKFwiQW4gaW50ZXJjZXB0IHJlYWRlciB3YXMgYWxyZWFkeSBlc3RhYmxpc2hlZFwiKTtcclxuICAgIHRhcmdldC5kZWhhbmNlciA9IHR5cGVvZiBwcm9wT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wT3JIYW5kbGVyIDogaGFuZGxlcjtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGFyZ2V0LmRlaGFuY2VyID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHQodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcclxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcik7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIHByb3BPckhhbmRsZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIGhhbmRsZXIpIHtcclxuICAgIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykuaW50ZXJjZXB0KGhhbmRsZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgaGFuZGxlcikge1xyXG4gICAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkuaW50ZXJjZXB0KGhhbmRsZXIpO1xyXG59XG5cbmZ1bmN0aW9uIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXZhbHVlLiRtb2J4LnZhbHVlc1twcm9wZXJ0eV0pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgYXRvbSA9IGdldEF0b20odmFsdWUsIHByb3BlcnR5KTtcclxuICAgICAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wdXRlZCh2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxyXG4gICAgICAgIHJldHVybiBmYWlsKFwiaXNDb21wdXRlZCBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzT2JzZXJ2YWJsZVByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xyXG4gICAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXB1dGVkUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgIT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgcmV0dXJuIGZhaWwoXCJpc0NvbXB1dGVkIGV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XHJcbiAgICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BOYW1lKTtcclxufVxuXG5mdW5jdGlvbiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHZhbHVlKSB8fCBpc09ic2VydmFibGVBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKFwiaXNPYnNlcnZhYmxlKG9iamVjdCwgcHJvcGVydHlOYW1lKSBpcyBub3Qgc3VwcG9ydGVkIGZvciBhcnJheXMgYW5kIG1hcHMuIFVzZSBtYXAuaGFzIG9yIGFycmF5Lmxlbmd0aCBpbnN0ZWFkLlwiKTtcclxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YXIgbyA9IHZhbHVlLiRtb2J4O1xyXG4gICAgICAgICAgICByZXR1cm4gby52YWx1ZXMgJiYgISFvLnZhbHVlc1twcm9wZXJ0eV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcclxuICAgIHJldHVybiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgICAgICEhdmFsdWUuJG1vYnggfHxcclxuICAgICAgICBpc0F0b20odmFsdWUpIHx8XHJcbiAgICAgICAgaXNSZWFjdGlvbih2YWx1ZSkgfHxcclxuICAgICAgICBpc0NvbXB1dGVkVmFsdWUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxyXG4gICAgICAgIGZhaWwoXCJpc09ic2VydmFibGUgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc09ic2VydmFibGVQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcclxuICAgIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBpc09ic2VydmFibGVQcm9wKHZhbHVlLCBwcm9wTmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wTmFtZSAhPT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4gZmFpbChcImV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XHJcbiAgICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcE5hbWUpO1xyXG59XG5cbmZ1bmN0aW9uIGtleXMob2JqKSB7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gb2JqLiRtb2J4LmdldEtleXMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBvYmouX2tleXMuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkob2JqLmtleXMoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkgeyByZXR1cm4gaW5kZXg7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhaWwoXCIna2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcclxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldOyB9KTtcclxuICAgIH1cclxuICAgIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9iai5nZXQoa2V5KTsgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KG9iai52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWlsKFwiJ3ZhbHVlcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBba2V5LCBvYmpba2V5XV07IH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgb2JqLmdldChrZXkpXTsgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KG9iai5lbnRyaWVzKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkgeyByZXR1cm4gW2luZGV4LCBrZXldOyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWlsKFwiJ2VudHJpZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiKTtcclxufVxyXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcclxuICAgICAgICBzdGFydEJhdGNoKCk7XHJcbiAgICAgICAgdmFyIHZhbHVlc18xID0ga2V5O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleV8xIGluIHZhbHVlc18xKVxyXG4gICAgICAgICAgICAgICAgc2V0KG9iaiwga2V5XzEsIHZhbHVlc18xW2tleV8xXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBlbmRCYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcclxuICAgICAgICB2YXIgYWRtID0gb2JqLiRtb2J4O1xyXG4gICAgICAgIHZhciBleGlzdGluZ09ic2VydmFibGUgPSBhZG0udmFsdWVzW2tleV07XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICBhZG0ud3JpdGUob2JqLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmluZU9ic2VydmFibGVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUsIGFkbS5kZWZhdWx0RW5oYW5jZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XHJcbiAgICAgICAgb2JqLnNldChrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XHJcbiAgICAgICAgb2JqLmFkZChrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcclxuICAgICAgICBpbnZhcmlhbnQoa2V5ID49IDAsIFwiTm90IGEgdmFsaWQgaW5kZXg6ICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICBzdGFydEJhdGNoKCk7XHJcbiAgICAgICAgaWYgKGtleSA+PSBvYmoubGVuZ3RoKVxyXG4gICAgICAgICAgICBvYmoubGVuZ3RoID0ga2V5ICsgMTtcclxuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIGVuZEJhdGNoKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbChcIidzZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmUob2JqLCBrZXkpIHtcclxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIG9iai4kbW9ieC5yZW1vdmUoa2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XHJcbiAgICAgICAgb2JqLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcclxuICAgICAgICBvYmouZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gICAgICAgIGludmFyaWFudChrZXkgPj0gMCwgXCJOb3QgYSB2YWxpZCBpbmRleDogJ1wiICsga2V5ICsgXCInXCIpO1xyXG4gICAgICAgIG9iai5zcGxpY2Uoa2V5LCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKFwiJ3JlbW92ZSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIGtleXMob2JqKS5pbmRleE9mKGtleSkgPj0gMFxyXG4gICAgICAgIHZhciBhZG0gPSBnZXRBZG1pbmlzdHJhdGlvbihvYmopO1xyXG4gICAgICAgIGFkbS5nZXRLZXlzKCk7IC8vIG1ha2Ugc3VyZSB3ZSBnZXQgbm90aWZpZWQgb2Yga2V5IGNoYW5nZXMsIGJ1dCBmb3IgcGVyZm9ybWFuY2UsIHVzZSB0aGUgdmFsdWVzIG1hcCB0byBsb29rIHVwIGV4aXN0ZW5jZVxyXG4gICAgICAgIHJldHVybiAhIWFkbS52YWx1ZXNba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcclxuICAgICAgICByZXR1cm4ga2V5ID49IDAgJiYga2V5IDwgb2JqLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKFwiJ2hhcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldChvYmosIGtleSkge1xyXG4gICAgaWYgKCFoYXMob2JqLCBrZXkpKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBvYmouZ2V0KGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoXCInZ2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIik7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpIHtcclxuICAgIGlmICh0eXBlb2YgY2JPckZpcmUgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlKTtcclxufVxyXG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5vYnNlcnZlKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xyXG59XHJcbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XHJcbiAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5vYnNlcnZlKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xyXG59XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIGRldGVjdEN5Y2xlczogdHJ1ZSxcclxuICAgIGV4cG9ydE1hcHNBc09iamVjdHM6IHRydWUsXHJcbiAgICByZWN1cnNlRXZlcnl0aGluZzogZmFsc2VcclxufTtcclxuZnVuY3Rpb24gY2FjaGUobWFwLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5kZXRlY3RDeWNsZXMpXHJcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiB0b0pTSGVscGVyKHNvdXJjZSwgb3B0aW9ucywgX19hbHJlYWR5U2Vlbikge1xyXG4gICAgaWYgKCFvcHRpb25zLnJlY3Vyc2VFdmVyeXRoaW5nICYmICFpc09ic2VydmFibGUoc291cmNlKSlcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIC8vIERpcmVjdGx5IHJldHVybiBudWxsIGlmIHNvdXJjZSBpcyBudWxsXHJcbiAgICBpZiAoc291cmNlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gRGlyZWN0bHkgcmV0dXJuIHRoZSBEYXRlIG9iamVjdCBpdHNlbGYgaWYgY29udGFpbmVkIGluIHRoZSBvYnNlcnZhYmxlXHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVZhbHVlKHNvdXJjZSkpXHJcbiAgICAgICAgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLmdldCgpLCBvcHRpb25zLCBfX2FscmVhZHlTZWVuKTtcclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSB0cmFjayB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHNvdXJjZSkpXHJcbiAgICAgICAga2V5cyhzb3VyY2UpO1xyXG4gICAgdmFyIGRldGVjdEN5Y2xlcyA9IG9wdGlvbnMuZGV0ZWN0Q3ljbGVzID09PSB0cnVlO1xyXG4gICAgaWYgKGRldGVjdEN5Y2xlcyAmJiBzb3VyY2UgIT09IG51bGwgJiYgX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xyXG4gICAgICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkgfHwgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgdmFyIHJlc18xID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIHRvQWRkID0gc291cmNlLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRvSlNIZWxwZXIodmFsdWUsIG9wdGlvbnMsIF9fYWxyZWFkeVNlZW4pOyB9KTtcclxuICAgICAgICByZXNfMS5sZW5ndGggPSB0b0FkZC5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIHJlc18xW2ldID0gdG9BZGRbaV07XHJcbiAgICAgICAgcmV0dXJuIHJlc18xO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldChzb3VyY2UpIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpID09PSBTZXQucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwb3J0TWFwc0FzT2JqZWN0cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFyIHJlc18yID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgU2V0KCksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc18yLmFkZCh0b0pTSGVscGVyKHZhbHVlLCBvcHRpb25zLCBfX2FscmVhZHlTZWVuKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzXzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzXzMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIFtdLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNfMy5wdXNoKHRvSlNIZWxwZXIodmFsdWUsIG9wdGlvbnMsIF9fYWxyZWFkeVNlZW4pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNfMztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHNvdXJjZSkgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkgPT09IE1hcC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5leHBvcnRNYXBzQXNPYmplY3RzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzXzQgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBNYXAoKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNfNC5zZXQoa2V5LCB0b0pTSGVscGVyKHZhbHVlLCBvcHRpb25zLCBfX2FscmVhZHlTZWVuKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzXzQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzXzUgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIHt9LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJlc181W2tleV0gPSB0b0pTSGVscGVyKHZhbHVlLCBvcHRpb25zLCBfX2FscmVhZHlTZWVuKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNfNTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjayB0byB0aGUgc2l0dWF0aW9uIHRoYXQgc291cmNlIGlzIGFuIE9ic2VydmFibGVPYmplY3Qgb3IgYSBwbGFpbiBvYmplY3RcclxuICAgIHZhciByZXMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIHt9LCBvcHRpb25zKTtcclxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICByZXNba2V5XSA9IHRvSlNIZWxwZXIoc291cmNlW2tleV0sIG9wdGlvbnMsIF9fYWxyZWFkeVNlZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB0b0pTKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIilcclxuICAgICAgICBvcHRpb25zID0geyBkZXRlY3RDeWNsZXM6IG9wdGlvbnMgfTtcclxuICAgIGlmICghb3B0aW9ucylcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XHJcbiAgICBvcHRpb25zLmRldGVjdEN5Y2xlcyA9XHJcbiAgICAgICAgb3B0aW9ucy5kZXRlY3RDeWNsZXMgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IG9wdGlvbnMucmVjdXJzZUV2ZXJ5dGhpbmcgPT09IHRydWVcclxuICAgICAgICAgICAgOiBvcHRpb25zLmRldGVjdEN5Y2xlcyA9PT0gdHJ1ZTtcclxuICAgIHZhciBfX2FscmVhZHlTZWVuO1xyXG4gICAgaWYgKG9wdGlvbnMuZGV0ZWN0Q3ljbGVzKVxyXG4gICAgICAgIF9fYWxyZWFkeVNlZW4gPSBuZXcgTWFwKCk7XHJcbiAgICByZXR1cm4gdG9KU0hlbHBlcihzb3VyY2UsIG9wdGlvbnMsIF9fYWxyZWFkeVNlZW4pO1xyXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKVxyXG4gICAgICAgIGVudGVyQnJlYWtQb2ludCA9IGFyZ3MucG9wKCk7XHJcbiAgICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcclxuICAgIGlmICghZGVyaXZhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWlsKFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nID09PSBUcmFjZU1vZGUuTk9ORSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZSArIFwiJyB0cmFjaW5nIGVuYWJsZWRcIik7XHJcbiAgICB9XHJcbiAgICBkZXJpdmF0aW9uLmlzVHJhY2luZyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QXRvbUZyb21BcmdzKGFyZ3MpIHtcclxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdKTtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBdG9tKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBEdXJpbmcgYSB0cmFuc2FjdGlvbiBubyB2aWV3cyBhcmUgdXBkYXRlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2FjdGlvbi5cclxuICogVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcnVuIHN5bmNocm9ub3VzbHkgbm9uZXRoZWxlc3MuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgc29tZSByZWFjdGl2ZSBzdGF0ZVxyXG4gKiBAcmV0dXJucyBhbnkgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlICdhY3Rpb24nIHBhcmFtZXRlci5cclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGFjdGlvbiwgdGhpc0FyZykge1xyXG4gICAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkgeyB0aGlzQXJnID0gdW5kZWZpbmVkOyB9XHJcbiAgICBzdGFydEJhdGNoKCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24uYXBwbHkodGhpc0FyZyk7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBlbmRCYXRjaCgpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHdoZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCAoYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikpXHJcbiAgICAgICAgcmV0dXJuIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgYXJnMSk7XHJcbiAgICByZXR1cm4gX3doZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyIHx8IHt9KTtcclxufVxyXG5mdW5jdGlvbiBfd2hlbihwcmVkaWNhdGUsIGVmZmVjdCwgb3B0cykge1xyXG4gICAgdmFyIHRpbWVvdXRIYW5kbGU7XHJcbiAgICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXNwb3Nlci4kbW9ieC5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMub25FcnJvcilcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLm9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0KTtcclxuICAgIH1cclxuICAgIG9wdHMubmFtZSA9IG9wdHMubmFtZSB8fCBcIldoZW5AXCIgKyBnZXROZXh0SWQoKTtcclxuICAgIHZhciBlZmZlY3RBY3Rpb24gPSBjcmVhdGVBY3Rpb24ob3B0cy5uYW1lICsgXCItZWZmZWN0XCIsIGVmZmVjdCk7XHJcbiAgICB2YXIgZGlzcG9zZXIgPSBhdXRvcnVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSgpKSB7XHJcbiAgICAgICAgICAgIHIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZSlcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcclxuICAgICAgICAgICAgZWZmZWN0QWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgb3B0cyk7XHJcbiAgICByZXR1cm4gZGlzcG9zZXI7XHJcbn1cclxuZnVuY3Rpb24gd2hlblByb21pc2UocHJlZGljYXRlLCBvcHRzKSB7XHJcbiAgICBpZiAob3B0cyAmJiBvcHRzLm9uRXJyb3IpXHJcbiAgICAgICAgcmV0dXJuIGZhaWwoXCJ0aGUgb3B0aW9ucyAnb25FcnJvcicgYW5kICdwcm9taXNlJyBjYW5ub3QgYmUgY29tYmluZWRcIik7XHJcbiAgICB2YXIgY2FuY2VsO1xyXG4gICAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgZGlzcG9zZXIgPSBfd2hlbihwcmVkaWNhdGUsIHJlc29sdmUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRzKSwgeyBvbkVycm9yOiByZWplY3QgfSkpO1xyXG4gICAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZGlzcG9zZXIoKTtcclxuICAgICAgICAgICAgcmVqZWN0KFwiV0hFTl9DQU5DRUxMRURcIik7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmVzLmNhbmNlbCA9IGNhbmNlbDtcclxuICAgIHJldHVybiByZXM7XHJcbn1cblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcclxuICAgIHJldHVybiBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9ycyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzLmxlbmd0aCA+IDA7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcmNlcHRvcihpbnRlcmNlcHRhYmxlLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnMgfHwgKGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzID0gW10pO1xyXG4gICAgaW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XHJcbiAgICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IGludGVyY2VwdG9ycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKVxyXG4gICAgICAgICAgICBpbnRlcmNlcHRvcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbnRlcmNlcHRDaGFuZ2UoaW50ZXJjZXB0YWJsZSwgY2hhbmdlKSB7XHJcbiAgICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnM7XHJcbiAgICAgICAgaWYgKGludGVyY2VwdG9ycylcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcmNlcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSBpbnRlcmNlcHRvcnNbaV0oY2hhbmdlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghY2hhbmdlIHx8IGNoYW5nZS50eXBlLCBcIkludGVyY2VwdCBoYW5kbGVycyBzaG91bGQgcmV0dXJuIG5vdGhpbmcgb3IgYSBjaGFuZ2Ugb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBoYXNMaXN0ZW5lcnMobGlzdGVuYWJsZSkge1xyXG4gICAgcmV0dXJuIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoID4gMDtcclxufVxyXG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmFibGUsIGhhbmRsZXIpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVycyB8fCAobGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnMgPSBbXSk7XHJcbiAgICBsaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWR4ID0gbGlzdGVuZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpXHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhsaXN0ZW5hYmxlLCBjaGFuZ2UpIHtcclxuICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnM7XHJcbiAgICBpZiAoIWxpc3RlbmVycylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGxpc3RlbmVyc1tpXShjaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgdW50cmFja2VkRW5kKHByZXZVKTtcclxufVxuXG52YXIgTUFYX1NQTElDRV9TSVpFID0gMTAwMDA7IC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvODU5XHJcbi8vIERldGVjdHMgYnVnIGluIHNhZmFyaSA5LjEuMSAob3IgaU9TIDkgc2FmYXJpIG1vYmlsZSkuIFNlZSAjMzY0XHJcbnZhciBzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1ZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdiA9IGZhbHNlO1xyXG4gICAgdmFyIHAgPSB7fTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIjBcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5jcmVhdGUocClbXCIwXCJdID0gMTtcclxuICAgIHJldHVybiB2ID09PSBmYWxzZTtcclxufSkoKTtcclxuLyoqXHJcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcclxuICogY2FuIHJlY3ljbGUgdGhlaXIgcHJvcGVydHkgZGVmaW5pdGlvbnMsIHdoaWNoIHNpZ25pZmljYW50bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb2YgY3JlYXRpbmdcclxuICogcHJvcGVydGllcyBvbiB0aGUgZmx5LlxyXG4gKi9cclxudmFyIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSAwO1xyXG4vLyBUeXBlc2NyaXB0IHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIE9ic2VydmFibGVBcnJheSBleHRlbmRzIEFycmF5XHJcbnZhciBTdHViQXJyYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHViQXJyYXkoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3R1YkFycmF5O1xyXG59KCkpO1xyXG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHByb3RvKSB7XHJcbiAgICBpZiAodHlwZW9mIE9iamVjdFtcInNldFByb3RvdHlwZU9mXCJdICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgT2JqZWN0W1wic2V0UHJvdG90eXBlT2ZcIl0oY3Rvci5wcm90b3R5cGUsIHByb3RvKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICBjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBwcm90bztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGN0b3JbXCJwcm90b3R5cGVcIl0gPSBwcm90bztcclxuICAgIH1cclxufVxyXG5pbmhlcml0KFN0dWJBcnJheSwgQXJyYXkucHJvdG90eXBlKTtcclxuLy8gV2VleCBmcmVlemUgQXJyYXkucHJvdG90eXBlXHJcbi8vIE1ha2UgdGhlbSB3cml0ZWFibGUgYW5kIGNvbmZpZ3VyYWJsZSBpbiBwcm90b3R5cGUgY2hhaW5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvd2VleC9wdWxsLzE1MjlcclxuaWYgKE9iamVjdC5pc0Zyb3plbihBcnJheSkpIHtcclxuICAgIFtcclxuICAgICAgICBcImNvbnN0cnVjdG9yXCIsXHJcbiAgICAgICAgXCJwdXNoXCIsXHJcbiAgICAgICAgXCJzaGlmdFwiLFxyXG4gICAgICAgIFwiY29uY2F0XCIsXHJcbiAgICAgICAgXCJwb3BcIixcclxuICAgICAgICBcInVuc2hpZnRcIixcclxuICAgICAgICBcInJlcGxhY2VcIixcclxuICAgICAgICBcImZpbmRcIixcclxuICAgICAgICBcImZpbmRJbmRleFwiLFxyXG4gICAgICAgIFwic3BsaWNlXCIsXHJcbiAgICAgICAgXCJyZXZlcnNlXCIsXHJcbiAgICAgICAgXCJzb3J0XCJcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dWJBcnJheS5wcm90b3R5cGUsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogQXJyYXkucHJvdG90eXBlW2tleV1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbnZhciBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBhcnJheSwgb3duZWQpIHtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5vd25lZCA9IG93bmVkO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5sYXN0S25vd25MZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuYXRvbSA9IG5ldyBBdG9tKG5hbWUgfHwgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSk7XHJcbiAgICAgICAgdGhpcy5lbmhhbmNlciA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7IHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBuYW1lICsgXCJbLi5dXCIpOyB9O1xyXG4gICAgfVxyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLmRlaGFuY2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLmRlaGFuY2VWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XHJcbiAgICAgICAgaWYgKGZpcmVJbW1lZGlhdGVseSA9PT0gdm9pZCAwKSB7IGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcih7XHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuYXJyYXksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBhZGRlZDogdGhpcy52YWx1ZXMuc2xpY2UoKSxcclxuICAgICAgICAgICAgICAgIGFkZGVkQ291bnQ6IHRoaXMudmFsdWVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJlbW92ZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLmdldEFycmF5TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnNldEFycmF5TGVuZ3RoID0gZnVuY3Rpb24gKG5ld0xlbmd0aCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV3TGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG5ld0xlbmd0aCA8IDApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LmFycmF5XSBPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcclxuICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobmV3TGVuZ3RoID09PSBjdXJyZW50TGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoID4gY3VycmVudExlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3SXRlbXMgPSBuZXcgQXJyYXkobmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxyXG4gICAgICAgICAgICB0aGlzLnNwbGljZVdpdGhBcnJheShjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXkobmV3TGVuZ3RoLCBjdXJyZW50TGVuZ3RoIC0gbmV3TGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICAvLyBhZGRzIC8gcmVtb3ZlcyB0aGUgbmVjZXNzYXJ5IG51bWVyaWMgcHJvcGVydGllcyB0byB0aGlzIG9iamVjdFxyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnVwZGF0ZUFycmF5TGVuZ3RoID0gZnVuY3Rpb24gKG9sZExlbmd0aCwgZGVsdGEpIHtcclxuICAgICAgICBpZiAob2xkTGVuZ3RoICE9PSB0aGlzLmxhc3RLbm93bkxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIE1vZGlmaWNhdGlvbiBleGNlcHRpb246IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgYW4gb2JzZXJ2YWJsZSBhcnJheSB3YXMgY2hhbmdlZC4gRGlkIHlvdSB1c2UgcGVlaygpIHRvIGNoYW5nZSBpdD9cIik7XHJcbiAgICAgICAgdGhpcy5sYXN0S25vd25MZW5ndGggKz0gZGVsdGE7XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBvbGRMZW5ndGggKyBkZWx0YSArIDEgPiBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFKVxyXG4gICAgICAgICAgICByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUuc3BsaWNlV2l0aEFycmF5ID0gZnVuY3Rpb24gKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID4gbGVuZ3RoKVxyXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcclxuICAgICAgICBlbHNlIGlmIChpbmRleCA8IDApXHJcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICBkZWxldGVDb3VudCA9IGxlbmd0aCAtIGluZGV4O1xyXG4gICAgICAgIGVsc2UgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQgfHwgZGVsZXRlQ291bnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XHJcbiAgICAgICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIG5ld0l0ZW1zID0gRU1QVFlfQVJSQVk7XHJcbiAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcy5hcnJheSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BsaWNlXCIsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkQ291bnQ6IGRlbGV0ZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgYWRkZWQ6IG5ld0l0ZW1zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNoYW5nZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcclxuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50O1xyXG4gICAgICAgICAgICBuZXdJdGVtcyA9IGNoYW5nZS5hZGRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3SXRlbXMgPVxyXG4gICAgICAgICAgICBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuZW5oYW5jZXIodiwgdW5kZWZpbmVkKTsgfSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aERlbHRhID0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBcnJheUxlbmd0aChsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY3JlYXRlIG9yIHJlbW92ZSBuZXcgZW50cmllc1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLnNwbGljZUl0ZW1zSW50b1ZhbHVlcyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcclxuICAgICAgICBpZiAoZGVsZXRlQ291bnQgIT09IDAgfHwgbmV3SXRlbXMubGVuZ3RoICE9PSAwKVxyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFycmF5U3BsaWNlKGluZGV4LCBuZXdJdGVtcywgcmVzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVzKHJlcyk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnNwbGljZUl0ZW1zSW50b1ZhbHVlcyA9IGZ1bmN0aW9uIChpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMudmFsdWVzKS5zcGxpY2UuYXBwbHkoX2EsIF9fc3ByZWFkKFtpbmRleCwgZGVsZXRlQ291bnRdLCBuZXdJdGVtcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMudmFsdWVzLnNsaWNlKGluZGV4LCBpbmRleCArIGRlbGV0ZUNvdW50KTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlc1xyXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChuZXdJdGVtcywgdGhpcy52YWx1ZXMuc2xpY2UoaW5kZXggKyBkZWxldGVDb3VudCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZSA9IGZ1bmN0aW9uIChpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVNweSA9ICF0aGlzLm93bmVkICYmIGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuYXJyYXksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMuYXRvbS5uYW1lIH0pKTtcclxuICAgICAgICB0aGlzLmF0b20ucmVwb3J0Q2hhbmdlZCgpO1xyXG4gICAgICAgIGlmIChub3RpZnkpXHJcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xyXG4gICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5ub3RpZnlBcnJheVNwbGljZSA9IGZ1bmN0aW9uIChpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcclxuICAgICAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWQgJiYgaXNTcHlFbmFibGVkKCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcclxuICAgICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcy5hcnJheSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BsaWNlXCIsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxyXG4gICAgICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvdW50OiByZW1vdmVkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGFkZGVkQ291bnQ6IGFkZGVkLmxlbmd0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBpZiAobm90aWZ5U3B5KVxyXG4gICAgICAgICAgICBzcHlSZXBvcnRTdGFydChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hhbmdlKSwgeyBuYW1lOiB0aGlzLmF0b20ubmFtZSB9KSk7XHJcbiAgICAgICAgdGhpcy5hdG9tLnJlcG9ydENoYW5nZWQoKTtcclxuICAgICAgICAvLyBjb25mb3JtOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9vYnNlcnZlXHJcbiAgICAgICAgaWYgKG5vdGlmeSlcclxuICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XHJcbiAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uO1xyXG59KCkpO1xyXG52YXIgT2JzZXJ2YWJsZUFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9ic2VydmFibGVBcnJheSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpOyB9XHJcbiAgICAgICAgaWYgKG93bmVkID09PSB2b2lkIDApIHsgb3duZWQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgX3RoaXMsIG93bmVkKTtcclxuICAgICAgICBhZGRIaWRkZW5GaW5hbFByb3AoX3RoaXMsIFwiJG1vYnhcIiwgYWRtKTtcclxuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnNwbGljZVdpdGhBcnJheSgwLCAwLCBpbml0aWFsVmFsdWVzKTtcclxuICAgICAgICAgICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1Zykge1xyXG4gICAgICAgICAgICAvLyBTZWVtcyB0aGF0IFNhZmFyaSB3b24ndCB1c2UgbnVtZXJpYyBwcm90b3R5cGUgc2V0dGVyIHVudGlsbCBhbnkgKiBudW1lcmljIHByb3BlcnR5IGlzXHJcbiAgICAgICAgICAgIC8vIGRlZmluZWQgb24gdGhlIGluc3RhbmNlLiBBZnRlciB0aGF0IGl0IHdvcmtzIGZpbmUsIGV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSBpcyBkZWxldGVkLlxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWRtLmFycmF5LCBcIjBcIiwgRU5UUllfMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5pbnRlcmNlcHQoaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcclxuICAgICAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHsgZmlyZUltbWVkaWF0ZWx5ID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5vYnNlcnZlKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnJheXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJheXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4kbW9ieC5hdG9tLnJlcG9ydE9ic2VydmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodGhpcy5wZWVrKCksIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChpc09ic2VydmFibGVBcnJheShhKSA/IGEucGVlaygpIDogYSk7IH0pKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobmV3SXRlbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5zcGxpY2VXaXRoQXJyYXkoMCwgdGhpcy4kbW9ieC52YWx1ZXMubGVuZ3RoLCBuZXdJdGVtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGFycmF5IGJhY2sgdG8gYSAoc2hhbGxvdykgamF2YXNjcmlwdCBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBGb3IgYSBkZWVwIGNsb25lIHVzZSBtb2J4LnRvSlNcclxuICAgICAqL1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKCk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvSlMoKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy4kbW9ieC5hdG9tLnJlcG9ydE9ic2VydmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguZGVoYW5jZVZhbHVlcyh0aGlzLiRtb2J4LnZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZFxyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZywgZnJvbUluZGV4KSB7XHJcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdm9pZCAwKSB7IGZyb21JbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcclxuICAgICAgICAgICAgZGVwcmVjYXRlZChcIlRoZSBhcnJheS5maW5kIGZyb21JbmRleCBhcmd1bWVudCB0byBmaW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBhbnltb3JlIGluIHRoZSBuZXh0IG1ham9yXCIpO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmZpbmRJbmRleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoaWR4KTtcclxuICAgIH07XHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kSW5kZXhcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZywgZnJvbUluZGV4KSB7XHJcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdm9pZCAwKSB7IGZyb21JbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcclxuICAgICAgICAgICAgZGVwcmVjYXRlZChcIlRoZSBhcnJheS5maW5kSW5kZXggZnJvbUluZGV4IGFyZ3VtZW50IHRvIGZpbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGFueW1vcmUgaW4gdGhlIG5leHQgbWFqb3JcIik7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5wZWVrKCksIGwgPSBpdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGl0ZW1zW2ldLCBpLCB0aGlzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogZnVuY3Rpb25zIHRoYXQgZG8gYWx0ZXIgdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIChiYXNlZCBvbiBsaWIuZXM2LmQudHMpXHJcbiAgICAgKiBzaW5jZSB0aGVzZSBmdW5jdGlvbnMgYWx0ZXIgdGhlIGlubmVyIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIHRoZSBoYXZlIHNpZGUgZWZmZWN0cy5cclxuICAgICAqIEJlY2F1c2UgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLCB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBpbiBjb21wdXRlZCBmdW5jdGlvbixcclxuICAgICAqIGFuZCBmb3IgdGhhdCByZWFzb24gdGhlIGRvIG5vdCBjYWxsIGRlcGVuZGVuY3lTdGF0ZS5ub3RpZnlPYnNlcnZlZFxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChpbmRleCwgZGVsZXRlQ291bnQpIHtcclxuICAgICAgICB2YXIgbmV3SXRlbXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBuZXdJdGVtc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguc3BsaWNlV2l0aEFycmF5KGluZGV4KTtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiRtb2J4LnNwbGljZVdpdGhBcnJheShpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnNwbGljZVdpdGhBcnJheSA9IGZ1bmN0aW9uIChpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWRtID0gdGhpcy4kbW9ieDtcclxuICAgICAgICBhZG0uc3BsaWNlV2l0aEFycmF5KGFkbS52YWx1ZXMubGVuZ3RoLCAwLCBpdGVtcyk7XHJcbiAgICAgICAgcmV0dXJuIGFkbS52YWx1ZXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwbGljZShNYXRoLm1heCh0aGlzLiRtb2J4LnZhbHVlcy5sZW5ndGggLSAxLCAwKSwgMSlbMF07XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCwgMSlbMF07XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhZG0gPSB0aGlzLiRtb2J4O1xyXG4gICAgICAgIGFkbS5zcGxpY2VXaXRoQXJyYXkoMCwgMCwgaXRlbXMpO1xyXG4gICAgICAgIHJldHVybiBhZG0udmFsdWVzLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcmV2ZXJzZSBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XHJcbiAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgYm90aCBhICdkZXJpdmF0aW9uJyBhbmQgYSAnbXV0YXRpb24nLlxyXG4gICAgICAgIC8vIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgZGVmYXVsdCBhbmQganVzdCBtYWtlIGl0IGFuIGRlcnZpdGF0aW9uXHJcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5zbGljZSgpO1xyXG4gICAgICAgIHJldHVybiBjbG9uZS5yZXZlcnNlLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjb21wYXJlRm4pIHtcclxuICAgICAgICAvLyBzb3J0IGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcclxuICAgICAgICAvLyB3aGljaCBnb2VzIGFnYWluc3QgYWxsIGdvb2QgcHJhY3RpY2VzLiBMZXQncyBub3QgY2hhbmdlIHRoZSBhcnJheSBpbiBwbGFjZSFcclxuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLnNsaWNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lLnNvcnQuYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy4kbW9ieC5kZWhhbmNlVmFsdWVzKHRoaXMuJG1vYngudmFsdWVzKS5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZnJvbUluZGV4LCB0b0luZGV4KSB7XHJcbiAgICAgICAgZGVwcmVjYXRlZChcIm9ic2VydmFibGVBcnJheS5tb3ZlIGlzIGRlcHJlY2F0ZWQsIHVzZSAuc2xpY2UoKSAmIC5yZXBsYWNlKCkgaW5zdGVhZFwiKTtcclxuICAgICAgICBmdW5jdGlvbiBjaGVja0luZGV4KGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LmFycmF5XSBJbmRleCBvdXQgb2YgYm91bmRzOiBcIiArIGluZGV4ICsgXCIgaXMgbmVnYXRpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuJG1vYngudmFsdWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgaW5kZXggKyBcIiBpcyBub3Qgc21hbGxlciB0aGFuIFwiICsgbGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja0luZGV4LmNhbGwodGhpcywgZnJvbUluZGV4KTtcclxuICAgICAgICBjaGVja0luZGV4LmNhbGwodGhpcywgdG9JbmRleCk7XHJcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvbGRJdGVtcyA9IHRoaXMuJG1vYngudmFsdWVzO1xyXG4gICAgICAgIHZhciBuZXdJdGVtcztcclxuICAgICAgICBpZiAoZnJvbUluZGV4IDwgdG9JbmRleCkge1xyXG4gICAgICAgICAgICBuZXdJdGVtcyA9IF9fc3ByZWFkKG9sZEl0ZW1zLnNsaWNlKDAsIGZyb21JbmRleCksIG9sZEl0ZW1zLnNsaWNlKGZyb21JbmRleCArIDEsIHRvSW5kZXggKyAxKSwgW1xyXG4gICAgICAgICAgICAgICAgb2xkSXRlbXNbZnJvbUluZGV4XVxyXG4gICAgICAgICAgICBdLCBvbGRJdGVtcy5zbGljZSh0b0luZGV4ICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9JbmRleCA8IGZyb21JbmRleFxyXG4gICAgICAgICAgICBuZXdJdGVtcyA9IF9fc3ByZWFkKG9sZEl0ZW1zLnNsaWNlKDAsIHRvSW5kZXgpLCBbXHJcbiAgICAgICAgICAgICAgICBvbGRJdGVtc1tmcm9tSW5kZXhdXHJcbiAgICAgICAgICAgIF0sIG9sZEl0ZW1zLnNsaWNlKHRvSW5kZXgsIGZyb21JbmRleCksIG9sZEl0ZW1zLnNsaWNlKGZyb21JbmRleCArIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXBsYWNlKG5ld0l0ZW1zKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWUgIzczNCwgaW4gY2FzZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIHVucmVsaWFibGUuLi5cclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGltcGwgPSB0aGlzLiRtb2J4O1xyXG4gICAgICAgIGlmIChpbXBsKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGltcGwudmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaW1wbC5hdG9tLnJlcG9ydE9ic2VydmVkKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wbC5kZWhhbmNlVmFsdWUoaW1wbC52YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbbW9ieC5hcnJheV0gQXR0ZW1wdCB0byByZWFkIGFuIGFycmF5IGluZGV4IChcIiArIGluZGV4ICsgXCIpIHRoYXQgaXMgb3V0IG9mIGJvdW5kcyAoXCIgKyBpbXBsLnZhbHVlcy5sZW5ndGggKyBcIikuIFBsZWFzZSBjaGVjayBsZW5ndGggZmlyc3QuIE91dCBvZiBib3VuZCBpbmRpY2VzIHdpbGwgbm90IGJlIHRyYWNrZWQgYnkgTW9iWFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvLyBTZWUgIzczNCwgaW4gY2FzZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIHVucmVsaWFibGUuLi5cclxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhciBhZG0gPSB0aGlzLiRtb2J4O1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBhZG0udmFsdWVzO1xyXG4gICAgICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGF0IGluZGV4IGluIHJhbmdlXHJcbiAgICAgICAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKGFkbS5hdG9tKTtcclxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyhhZG0pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKGFkbSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBhZG0uZW5oYW5jZXIobmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gb2xkVmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBhZG0ubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZShpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBhZGQgYSBuZXcgaXRlbVxyXG4gICAgICAgICAgICBhZG0uc3BsaWNlV2l0aEFycmF5KGluZGV4LCAwLCBbbmV3VmFsdWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG91dCBvZiBib3VuZHNcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHMsIFwiICsgaW5kZXggKyBcIiBpcyBsYXJnZXIgdGhhbiBcIiArIHZhbHVlcy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5O1xyXG59KFN0dWJBcnJheSkpO1xyXG5kZWNsYXJlSXRlcmF0b3IoT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kbW9ieC5hdG9tLnJlcG9ydE9ic2VydmVkKCk7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcclxuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IHNlbGYubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHNlbGZbbmV4dEluZGV4KytdLCBkb25lOiBmYWxzZSB9XHJcbiAgICAgICAgICAgICAgICA6IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguZ2V0QXJyYXlMZW5ndGgoKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLiRtb2J4LnNldEFycmF5TGVuZ3RoKG5ld0xlbmd0aCk7XHJcbiAgICB9XHJcbn0pO1xyXG5hZGRIaWRkZW5Qcm9wKE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sKCksIFwiQXJyYXlcIik7XHJcbltcclxuICAgIFwiZXZlcnlcIixcclxuICAgIFwiZmlsdGVyXCIsXHJcbiAgICBcImZvckVhY2hcIixcclxuICAgIFwiaW5kZXhPZlwiLFxyXG4gICAgXCJqb2luXCIsXHJcbiAgICBcImxhc3RJbmRleE9mXCIsXHJcbiAgICBcIm1hcFwiLFxyXG4gICAgXCJyZWR1Y2VcIixcclxuICAgIFwicmVkdWNlUmlnaHRcIixcclxuICAgIFwic2xpY2VcIixcclxuICAgIFwic29tZVwiLFxyXG4gICAgXCJ0b1N0cmluZ1wiLFxyXG4gICAgXCJ0b0xvY2FsZVN0cmluZ1wiXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAoZnVuY05hbWUpIHtcclxuICAgIHZhciBiYXNlRnVuYyA9IEFycmF5LnByb3RvdHlwZVtmdW5jTmFtZV07XHJcbiAgICBpbnZhcmlhbnQodHlwZW9mIGJhc2VGdW5jID09PSBcImZ1bmN0aW9uXCIsIFwiQmFzZSBmdW5jdGlvbiBub3QgZGVmaW5lZCBvbiBBcnJheSBwcm90b3R5cGU6ICdcIiArIGZ1bmNOYW1lICsgXCInXCIpO1xyXG4gICAgYWRkSGlkZGVuUHJvcChPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBmdW5jTmFtZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBiYXNlRnVuYy5hcHBseSh0aGlzLnBlZWsoKSwgYXJndW1lbnRzKTtcclxuICAgIH0pO1xyXG59KTtcclxuLyoqXHJcbiAqIFdlIGRvbid0IHdhbnQgdGhvc2UgdG8gc2hvdyB1cCBpbiBgZm9yIChjb25zdCBrZXkgaW4gYXIpYCAuLi5cclxuICovXHJcbm1ha2VOb25FbnVtZXJhYmxlKE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIFtcclxuICAgIFwiY29uc3RydWN0b3JcIixcclxuICAgIFwiaW50ZXJjZXB0XCIsXHJcbiAgICBcIm9ic2VydmVcIixcclxuICAgIFwiY2xlYXJcIixcclxuICAgIFwiY29uY2F0XCIsXHJcbiAgICBcImdldFwiLFxyXG4gICAgXCJyZXBsYWNlXCIsXHJcbiAgICBcInRvSlNcIixcclxuICAgIFwidG9KU09OXCIsXHJcbiAgICBcInBlZWtcIixcclxuICAgIFwiZmluZFwiLFxyXG4gICAgXCJmaW5kSW5kZXhcIixcclxuICAgIFwic3BsaWNlXCIsXHJcbiAgICBcInNwbGljZVdpdGhBcnJheVwiLFxyXG4gICAgXCJwdXNoXCIsXHJcbiAgICBcInBvcFwiLFxyXG4gICAgXCJzZXRcIixcclxuICAgIFwic2hpZnRcIixcclxuICAgIFwidW5zaGlmdFwiLFxyXG4gICAgXCJyZXZlcnNlXCIsXHJcbiAgICBcInNvcnRcIixcclxuICAgIFwicmVtb3ZlXCIsXHJcbiAgICBcIm1vdmVcIixcclxuICAgIFwidG9TdHJpbmdcIixcclxuICAgIFwidG9Mb2NhbGVTdHJpbmdcIlxyXG5dKTtcclxuLy8gU2VlICMzNjRcclxudmFyIEVOVFJZXzAgPSBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcigwKTtcclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGluZGV4LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXJ2ZUFycmF5QnVmZmVyKG1heCkge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFOyBpbmRleCA8IG1heDsgaW5kZXgrKylcclxuICAgICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xyXG4gICAgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IG1heDtcclxufVxyXG5yZXNlcnZlQXJyYXlCdWZmZXIoMTAwMCk7XHJcbnZhciBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKTtcclxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHtcclxuICAgIHJldHVybiBpc09iamVjdCh0aGluZykgJiYgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbih0aGluZy4kbW9ieCk7XHJcbn1cblxudmFyIE9ic2VydmFibGVNYXBNYXJrZXIgPSB7fTtcclxudmFyIE9ic2VydmFibGVNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlTWFwKGluaXRpYWxEYXRhLCBlbmhhbmNlciwgbmFtZSkge1xyXG4gICAgICAgIGlmIChlbmhhbmNlciA9PT0gdm9pZCAwKSB7IGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyOyB9XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCk7IH1cclxuICAgICAgICB0aGlzLmVuaGFuY2VyID0gZW5oYW5jZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLiRtb2J4ID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcclxuICAgICAgICB0aGlzLl9rZXlzID0gKG5ldyBPYnNlcnZhYmxlQXJyYXkodW5kZWZpbmVkLCByZWZlcmVuY2VFbmhhbmNlciwgdGhpcy5uYW1lICsgXCIua2V5cygpXCIsIHRydWUpKTtcclxuICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vYngubWFwIHJlcXVpcmVzIE1hcCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvbWFwLmpzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2hhc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm1lcmdlKGluaXRpYWxEYXRhKTtcclxuICAgIH1cclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl9oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaGFzKGtleSk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXMoa2V5KTtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9oYXNNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICAvLyB0b2RvOiByZXBsYWNlIHdpdGggYXRvbSAoYnJlYWtpbmcgY2hhbmdlKVxyXG4gICAgICAgICAgICB2YXIgbmV3RW50cnkgPSAoZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHRoaXMuX2hhcyhrZXkpLCByZWZlcmVuY2VFbmhhbmNlciwgdGhpcy5uYW1lICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNNYXAuc2V0KGtleSwgbmV3RW50cnkpO1xyXG4gICAgICAgICAgICBvbkJlY29tZVVub2JzZXJ2ZWQobmV3RW50cnksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYXNNYXAuZGVsZXRlKGtleSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgaGFzS2V5ID0gdGhpcy5faGFzKGtleSk7XHJcbiAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IGhhc0tleSA/IFwidXBkYXRlXCIgOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbmFtZToga2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNoYW5nZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0tleSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFZhbHVlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XHJcbiAgICAgICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdGhpcy5fZGF0YS5nZXQoa2V5KS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMubmFtZSwga2V5OiBrZXkgfSkpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVIYXNNYXBFbnRyeShrZXksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gX3RoaXMuX2RhdGEuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnkpXHJcbiAgICAgICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl91cGRhdGVIYXNNYXBFbnRyeSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5faGFzTWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICBlbnRyeS5zZXROZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLl9kYXRhLmdldChrZXkpO1xyXG4gICAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XHJcbiAgICAgICAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMubmFtZSwga2V5OiBrZXkgfSkpO1xyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeSlcclxuICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5KVxyXG4gICAgICAgICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl9hZGRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVWYWx1ZShuZXdWYWx1ZSwgX3RoaXMuZW5oYW5jZXIsIF90aGlzLm5hbWUgKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhLnNldChrZXksIG9ic2VydmFibGUpO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUudmFsdWU7IC8vIHZhbHVlIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkXHJcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVIYXNNYXBFbnRyeShrZXksIHRydWUpO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMubmFtZSwga2V5OiBrZXkgfSkpO1xyXG4gICAgICAgIGlmIChub3RpZnkpXHJcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xyXG4gICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMuX2RhdGEuZ2V0KGtleSkuZ2V0KCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZSh1bmRlZmluZWQpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmRlaGFuY2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1tpdGVyYXRvclN5bWJvbCgpXSgpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBzZWxmLl9rZXlzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZTogc2VsZi5nZXQoc2VsZi5fa2V5c1tuZXh0SW5kZXgrK10pLCBkb25lOiBmYWxzZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEluZGV4IDwgc2VsZi5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VsZi5fa2V5c1tuZXh0SW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIHNlbGYuZ2V0KGtleSldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBfdGhpcy5nZXQoa2V5KSwga2V5LCBfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBNZXJnZSBhbm90aGVyIG9iamVjdCBpbnRvIHRoaXMgb2JqZWN0LCByZXR1cm5zIHRoaXMuICovXHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvdGhlcikpIHtcclxuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci50b0pTKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3RoZXIpKVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3RoZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMuc2V0KGtleSwgb3RoZXJba2V5XSk7IH0pO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSlcclxuICAgICAgICAgICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0VTNk1hcChvdGhlcikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5jb25zdHJ1Y3RvciAhPT0gTWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwoXCJDYW5ub3QgaW5pdGlhbGl6ZSBmcm9tIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gTWFwOiBcIiArIG90aGVyLmNvbnN0cnVjdG9yLm5hbWUpOyAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiBfdGhpcy5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBmYWlsKFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMuZGVsZXRlKGtleSk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRNYXAgPSBjb252ZXJ0VG9NYXAodmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG9sZEtleXMgPSBfdGhpcy5fa2V5cztcclxuICAgICAgICAgICAgdmFyIG5ld0tleXMgPSBBcnJheS5mcm9tKHJlcGxhY2VtZW50TWFwLmtleXMoKSk7XHJcbiAgICAgICAgICAgIHZhciBrZXlzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRLZXkgPSBvbGRLZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8ga2V5IG9yZGVyIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleXMubGVuZ3RoID09PSBuZXdLZXlzLmxlbmd0aCAmJiBvbGRLZXkgIT09IG5ld0tleXNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlbWVudE1hcC5oYXMob2xkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxldGUob2xkS2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBsYWNlbWVudE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXcga2V5XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9kYXRhLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5c0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGtleXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5yZXBsYWNlKG5ld0tleXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGVNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgbWFwLlxyXG4gICAgICogTm90ZSB0aGF0IGFsbCB0aGUga2V5cyBiZWluZyBzdHJpbmdpZmllZC5cclxuICAgICAqIElmIHRoZXJlIGFyZSBkdXBsaWNhdGluZyBrZXlzIGFmdGVyIGNvbnZlcnRpbmcgdGhlbSB0byBzdHJpbmdzLCBiZWhhdmlvdXIgaXMgdW5kZXRlcm1pbmVkLlxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS50b1BPSk8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzID0ge307XHJcbiAgICAgICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChyZXNbdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IHN0cmluZ2lmeUtleShrZXkpXSA9IF90aGlzLmdldChrZXkpKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IG5vbiBvYnNlcnZhYmxlIG9iamVjdCBjbG9uZSBvZiB0aGlzIG1hcC5cclxuICAgICAqIE5vdGUgdGhhdCB0aGUgdmFsdWVzIG1pZ3RoIHN0aWxsIGJlIG9ic2VydmFibGUuIEZvciBhIGRlZXAgY2xvbmUgdXNlIG1vYngudG9KUy5cclxuICAgICAqL1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJlcy5zZXQoa2V5LCBfdGhpcy5nZXQoa2V5KSk7IH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFVzZWQgYnkgSlNPTi5zdHJpbmdpZnlcclxuICAgICAgICByZXR1cm4gdGhpcy50b1BPSk8oKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5uYW1lICtcclxuICAgICAgICAgICAgXCJbeyBcIiArXHJcbiAgICAgICAgICAgIHRoaXMuX2tleXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHN0cmluZ2lmeUtleShrZXkpICsgXCI6IFwiICsgKFwiXCIgKyBfdGhpcy5nZXQoa2V5KSk7IH0pLmpvaW4oXCIsIFwiKSArXHJcbiAgICAgICAgICAgIFwiIH1dXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXHJcbiAgICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcclxuICAgICAgICBpbnZhcmlhbnQoZmlyZUltbWVkaWF0ZWx5ICE9PSB0cnVlLCBcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBtYXBzLlwiKTtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZU1hcDtcclxufSgpKTtcclxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSkge1xyXG4gICAgaWYgKGtleSAmJiBrZXkudG9TdHJpbmcpXHJcbiAgICAgICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcclxufVxyXG5kZWNsYXJlSXRlcmF0b3IoT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcclxufSk7XHJcbmFkZEhpZGRlbkZpbmFsUHJvcChPYnNlcnZhYmxlTWFwLnByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2woKSwgXCJNYXBcIik7XHJcbi8qICd2YXInIGZpeGVzIHNtYWxsLWJ1aWxkIGlzc3VlICovXHJcbnZhciBpc09ic2VydmFibGVNYXAgPSBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU1hcFwiLCBPYnNlcnZhYmxlTWFwKTtcblxudmFyIE9ic2VydmFibGVTZXRNYXJrZXIgPSB7fTtcclxudmFyIE9ic2VydmFibGVTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlU2V0KGluaXRpYWxEYXRhLCBlbmhhbmNlciwgbmFtZSkge1xyXG4gICAgICAgIGlmIChlbmhhbmNlciA9PT0gdm9pZCAwKSB7IGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyOyB9XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlU2V0QFwiICsgZ2V0TmV4dElkKCk7IH1cclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuJG1vYnggPSBPYnNlcnZhYmxlU2V0TWFya2VyO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fYXRvbSA9IGNyZWF0ZUF0b20odGhpcy5uYW1lKTtcclxuICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vYnguc2V0IHJlcXVpcmVzIFNldCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvc2V0LmpzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVuaGFuY2VyID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHsgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsIG5hbWUpOyB9O1xyXG4gICAgICAgIGlmIChpbml0aWFsRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxhY2UoaW5pdGlhbERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9ic2VydmFibGVTZXQucHJvdG90eXBlLmRlaGFuY2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9kYXRhLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUsIF90aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F0b20ucmVwb3J0T2JzZXJ2ZWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9ic2VydmFibGVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5fYXRvbSk7XHJcbiAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGlkZWFsbHksIHZhbHVlID0gY2hhbmdlLnZhbHVlIHdvdWxkIGJlIGRvbmUgaGVyZSwgc28gdGhhdCB2YWx1ZXMgY2FuIGJlXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZWQgYnkgaW50ZXJjZXB0b3IuIFNhbWUgYXBwbGllcyBmb3Igb3RoZXIgU2V0IGFuZCBNYXAgYXBpJ3MuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kYXRhLmFkZChfdGhpcy5lbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkKSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXRvbS5yZXBvcnRDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XHJcbiAgICAgICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeSlcclxuICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgICAgICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweVxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIilcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMubmFtZSB9KSk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hdG9tLnJlcG9ydENoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kYXRhLmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAobm90aWZ5KVxyXG4gICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIilcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2F0b20ucmVwb3J0T2JzZXJ2ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5oYXModGhpcy5kZWhhbmNlVmFsdWUodmFsdWUpKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBrZXlzID0gaXRlcmF0b3JUb0FycmF5KHRoaXMua2V5cygpKTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gaXRlcmF0b3JUb0FycmF5KHRoaXMudmFsdWVzKCkpO1xyXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBuZXh0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sIGRvbmU6IGZhbHNlIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gMDtcclxuICAgICAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcztcclxuICAgICAgICBpZiAodGhpcy5fZGF0YS52YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZhYmxlVmFsdWVzID0gaXRlcmF0b3JUb0FycmF5KHRoaXMuX2RhdGEudmFsdWVzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gdmFsdWVzIGZ1bmN0aW9uIGluIElFMTFcclxuICAgICAgICAgICAgb2JzZXJ2YWJsZVZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9ic2VydmFibGVWYWx1ZXMucHVzaChlKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlKG9ic2VydmFibGVWYWx1ZXNbbmV4dEluZGV4KytdKSwgZG9uZTogZmFsc2UgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogeyBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG90aGVyKSkge1xyXG4gICAgICAgICAgICBvdGhlciA9IG90aGVyLnRvSlMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuYWRkKHZhbHVlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFUzZTZXQob3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLmFkZCh2YWx1ZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGZhaWwoXCJDYW5ub3QgaW5pdGlhbGl6ZSBzZXQgZnJvbSBcIiArIG90aGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVTZXQucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgICAgIC8vIFRPRE8gJ2ZpcmVJbW1lZGlhdGVseScgY2FuIGJlIHRydWU/XHJcbiAgICAgICAgaW52YXJpYW50KGZpcmVJbW1lZGlhdGVseSAhPT0gdHJ1ZSwgXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVTZXQucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCJbIFwiICsgaXRlcmF0b3JUb0FycmF5KHRoaXMua2V5cygpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGVTZXQ7XHJcbn0oKSk7XHJcbmRlY2xhcmVJdGVyYXRvcihPYnNlcnZhYmxlU2V0LnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XHJcbn0pO1xyXG5hZGRIaWRkZW5GaW5hbFByb3AoT2JzZXJ2YWJsZVNldC5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sKCksIFwiU2V0XCIpO1xyXG52YXIgaXNPYnNlcnZhYmxlU2V0ID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5cbnZhciBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuYW1lLCBkZWZhdWx0RW5oYW5jZXIpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEVuaGFuY2VyID0gZGVmYXVsdEVuaGFuY2VyO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0ge307XHJcbiAgICB9XHJcbiAgICBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob3duZXIsIGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1trZXldLmdldCgpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob3duZXIsIGtleSwgbmV3VmFsdWUpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzW2tleV07XHJcbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmFibGUuc2V0KG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbnRlcmNlcHRcclxuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcclxuICAgICAgICAgICAgICAgIG9iamVjdDogaW5zdGFuY2UsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgLy8gbm90aWZ5IHNweSAmIG9ic2VydmVyc1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XHJcbiAgICAgICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRTdGFydChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hhbmdlKSwgeyBuYW1lOiB0aGlzLm5hbWUsIGtleToga2V5IH0pKTtcclxuICAgICAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnkpXHJcbiAgICAgICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsdWVzW2tleV0pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZW1vdmVcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0YXJ0QmF0Y2goKTtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlc1trZXldLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLnJlbW92ZShrZXkpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZXNba2V5XTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlbW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcclxuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGFuZ2UpLCB7IG5hbWU6IHRoaXMubmFtZSwga2V5OiBrZXkgfSkpO1xyXG4gICAgICAgICAgICBpZiAobm90aWZ5KVxyXG4gICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIGVuZEJhdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUuaWxsZWdhbEFjY2VzcyA9IGZ1bmN0aW9uIChvd25lciwgcHJvcE5hbWUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGhhcHBlbnMgaWYgYSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBwcm90b3R5cGUgY2hhaW4sIGJ1dCB0aGUgcHJvcGVydHkgd2FzXHJcbiAgICAgICAgICogZGVjbGFyZWQgZGlyZWN0bHkgYXMgb3duIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBFLmcuOlxyXG4gICAgICAgICAqIGNsYXNzIEEge1xyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKiBleHRlbmRPYnNlcnZhYmxlKEEucHJvdG90eXBlLCB7IHg6IDEgfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGNsYXNzQiBleHRlbnMgQSB7XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG5ldyBCKCkueClcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IGlzIHVuY2xlYXIgd2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgJ3N0YXRpYycgb3IgaW5oZXJpdGVkLlxyXG4gICAgICAgICAqIEVpdGhlciB1c2UgYGNvbnNvbGUubG9nKEEueClgXHJcbiAgICAgICAgICogb3I6IGRlY29yYXRlKEEsIHsgeDogb2JzZXJ2YWJsZSB9KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB1c2luZyBkZWNvcmF0ZSwgdGhlIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHJlZGVjbGFyZWQgYXMgb3duIHByb3BlcnR5IG9uIHRoZSBhY3R1YWwgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAnXCIgKyBwcm9wTmFtZSArIFwiJyBvZiAnXCIgKyBvd25lciArIFwiJyB3YXMgYWNjZXNzZWQgdGhyb3VnaCB0aGUgcHJvdG90eXBlIGNoYWluLiBVc2UgJ2RlY29yYXRlJyBpbnN0ZWFkIHRvIGRlY2xhcmUgdGhlIHByb3Agb3IgYWNjZXNzIGl0IHN0YXRpY2FsbHkgdGhyb3VnaCBpdCdzIG93bmVyXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXHJcbiAgICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGZpcmVJbW1lZGlhdGVseSkge1xyXG4gICAgICAgIGludmFyaWFudChmaXJlSW1tZWRpYXRlbHkgIT09IHRydWUsIFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmlyZSBpbW1lZGlhdGVseSBwcm9wZXJ0eSBmb3Igb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5pbnRlcmNlcHQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmtleXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmtleXMgPSAobmV3IE9ic2VydmFibGVBcnJheShPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnZhbHVlc1trZXldIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlOyB9KSwgcmVmZXJlbmNlRW5oYW5jZXIsIFwia2V5cyhcIiArIHRoaXMubmFtZSArIFwiKVwiLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuc2xpY2UoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBuYW1lLCBkZWZhdWx0RW5oYW5jZXIpIHtcclxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiXCI7IH1cclxuICAgIGlmIChkZWZhdWx0RW5oYW5jZXIgPT09IHZvaWQgMCkgeyBkZWZhdWx0RW5oYW5jZXIgPSBkZWVwRW5oYW5jZXI7IH1cclxuICAgIHZhciBhZG0gPSB0YXJnZXQuJG1vYng7XHJcbiAgICBpZiAoYWRtKVxyXG4gICAgICAgIHJldHVybiBhZG07XHJcbiAgICBpbnZhcmlhbnQoT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpLCBcIkNhbm5vdCBtYWtlIHRoZSBkZXNpZ25hdGVkIG9iamVjdCBvYnNlcnZhYmxlOyBpdCBpcyBub3QgZXh0ZW5zaWJsZVwiKTtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgIG5hbWUgPSAodGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYnNlcnZhYmxlT2JqZWN0XCIpICsgXCJAXCIgKyBnZXROZXh0SWQoKTtcclxuICAgIGlmICghbmFtZSlcclxuICAgICAgICBuYW1lID0gXCJPYnNlcnZhYmxlT2JqZWN0QFwiICsgZ2V0TmV4dElkKCk7XHJcbiAgICBhZG0gPSBuZXcgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldCwgbmFtZSwgZGVmYXVsdEVuaGFuY2VyKTtcclxuICAgIGFkZEhpZGRlbkZpbmFsUHJvcCh0YXJnZXQsIFwiJG1vYnhcIiwgYWRtKTtcclxuICAgIHJldHVybiBhZG07XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KHRhcmdldCwgcHJvcE5hbWUsIG5ld1ZhbHVlLCBlbmhhbmNlcikge1xyXG4gICAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpO1xyXG4gICAgYXNzZXJ0UHJvcGVydHlDb25maWd1cmFibGUodGFyZ2V0LCBwcm9wTmFtZSk7XHJcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKGFkbSkpIHtcclxuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKGFkbSwge1xyXG4gICAgICAgICAgICBvYmplY3Q6IHRhcmdldCxcclxuICAgICAgICAgICAgbmFtZTogcHJvcE5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkXCIsXHJcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghY2hhbmdlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IChhZG0udmFsdWVzW3Byb3BOYW1lXSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIGVuaGFuY2VyLCBhZG0ubmFtZSArIFwiLlwiICsgcHJvcE5hbWUsIGZhbHNlKSk7XHJcbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUudmFsdWU7IC8vIG9ic2VydmFibGVWYWx1ZSBtaWdodCBoYXZlIGNoYW5nZWQgaXRcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BOYW1lLCBnZW5lcmF0ZU9ic2VydmFibGVQcm9wQ29uZmlnKHByb3BOYW1lKSk7XHJcbiAgICBpZiAoYWRtLmtleXMpXHJcbiAgICAgICAgYWRtLmtleXMucHVzaChwcm9wTmFtZSk7XHJcbiAgICBub3RpZnlQcm9wZXJ0eUFkZGl0aW9uKGFkbSwgdGFyZ2V0LCBwcm9wTmFtZSwgbmV3VmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCAvLyB3aGljaCBvYmplY3RzIGhvbGRzIHRoZSBvYnNlcnZhYmxlIGFuZCBwcm92aWRlcyBgdGhpc2AgY29udGV4dD9cclxucHJvcE5hbWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0KTtcclxuICAgIG9wdGlvbnMubmFtZSA9IGFkbS5uYW1lICsgXCIuXCIgKyBwcm9wTmFtZTtcclxuICAgIG9wdGlvbnMuY29udGV4dCA9IHRhcmdldDtcclxuICAgIGFkbS52YWx1ZXNbcHJvcE5hbWVdID0gbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucyk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wTmFtZSwgZ2VuZXJhdGVDb21wdXRlZFByb3BDb25maWcocHJvcE5hbWUpKTtcclxufVxyXG52YXIgb2JzZXJ2YWJsZVByb3BlcnR5Q29uZmlncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbnZhciBjb21wdXRlZFByb3BlcnR5Q29uZmlncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlT2JzZXJ2YWJsZVByb3BDb25maWcocHJvcE5hbWUpIHtcclxuICAgIHJldHVybiAob2JzZXJ2YWJsZVByb3BlcnR5Q29uZmlnc1twcm9wTmFtZV0gfHxcclxuICAgICAgICAob2JzZXJ2YWJsZVByb3BlcnR5Q29uZmlnc1twcm9wTmFtZV0gPSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5yZWFkKHRoaXMsIHByb3BOYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbW9ieC53cml0ZSh0aGlzLCBwcm9wTmFtZSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWRtaW5pc3RyYXRpb25Gb3JDb21wdXRlZFByb3BPd25lcihvd25lcikge1xyXG4gICAgdmFyIGFkbSA9IG93bmVyLiRtb2J4O1xyXG4gICAgaWYgKCFhZG0pIHtcclxuICAgICAgICAvLyBiZWNhdXNlIGNvbXB1dGVkIHByb3BzIGFyZSBkZWNsYXJlZCBvbiBwcm90eSxcclxuICAgICAgICAvLyB0aGUgY3VycmVudCBpbnN0YW5jZSBtaWdodCBub3QgaGF2ZSBiZWVuIGluaXRpYWxpemVkIHlldFxyXG4gICAgICAgIGluaXRpYWxpemVJbnN0YW5jZShvd25lcik7XHJcbiAgICAgICAgcmV0dXJuIG93bmVyLiRtb2J4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFkbTtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbXB1dGVkUHJvcENvbmZpZyhwcm9wTmFtZSkge1xyXG4gICAgcmV0dXJuIChjb21wdXRlZFByb3BlcnR5Q29uZmlnc1twcm9wTmFtZV0gfHxcclxuICAgICAgICAoY29tcHV0ZWRQcm9wZXJ0eUNvbmZpZ3NbcHJvcE5hbWVdID0ge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLmNvbXB1dGVkQ29uZmlndXJhYmxlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb25Gb3JDb21wdXRlZFByb3BPd25lcih0aGlzKS5yZWFkKHRoaXMsIHByb3BOYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgZ2V0QWRtaW5pc3RyYXRpb25Gb3JDb21wdXRlZFByb3BPd25lcih0aGlzKS53cml0ZSh0aGlzLCBwcm9wTmFtZSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbihhZG0sIG9iamVjdCwga2V5LCBuZXdWYWx1ZSkge1xyXG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyhhZG0pO1xyXG4gICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xyXG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgdHlwZTogXCJhZGRcIixcclxuICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IGtleSxcclxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX19hc3NpZ24oX19hc3NpZ24oe30sIGNoYW5nZSksIHsgbmFtZTogYWRtLm5hbWUsIGtleToga2V5IH0pKTtcclxuICAgIGlmIChub3RpZnkpXHJcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKGFkbSwgY2hhbmdlKTtcclxuICAgIGlmIChub3RpZnlTcHkpXHJcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XHJcbn1cclxudmFyIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pO1xyXG5mdW5jdGlvbiBpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHtcclxuICAgIGlmIChpc09iamVjdCh0aGluZykpIHtcclxuICAgICAgICAvLyBJbml0aWFsaXplcnMgcnVuIGxhemlseSB3aGVuIHRyYW5zcGlsaW5nIHRvIGJhYmVsLCBzbyBtYWtlIHN1cmUgdGhleSBhcmUgcnVuLi4uXHJcbiAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlKHRoaW5nKTtcclxuICAgICAgICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGhpbmcuJG1vYngpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbmZ1bmN0aW9uIGdldEF0b20odGhpbmcsIHByb3BlcnR5KSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHRoaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGZhaWwoXCJJdCBpcyBub3QgcG9zc2libGUgdG8gZ2V0IGluZGV4IGF0b21zIGZyb20gYXJyYXlzXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpbmcuJG1vYnguYXRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaW5nLiRtb2J4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSkge1xyXG4gICAgICAgICAgICB2YXIgYW55VGhpbmcgPSB0aGluZztcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXRvbShhbnlUaGluZy5fa2V5cyk7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gYW55VGhpbmcuX2RhdGEuZ2V0KHByb3BlcnR5KSB8fCBhbnlUaGluZy5faGFzTWFwLmdldChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIGlmICghb2JzZXJ2YWJsZSlcclxuICAgICAgICAgICAgICAgIGZhaWwoXCJ0aGUgZW50cnkgJ1wiICsgcHJvcGVydHkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9ic2VydmFibGUgbWFwICdcIiArIGdldERlYnVnTmFtZSh0aGluZykgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0aWFsaXplcnMgcnVuIGxhemlseSB3aGVuIHRyYW5zcGlsaW5nIHRvIGJhYmVsLCBzbyBtYWtlIHN1cmUgdGhleSBhcmUgcnVuLi4uXHJcbiAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlKHRoaW5nKTtcclxuICAgICAgICBpZiAocHJvcGVydHkgJiYgIXRoaW5nLiRtb2J4KVxyXG4gICAgICAgICAgICB0aGluZ1twcm9wZXJ0eV07IC8vIFNlZSAjMTA3MlxyXG4gICAgICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcInBsZWFzZSBzcGVjaWZ5IGEgcHJvcGVydHlcIik7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpbmcuJG1vYngudmFsdWVzW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgaWYgKCFvYnNlcnZhYmxlKVxyXG4gICAgICAgICAgICAgICAgZmFpbChcIm5vIG9ic2VydmFibGUgcHJvcGVydHkgJ1wiICsgcHJvcGVydHkgKyBcIicgZm91bmQgb24gdGhlIG9ic2VydmFibGUgb2JqZWN0ICdcIiArIGdldERlYnVnTmFtZSh0aGluZykgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGluZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpbmcgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGlmIChpc1JlYWN0aW9uKHRoaW5nLiRtb2J4KSkge1xyXG4gICAgICAgICAgICAvLyBkaXNwb3NlciBmdW5jdGlvblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpbmcuJG1vYng7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhaWwoXCJDYW5ub3Qgb2J0YWluIGF0b20gZnJvbSBcIiArIHRoaW5nKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcclxuICAgIGlmICghdGhpbmcpXHJcbiAgICAgICAgZmFpbChcIkV4cGVjdGluZyBzb21lIG9iamVjdFwiKTtcclxuICAgIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xyXG4gICAgaWYgKGlzQXRvbSh0aGluZykgfHwgaXNDb21wdXRlZFZhbHVlKHRoaW5nKSB8fCBpc1JlYWN0aW9uKHRoaW5nKSlcclxuICAgICAgICByZXR1cm4gdGhpbmc7XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKVxyXG4gICAgICAgIHJldHVybiB0aGluZztcclxuICAgIC8vIEluaXRpYWxpemVycyBydW4gbGF6aWx5IHdoZW4gdHJhbnNwaWxpbmcgdG8gYmFiZWwsIHNvIG1ha2Ugc3VyZSB0aGV5IGFyZSBydW4uLi5cclxuICAgIGluaXRpYWxpemVJbnN0YW5jZSh0aGluZyk7XHJcbiAgICBpZiAodGhpbmcuJG1vYngpXHJcbiAgICAgICAgcmV0dXJuIHRoaW5nLiRtb2J4O1xyXG4gICAgZmFpbChcIkNhbm5vdCBvYnRhaW4gYWRtaW5pc3RyYXRpb24gZnJvbSBcIiArIHRoaW5nKTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWJ1Z05hbWUodGhpbmcsIHByb3BlcnR5KSB7XHJcbiAgICB2YXIgbmFtZWQ7XHJcbiAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICBuYW1lZCA9IGdldEF0b20odGhpbmcsIHByb3BlcnR5KTtcclxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykgfHwgaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKVxyXG4gICAgICAgIG5hbWVkID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZyk7IC8vIHZhbGlkIGZvciBhcnJheXMgYXMgd2VsbFxyXG4gICAgcmV0dXJuIG5hbWVkLm5hbWU7XHJcbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIGRlcHRoKSB7XHJcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IC0xOyB9XHJcbiAgICByZXR1cm4gZXEoYSwgYiwgZGVwdGgpO1xyXG59XHJcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzVjMjM3YTdjNjgyZmI2OGZkNTM3ODIwM2YwYmYyMmRjZTE2MjQ4NTQvdW5kZXJzY29yZS5qcyNMMTE4Ni1MMTI4OVxyXG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxyXG5mdW5jdGlvbiBlcShhLCBiLCBkZXB0aCwgYVN0YWNrLCBiU3RhY2spIHtcclxuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cclxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xyXG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXHJcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxyXG4gICAgaWYgKGEgIT09IGEpXHJcbiAgICAgICAgcmV0dXJuIGIgIT09IGI7XHJcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XHJcbiAgICBpZiAodHlwZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgIT0gXCJvYmplY3RcIilcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cclxuICAgIGEgPSB1bndyYXAoYSk7XHJcbiAgICBiID0gdW53cmFwKGIpO1xyXG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cclxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xyXG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xyXG4gICAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxyXG4gICAgICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjpcclxuICAgICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxyXG4gICAgICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcclxuICAgICAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcclxuICAgICAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xyXG4gICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcclxuICAgICAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cclxuICAgICAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXHJcbiAgICAgICAgICAgIGlmICgrYSAhPT0gK2EpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gK2IgIT09ICtiO1xyXG4gICAgICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xyXG4gICAgICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XHJcbiAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcclxuICAgICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxyXG4gICAgICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXHJcbiAgICAgICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cclxuICAgICAgICAgICAgcmV0dXJuICthID09PSArYjtcclxuICAgICAgICBjYXNlIFwiW29iamVjdCBTeW1ib2xdXCI6XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC52YWx1ZU9mLmNhbGwoYSkgPT09IFN5bWJvbC52YWx1ZU9mLmNhbGwoYikpO1xyXG4gICAgfVxyXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xyXG4gICAgaWYgKCFhcmVBcnJheXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXHJcbiAgICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cclxuICAgICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XHJcbiAgICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJlxyXG4gICAgICAgICAgICAhKHR5cGVvZiBhQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYkN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikgJiZcclxuICAgICAgICAgICAgKFwiY29uc3RydWN0b3JcIiBpbiBhICYmIFwiY29uc3RydWN0b3JcIiBpbiBiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRlcHRoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGVwdGggPCAwKSB7XHJcbiAgICAgICAgZGVwdGggPSAtMTtcclxuICAgIH1cclxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcclxuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxyXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxyXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxyXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xyXG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xyXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcclxuICAgICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXHJcbiAgICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKVxyXG4gICAgICAgICAgICByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICBhU3RhY2sucHVzaChhKTtcclxuICAgIGJTdGFjay5wdXNoKGIpO1xyXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXHJcbiAgICBpZiAoYXJlQXJyYXlzKSB7XHJcbiAgICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXHJcbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XHJcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcclxuICAgICAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xyXG4gICAgICAgICAgICBpZiAoIShoYXMkMShiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICBhU3RhY2sucG9wKCk7XHJcbiAgICBiU3RhY2sucG9wKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB1bndyYXAoYSkge1xyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KGEpKVxyXG4gICAgICAgIHJldHVybiBhLnBlZWsoKTtcclxuICAgIGlmIChpc0VTNk1hcChhKSB8fCBpc09ic2VydmFibGVNYXAoYSkpXHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheShhLmVudHJpZXMoKSk7XHJcbiAgICBpZiAoaXNFUzZTZXQoYSkgfHwgaXNPYnNlcnZhYmxlU2V0KGEpKVxyXG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkoYS5lbnRyaWVzKCkpO1xyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuZnVuY3Rpb24gaGFzJDEoYSwga2V5KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSk7XHJcbn1cblxuLypcclxuVGhlIG9ubHkgcmVhc29uIGZvciB0aGlzIGZpbGUgdG8gZXhpc3QgaXMgcHVyZSBob3Jyb3I6XHJcbldpdGhvdXQgaXQgcm9sbHVwIGNhbiBtYWtlIHRoZSBidW5kbGluZyBmYWlsIGF0IGFueSBwb2ludCBpbiB0aW1lOyB3aGVuIGl0IHJvbGxzIHVwIHRoZSBmaWxlcyBpbiB0aGUgd3Jvbmcgb3JkZXJcclxuaXQgd2lsbCBjYXVzZSB1bmRlZmluZWQgZXJyb3JzIChmb3IgZXhhbXBsZSBiZWNhdXNlIHN1cGVyIGNsYXNzZXMgb3IgbG9jYWwgdmFyaWFibGVzIG5vdCBiZWluZyBob3N0ZWQpLlxyXG5XaXRoIHRoaXMgZmlsZSB0aGF0IHdpbGwgc3RpbGwgaGFwcGVuLFxyXG5idXQgYXQgbGVhc3QgaW4gdGhpcyBmaWxlIHdlIGNhbiBtYWdpY2FsbHkgcmVvcmRlciB0aGUgaW1wb3J0cyB3aXRoIHRyaWFsIGFuZCBlcnJvciB1bnRpbCB0aGUgYnVpbGQgc3VjY2VlZHMgYWdhaW4uXHJcbiovXG5cbi8qKlxyXG4gKiAoYykgTWljaGVsIFdlc3RzdHJhdGUgMjAxNSAtIDIwMTlcclxuICogTUlUIExpY2Vuc2VkXHJcbiAqXHJcbiAqIFdlbGNvbWUgdG8gdGhlIG1vYnggc291cmNlcyEgVG8gZ2V0IGFuIGdsb2JhbCBvdmVydmlldyBvZiBob3cgTW9iWCBpbnRlcm5hbGx5IHdvcmtzLFxyXG4gKiB0aGlzIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydDpcclxuICogaHR0cHM6Ly9tZWRpdW0uY29tL0Btd2VzdHN0cmF0ZS9iZWNvbWluZy1mdWxseS1yZWFjdGl2ZS1hbi1pbi1kZXB0aC1leHBsYW5hdGlvbi1vZi1tb2JzZXJ2YWJsZS01NTk5NTI2MmEyNTQjLnh2Ymg2cWQ3NFxyXG4gKlxyXG4gKiBTb3VyY2UgZm9sZGVyczpcclxuICogPT09PT09PT09PT09PT09XHJcbiAqXHJcbiAqIC0gYXBpLyAgICAgTW9zdCBvZiB0aGUgcHVibGljIHN0YXRpYyBtZXRob2RzIGV4cG9zZWQgYnkgdGhlIG1vZHVsZSBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSBjb3JlLyAgICBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW9iWCBhbGdvcml0aG07IGF0b21zLCBkZXJpdmF0aW9ucywgcmVhY3Rpb25zLCBkZXBlbmRlbmN5IHRyZWVzLCBvcHRpbWl6YXRpb25zLiBDb29sIHN0dWZmIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gKiAtIHR5cGVzLyAgIEFsbCB0aGUgbWFnaWMgdGhhdCBpcyBuZWVkIHRvIGhhdmUgb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIHZhbHVlcyBpcyBpbiB0aGlzIGZvbGRlci4gSW5jbHVkaW5nIHRoZSBtb2RpZmllcnMgbGlrZSBgYXNGbGF0YC5cclxuICogLSB1dGlscy8gICBVdGlsaXR5IHN0dWZmLlxyXG4gKlxyXG4gKi9cclxudHJ5IHtcclxufVxyXG5jYXRjaCAoZSkge1xyXG4gICAgdmFyIGcgPSBnZXRHbG9iYWwoKTtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICBnLnByb2Nlc3MgPSB7fTtcclxuICAgIGcucHJvY2Vzcy5lbnYgPSB7fTtcclxufVxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gdGVzdENvZGVNaW5pZmljYXRpb24oKSB7IH1cclxuICAgIGlmICh0ZXN0Q29kZU1pbmlmaWNhdGlvbi5uYW1lICE9PSBcInRlc3RDb2RlTWluaWZpY2F0aW9uXCIgJiZcclxuICAgICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmXHJcbiAgICAgICAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52LklHTk9SRV9NT0JYX01JTklGWV9XQVJOSU5HICE9PSBcInRydWVcIikge1xyXG4gICAgICAgIC8vIHRyaWNrIHNvIGl0IGRvZXNuJ3QgZ2V0IHJlcGxhY2VkXHJcbiAgICAgICAgdmFyIHZhck5hbWUgPSBbXCJwcm9jZXNzXCIsIFwiZW52XCIsIFwiTk9ERV9FTlZcIl0uam9pbihcIi5cIik7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIHlvdSBhcmUgcnVubmluZyBhIG1pbmlmaWVkIGJ1aWxkLCBidXQgJ1wiICsgdmFyTmFtZSArIFwiJyB3YXMgbm90IHNldCB0byAncHJvZHVjdGlvbicgaW4geW91ciBidW5kbGVyLiBUaGlzIHJlc3VsdHMgaW4gYW4gdW5uZWNlc3NhcmlseSBsYXJnZSBhbmQgc2xvdyBidW5kbGVcIik7XHJcbiAgICB9XHJcbn0pKCk7XHJcbi8vIGZvcndhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG1vYngsIHNvIHRoYXQgcGFja2FnZXMgY2FuIGVhc2lseSBzdXBwb3J0IG1vYnggNCAmIDVcclxudmFyICRtb2J4ID0gXCIkbW9ieFwiO1xyXG5pZiAodHlwZW9mIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5a29nL21vYngtZGV2dG9vbHMvXHJcbiAgICBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3RNb2J4KHtcclxuICAgICAgICBzcHk6IHNweSxcclxuICAgICAgICBleHRyYXM6IHtcclxuICAgICAgICAgICAgZ2V0RGVidWdOYW1lOiBnZXREZWJ1Z05hbWVcclxuICAgICAgICB9LFxyXG4gICAgICAgICRtb2J4OiAkbW9ieFxyXG4gICAgfSk7XHJcbn1cclxuLy8gVE9ETzogcmVtb3ZlIGluIHNvbWUgZnV0dXJlIGJ1aWxkXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHZhciB3YXJuZWRBYm91dERlZmF1bHRFeHBvcnRfMSA9IGZhbHNlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCBcImRlZmF1bHRcIiwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXdhcm5lZEFib3V0RGVmYXVsdEV4cG9ydF8xKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuZWRBYm91dERlZmF1bHRFeHBvcnRfMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgTW9iWCBwYWNrYWdlIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGV4cG9ydC4gVXNlICdpbXBvcnQgeyB0aGluZyB9IGZyb20gXFxcIm1vYnhcXFwiJyAocmVjb21tZW5kZWQpIG9yICdpbXBvcnQgKiBhcyBtb2J4IGZyb20gXFxcIm1vYnhcXFwiJyBpbnN0ZWFkLlxcXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFtcclxuICAgICAgICBcImV4dHJhc1wiLFxyXG4gICAgICAgIFwiQXRvbVwiLFxyXG4gICAgICAgIFwiQmFzZUF0b21cIixcclxuICAgICAgICBcImFzRmxhdFwiLFxyXG4gICAgICAgIFwiYXNNYXBcIixcclxuICAgICAgICBcImFzUmVmZXJlbmNlXCIsXHJcbiAgICAgICAgXCJhc1N0cnVjdHVyZVwiLFxyXG4gICAgICAgIFwiYXV0b3J1bkFzeW5jXCIsXHJcbiAgICAgICAgXCJjcmVhdGVUcmFuZm9ybWVyXCIsXHJcbiAgICAgICAgXCJleHByXCIsXHJcbiAgICAgICAgXCJpc01vZGlmaWVyRGVzY3JpcHRvclwiLFxyXG4gICAgICAgIFwiaXNTdHJpY3RNb2RlRW5hYmxlZFwiLFxyXG4gICAgICAgIFwibWFwXCIsXHJcbiAgICAgICAgXCJ1c2VTdHJpY3RcIixcclxuICAgICAgICBcIndoeVJ1blwiXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsIHByb3AsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZmFpbChcIidcIiArIHByb3AgKyBcIicgaXMgbm8gbG9uZ2VyIHBhcnQgb2YgdGhlIHB1YmxpYyBNb2JYIGFwaS4gUGxlYXNlIGNvbnN1bHQgdGhlIGNoYW5nZWxvZyB0byBmaW5kIG91dCB3aGVyZSB0aGlzIGZ1bmN0aW9uYWxpdHkgd2VudFwiKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7IH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbmV4cG9ydHMuJG1vYnggPSAkbW9ieDtcbmV4cG9ydHMuRmxvd0NhbmNlbGxhdGlvbkVycm9yID0gRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xuZXhwb3J0cy5PYnNlcnZhYmxlTWFwID0gT2JzZXJ2YWJsZU1hcDtcbmV4cG9ydHMuT2JzZXJ2YWJsZVNldCA9IE9ic2VydmFibGVTZXQ7XG5leHBvcnRzLlJlYWN0aW9uID0gUmVhY3Rpb247XG5leHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzO1xuZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCA9IGFsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQ7XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNFbmQgPSBhbGxvd1N0YXRlUmVhZHNFbmQ7XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNTdGFydCA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0O1xuZXhwb3J0cy5fZW5kQWN0aW9uID0gX2VuZEFjdGlvbjtcbmV4cG9ydHMuX2dldEFkbWluaXN0cmF0aW9uID0gZ2V0QWRtaW5pc3RyYXRpb247XG5leHBvcnRzLl9nZXRHbG9iYWxTdGF0ZSA9IGdldEdsb2JhbFN0YXRlO1xuZXhwb3J0cy5faW50ZXJjZXB0UmVhZHMgPSBpbnRlcmNlcHRSZWFkcztcbmV4cG9ydHMuX2lzQ29tcHV0aW5nRGVyaXZhdGlvbiA9IGlzQ29tcHV0aW5nRGVyaXZhdGlvbjtcbmV4cG9ydHMuX3Jlc2V0R2xvYmFsU3RhdGUgPSByZXNldEdsb2JhbFN0YXRlO1xuZXhwb3J0cy5fc3RhcnRBY3Rpb24gPSBfc3RhcnRBY3Rpb247XG5leHBvcnRzLmFjdGlvbiA9IGFjdGlvbjtcbmV4cG9ydHMuYXV0b3J1biA9IGF1dG9ydW47XG5leHBvcnRzLmNvbXBhcmVyID0gY29tcGFyZXI7XG5leHBvcnRzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG5leHBvcnRzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbmV4cG9ydHMuY3JlYXRlQXRvbSA9IGNyZWF0ZUF0b207XG5leHBvcnRzLmRlY29yYXRlID0gZGVjb3JhdGU7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuZXhwb3J0cy5leHRlbmRPYnNlcnZhYmxlID0gZXh0ZW5kT2JzZXJ2YWJsZTtcbmV4cG9ydHMuZXh0ZW5kU2hhbGxvd09ic2VydmFibGUgPSBleHRlbmRTaGFsbG93T2JzZXJ2YWJsZTtcbmV4cG9ydHMuZmxvdyA9IGZsb3c7XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuZ2V0QXRvbSA9IGdldEF0b207XG5leHBvcnRzLmdldERlYnVnTmFtZSA9IGdldERlYnVnTmFtZTtcbmV4cG9ydHMuZ2V0RGVwZW5kZW5jeVRyZWUgPSBnZXREZXBlbmRlbmN5VHJlZTtcbmV4cG9ydHMuZ2V0T2JzZXJ2ZXJUcmVlID0gZ2V0T2JzZXJ2ZXJUcmVlO1xuZXhwb3J0cy5oYXMgPSBoYXM7XG5leHBvcnRzLmludGVyY2VwdCA9IGludGVyY2VwdDtcbmV4cG9ydHMuaXNBY3Rpb24gPSBpc0FjdGlvbjtcbmV4cG9ydHMuaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbmV4cG9ydHMuaXNCb3hlZE9ic2VydmFibGUgPSBpc09ic2VydmFibGVWYWx1ZTtcbmV4cG9ydHMuaXNDb21wdXRlZCA9IGlzQ29tcHV0ZWQ7XG5leHBvcnRzLmlzQ29tcHV0ZWRQcm9wID0gaXNDb21wdXRlZFByb3A7XG5leHBvcnRzLmlzRmxvd0NhbmNlbGxhdGlvbkVycm9yID0gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZTtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlQXJyYXkgPSBpc09ic2VydmFibGVBcnJheTtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlTWFwID0gaXNPYnNlcnZhYmxlTWFwO1xuZXhwb3J0cy5pc09ic2VydmFibGVPYmplY3QgPSBpc09ic2VydmFibGVPYmplY3Q7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZVByb3AgPSBpc09ic2VydmFibGVQcm9wO1xuZXhwb3J0cy5pc09ic2VydmFibGVTZXQgPSBpc09ic2VydmFibGVTZXQ7XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2ZSA9IG9ic2VydmU7XG5leHBvcnRzLm9uQmVjb21lT2JzZXJ2ZWQgPSBvbkJlY29tZU9ic2VydmVkO1xuZXhwb3J0cy5vbkJlY29tZVVub2JzZXJ2ZWQgPSBvbkJlY29tZVVub2JzZXJ2ZWQ7XG5leHBvcnRzLm9uUmVhY3Rpb25FcnJvciA9IG9uUmVhY3Rpb25FcnJvcjtcbmV4cG9ydHMucmVhY3Rpb24gPSByZWFjdGlvbjtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZXhwb3J0cy5ydW5JbkFjdGlvbiA9IHJ1bkluQWN0aW9uO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLnNweSA9IHNweTtcbmV4cG9ydHMudG9KUyA9IHRvSlM7XG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XG5leHBvcnRzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG5leHBvcnRzLnVudHJhY2tlZCA9IHVudHJhY2tlZDtcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZXhwb3J0cy53aGVuID0gd2hlbjtcbiJdfQ==