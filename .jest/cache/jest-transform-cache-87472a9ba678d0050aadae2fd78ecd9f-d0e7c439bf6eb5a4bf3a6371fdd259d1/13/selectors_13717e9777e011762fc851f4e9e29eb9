7455345023938c7f0ec8d76e80a7d214
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

exports.buildPredicate = buildPredicate;
exports.reduceTreeBySelector = reduceTreeBySelector;
exports.reduceTreesBySelector = reduceTreesBySelector;

var _rstSelectorParser = require('rst-selector-parser');

var _object = require('object.values');

var _object2 = _interopRequireDefault(_object);

var _arrayPrototype = require('array.prototype.flat');

var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

var _objectIs = require('object-is');

var _objectIs2 = _interopRequireDefault(_objectIs);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _byConstructor = require('html-element-map/byConstructor');

var _byConstructor2 = _interopRequireDefault(_byConstructor);

var _RSTTraversal = require('./RSTTraversal');

var _Utils = require('./Utils');

var _getAdapter = require('./getAdapter');

var _getAdapter2 = _interopRequireDefault(_getAdapter);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
} // our CSS selector parser instance


var parser = (0, _rstSelectorParser.createParser)(); // Combinators that allow you to chance selectors

var CHILD = 'childCombinator';
var ADJACENT_SIBLING = 'adjacentSiblingCombinator';
var GENERAL_SIBLING = 'generalSiblingCombinator';
var DESCENDANT = 'descendantCombinator'; // Selectors for targeting elements

var SELECTOR = 'selector';
var TYPE_SELECTOR = 'typeSelector';
var CLASS_SELECTOR = 'classSelector';
var ID_SELECTOR = 'idSelector';
var UNIVERSAL_SELECTOR = 'universalSelector';
var ATTRIBUTE_PRESENCE = 'attributePresenceSelector';
var ATTRIBUTE_VALUE = 'attributeValueSelector'; // @TODO we dont support these, throw if they are used

var PSEUDO_CLASS = 'pseudoClassSelector';
var PSEUDO_ELEMENT = 'pseudoElementSelector';
var EXACT_ATTRIBUTE_OPERATOR = '=';
var WHITELIST_ATTRIBUTE_OPERATOR = '~=';
var HYPHENATED_ATTRIBUTE_OPERATOR = '|=';
var PREFIX_ATTRIBUTE_OPERATOR = '^=';
var SUFFIX_ATTRIBUTE_OPERATOR = '$=';
var SUBSTRING_ATTRIBUTE_OPERATOR = '*=';

function unique(arr) {
  return [].concat(_toConsumableArray(new Set(arr)));
}
/**
 * Calls reduce on a array of nodes with the passed
 * function, returning only unique results.
 * @param {Function} fn
 * @param {Array<Node>} nodes
 */


function uniqueReduce(fn, nodes) {
  return unique(nodes.reduce(fn, []));
}
/**
 * Takes a CSS selector and returns a set of tokens parsed
 * by scalpel.
 * @param {String} selector
 */


function safelyGenerateTokens(selector) {
  try {
    return parser.parse(selector);
  } catch (err) {
    throw new Error('Failed to parse selector: ' + String(selector));
  }
}

function matchAttributeSelector(node, token) {
  var operator = token.operator,
      value = token.value,
      name = token.name;
  var nodeProps = (0, _Utils.propsOfNode)(node);
  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);

  if (descriptor && descriptor.get) {
    return false;
  }

  var nodePropValue = nodeProps[name];

  if (typeof nodePropValue === 'undefined') {
    return false;
  }

  if (token.type === ATTRIBUTE_PRESENCE) {
    return (0, _has2['default'])(nodeProps, token.name);
  } // Only the exact value operator ("=") can match non-strings


  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {
    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {
      return false;
    }
  }

  switch (operator) {
    /**
     * Represents an element with the att attribute whose value is exactly "val".
     * @example
     * [attr="val"] matches attr="val"
     */
    case EXACT_ATTRIBUTE_OPERATOR:
      return (0, _objectIs2['default'])(nodePropValue, value);

    /**
     * Represents an element with the att attribute whose value is a whitespace-separated
     * list of words, one of which is exactly
     * @example
     *  [rel~="copyright"] matches rel="copyright other"
     */

    case WHITELIST_ATTRIBUTE_OPERATOR:
      return nodePropValue.split(' ').indexOf(value) !== -1;

    /**
     * Represents an element with the att attribute, its value either being exactly the
     * value or beginning with the value immediately followed by "-"
     * @example
     * [hreflang|="en"] matches hreflang="en-US"
     */

    case HYPHENATED_ATTRIBUTE_OPERATOR:
      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');

    /**
     * Represents an element with the att attribute whose value begins with the prefix value.
     * If the value is the empty string then the selector does not represent anything.
     * @example
     * [type^="image"] matches type="imageobject"
     */

    case PREFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(0, value.length) === value;

    /**
     * Represents an element with the att attribute whose value ends with the suffix value.
     * If the value is the empty string then the selector does not represent anything.
     * @example
     * [type$="image"] matches type="imageobject"
     */

    case SUFFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(-value.length) === value;

    /**
     * Represents an element with the att attribute whose value contains at least one
     * instance of the value. If value is the empty string then the
     * selector does not represent anything.
     * @example
     * [title*="hello"] matches title="well hello there"
     */

    case SUBSTRING_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.indexOf(value) !== -1;

    default:
      throw new Error('Enzyme::Selector: Unknown attribute selector operator "' + String(operator) + '"');
  }
}

function matchPseudoSelector(node, token, root) {
  var name = token.name,
      parameters = token.parameters;

  if (name === 'not') {
    // eslint-disable-next-line no-use-before-define
    return parameters.every(function (selector) {
      return reduceTreeBySelector(selector, node).length === 0;
    });
  }

  if (name === 'empty') {
    return (0, _RSTTraversal.treeFilter)(node, function (n) {
      return n !== node;
    }).length === 0;
  }

  if (name === 'first-child') {
    var _findParentNode = (0, _RSTTraversal.findParentNode)(root, node),
        rendered = _findParentNode.rendered;

    var _rendered = _slicedToArray(rendered, 1),
        firstChild = _rendered[0];

    return firstChild === node;
  }

  if (name === 'last-child') {
    var _findParentNode2 = (0, _RSTTraversal.findParentNode)(root, node),
        _rendered2 = _findParentNode2.rendered;

    return _rendered2[_rendered2.length - 1] === node;
  }

  if (name === 'focus') {
    if (typeof document === 'undefined') {
      throw new Error('Enzyme::Selector does not support the ":focus" pseudo-element without a global `document`.');
    }

    var adapter = (0, _getAdapter2['default'])();
    /* eslint-env browser */

    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;
  }

  throw new TypeError('Enzyme::Selector does not support the "' + String(token.name) + '" pseudo-element or pseudo-class selectors.');
}
/**
 * Takes a node and a token and determines if the node
 * matches the predicate defined by the token.
 * @param {Node} node
 * @param {Token} token
 */


function nodeMatchesToken(node, token, root) {
  if (node === null || typeof node === 'string') {
    return false;
  }

  switch (token.type) {
    /**
     * Match every node
     * @example '*' matches every node
     */
    case UNIVERSAL_SELECTOR:
      return true;

    /**
     * Match against the className prop
     * @example '.active' matches <div className='active' />
     */

    case CLASS_SELECTOR:
      return (0, _RSTTraversal.hasClassName)(node, token.name);

    /**
     * Simple type matching
     * @example 'div' matches <div />
     */

    case TYPE_SELECTOR:
      return (0, _Utils.nodeHasType)(node, token.name);

    /**
     * Match against the `id` prop
     * @example '#nav' matches <ul id="nav" />
     */

    case ID_SELECTOR:
      return (0, _RSTTraversal.nodeHasId)(node, token.name);

    /**
     * Matches if an attribute is present, regardless
     * of its value
     * @example '[disabled]' matches <a disabled />
     */

    case ATTRIBUTE_PRESENCE:
      return matchAttributeSelector(node, token);

    /**
     * Matches if an attribute is present with the
     * provided value
     * @example '[data-foo=foo]' matches <div data-foo="foo" />
     */

    case ATTRIBUTE_VALUE:
      return matchAttributeSelector(node, token);

    case PSEUDO_ELEMENT:
    case PSEUDO_CLASS:
      return matchPseudoSelector(node, token, root);

    default:
      throw new Error('Unknown token type: ' + String(token.type));
  }
}
/**
 * Returns a predicate function that checks if a
 * node matches every token in the body of a selector
 * token.
 * @param {Token} token
 */


function buildPredicateFromToken(token, root) {
  return function (node) {
    return token.body.every(function (bodyToken) {
      return nodeMatchesToken(node, bodyToken, root);
    });
  };
}
/**
 * Returns whether a parsed selector is a complex selector, which
 * is defined as a selector that contains combinators.
 * @param {Array<Token>} tokens
 */


function isComplexSelector(tokens) {
  return tokens.some(function (token) {
    return token.type !== SELECTOR;
  });
}
/**
 * Takes a component constructor, object, or string representing
 * a simple selector and returns a predicate function that can
 * be applied to a single node.
 * @param {EnzymeSelector} selector
 */


function buildPredicate(selector) {
  // If the selector is a string, parse it as a simple CSS selector
  if (typeof selector === 'string') {
    var tokens = safelyGenerateTokens(selector);

    if (isComplexSelector(tokens)) {
      throw new TypeError('This method does not support complex CSS selectors');
    } // Simple selectors only have a single selector token


    return buildPredicateFromToken(tokens[0]);
  } // If the selector is an element type, check if the node's type matches


  var adapter = (0, _getAdapter2['default'])();
  var isElementType = adapter.isValidElementType ? adapter.isValidElementType(selector) : typeof selector === 'function';

  if (isElementType) {
    return function (node) {
      return adapter.matchesElementType(node, selector);
    };
  } // If the selector is an non-empty object, treat the keys/values as props


  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {
      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {
        return typeof value === 'undefined';
      });

      if (hasUndefinedValues) {
        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');
      }

      return function (node) {
        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);
      };
    }

    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');
  }

  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');
}
/**
 * Matches only nodes which are adjacent siblings (direct next sibling)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 * @param {Node} root
 */


function matchAdjacentSiblings(nodes, predicate, root) {
  return nodes.reduce(function (matches, node) {
    var parent = (0, _RSTTraversal.findParentNode)(root, node); // If there's no parent, there's no siblings

    if (!parent) {
      return matches;
    }

    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);
    var nodeIndex = parentChildren.indexOf(node);
    var adjacentSibling = parentChildren[nodeIndex + 1]; // No sibling

    if (!adjacentSibling) {
      return matches;
    }

    if (predicate(adjacentSibling)) {
      matches.push(adjacentSibling);
    }

    return matches;
  }, []);
}
/**
 * Matches only nodes which are general siblings (any sibling *after*)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 * @param {Node} root
 */


function matchGeneralSibling(nodes, predicate, root) {
  return uniqueReduce(function (matches, node) {
    var parent = (0, _RSTTraversal.findParentNode)(root, node);

    if (!parent) {
      return matches;
    }

    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);
    var nodeIndex = parentChildren.indexOf(node);
    var youngerSiblings = parentChildren.slice(nodeIndex + 1);
    return matches.concat(youngerSiblings.filter(predicate));
  }, nodes);
}
/**
 * Matches only nodes which are direct children (not grandchildren, etc.)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 */


function matchDirectChild(nodes, predicate) {
  return uniqueReduce(function (matches, node) {
    return matches.concat((0, _RSTTraversal.childrenOfNode)(node).filter(predicate));
  }, nodes);
}
/**
 * Matches all descendant nodes against a predicate,
 * returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 */


function matchDescendant(nodes, predicate) {
  return uniqueReduce(function (matches, node) {
    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));
  }, (0, _arrayPrototype2['default'])(nodes.map(_RSTTraversal.childrenOfNode)));
}
/**
 * Takes an RST and reduces it to a set of nodes matching
 * the selector. The selector can be a simple selector, which
 * is handled by `buildPredicate`, or a complex CSS selector which
 * reduceTreeBySelector parses and reduces the tree based on the combinators.
 *
 * @param {EnzymeSelector} selector
 * @param {RSTNode} root
 */


function reduceTreeBySelector(selector, root) {
  if (typeof selector !== 'string') {
    var elements = (0, _byConstructor2['default'])(selector);

    if (elements.length > 0) {
      return (0, _arrayPrototype2['default'])(elements.map(function (x) {
        return reduceTreeBySelector(x.tag, root);
      })); // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved
      // const htmlTagNames = elements.map(x => x.tag).join(', ');
      // return reduceTreeBySelector(htmlTagNames, root);
    }
  }

  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
    return (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));
  }

  var results = [];

  if (typeof selector === 'string') {
    var tokens = safelyGenerateTokens(selector);
    var index = 0;

    while (index < tokens.length) {
      var token = tokens[index];
      /**
       * There are two types of tokens in a CSS selector:
       *
       * 1. Selector tokens. These target nodes directly, like
       *    type or attribute selectors. These are easy to apply
       *    because we can traverse the tree and return only
       *    the nodes that match the predicate.
       *
       * 2. Combinator tokens. These tokens chain together
       *    selector nodes. For example > for children, or +
       *    for adjacent siblings. These are harder to match
       *    as we have to track where in the tree we are
       *    to determine if a selector node applies or not.
       */

      if (token.type === SELECTOR) {
        var predicate = buildPredicateFromToken(token, root);
        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));
      } else {
        // We can assume there always all previously matched tokens since selectors
        // cannot start with combinators.
        var type = token.type; // We assume the next token is a selector, so move the index
        // forward and build the predicate.

        index += 1;

        var _predicate = buildPredicateFromToken(tokens[index], root); // We match against only the nodes which have already been matched,
        // since a combinator is meant to refine a previous selector.


        switch (type) {
          // The + combinator
          case ADJACENT_SIBLING:
            results = matchAdjacentSiblings(results, _predicate, root);
            break;
          // The ~ combinator

          case GENERAL_SIBLING:
            results = matchGeneralSibling(results, _predicate, root);
            break;
          // The > combinator

          case CHILD:
            results = matchDirectChild(results, _predicate);
            break;
          // The ' ' (whitespace) combinator

          case DESCENDANT:
            {
              results = matchDescendant(results, _predicate);
              break;
            }

          default:
            throw new Error('Unknown combinator selector: ' + String(type));
        }
      }

      index += 1;
    }
  } else {
    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');
  }

  return results;
}

function reduceTreesBySelector(selector, roots) {
  var results = roots.map(function (n) {
    return reduceTreeBySelector(selector, n);
  });
  return unique((0, _arrayPrototype2['default'])(results, 1));
} //# sourceMappingURL=selectors.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zZWxlY3RvcnMuanMiXSwibmFtZXMiOlsicGFyc2VyIiwiQ0hJTEQiLCJBREpBQ0VOVF9TSUJMSU5HIiwiR0VORVJBTF9TSUJMSU5HIiwiREVTQ0VOREFOVCIsIlNFTEVDVE9SIiwiVFlQRV9TRUxFQ1RPUiIsIkNMQVNTX1NFTEVDVE9SIiwiSURfU0VMRUNUT1IiLCJVTklWRVJTQUxfU0VMRUNUT1IiLCJBVFRSSUJVVEVfUFJFU0VOQ0UiLCJBVFRSSUJVVEVfVkFMVUUiLCJQU0VVRE9fQ0xBU1MiLCJQU0VVRE9fRUxFTUVOVCIsIkVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUiIsIldISVRFTElTVF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJIWVBIRU5BVEVEX0FUVFJJQlVURV9PUEVSQVRPUiIsIlBSRUZJWF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJTVUZGSVhfQVRUUklCVVRFX09QRVJBVE9SIiwiU1VCU1RSSU5HX0FUVFJJQlVURV9PUEVSQVRPUiIsInVuaXF1ZSIsIm5vZGVzIiwib3BlcmF0b3IiLCJ2YWx1ZSIsIm5hbWUiLCJ0b2tlbiIsIm5vZGVQcm9wcyIsImRlc2NyaXB0b3IiLCJPYmplY3QiLCJub2RlUHJvcFZhbHVlIiwicGFyYW1ldGVycyIsInJlZHVjZVRyZWVCeVNlbGVjdG9yIiwibiIsInJlbmRlcmVkIiwiZmlyc3RDaGlsZCIsImFkYXB0ZXIiLCJkb2N1bWVudCIsIm5vZGUiLCJtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yIiwibWF0Y2hQc2V1ZG9TZWxlY3RvciIsIm5vZGVNYXRjaGVzVG9rZW4iLCJidWlsZFByZWRpY2F0ZSIsInRva2VucyIsInNhZmVseUdlbmVyYXRlVG9rZW5zIiwiaXNDb21wbGV4U2VsZWN0b3IiLCJidWlsZFByZWRpY2F0ZUZyb21Ub2tlbiIsImlzRWxlbWVudFR5cGUiLCJBcnJheSIsInNlbGVjdG9yIiwiaGFzVW5kZWZpbmVkVmFsdWVzIiwicGFyZW50IiwicGFyZW50Q2hpbGRyZW4iLCJub2RlSW5kZXgiLCJhZGphY2VudFNpYmxpbmciLCJwcmVkaWNhdGUiLCJtYXRjaGVzIiwieW91bmdlclNpYmxpbmdzIiwiY2hpbGRyZW5PZk5vZGUiLCJlbGVtZW50cyIsIngiLCJyZXN1bHRzIiwiaW5kZXgiLCJ0eXBlIiwibWF0Y2hBZGphY2VudFNpYmxpbmdzIiwibWF0Y2hHZW5lcmFsU2libGluZyIsIm1hdGNoRGlyZWN0Q2hpbGQiLCJtYXRjaERlc2NlbmRhbnQiLCJyZWR1Y2VUcmVlc0J5U2VsZWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBbVFnQnlDLGMsR0FBQUEsYztRQXFIQVYsb0IsR0FBQUEsb0I7UUErRUFvQyxxQixHQUFBQSxxQjs7QUF2Y2hCLElBQUEsa0JBQUEsR0FBQSxPQUFBLENBQUEscUJBQUEsQ0FBQTs7QUFDQSxJQUFBLE9BQUEsR0FBQSxPQUFBLENBQUEsZUFBQSxDQUFBOzs7O0FBQ0EsSUFBQSxlQUFBLEdBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUE7Ozs7QUFDQSxJQUFBLFNBQUEsR0FBQSxPQUFBLENBQUEsV0FBQSxDQUFBOzs7O0FBQ0EsSUFBQSxJQUFBLEdBQUEsT0FBQSxDQUFBLEtBQUEsQ0FBQTs7OztBQUNBLElBQUEsY0FBQSxHQUFBLE9BQUEsQ0FBQSxnQ0FBQSxDQUFBOzs7O0FBQ0EsSUFBQSxhQUFBLEdBQUEsT0FBQSxDQUFBLGdCQUFBLENBQUE7O0FBUUEsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFDQSxJQUFBLFdBQUEsR0FBQSxPQUFBLENBQUEsY0FBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUNBOzs7QUFDQSxJQUFNbkUsTUFBQUEsR0FBUyxDQUFBLEdBQUEsa0JBQUEsQ0FBZixZQUFlLEdBQWYsQyxDQUVBOztBQUNBLElBQU1DLEtBQUFBLEdBQU4saUJBQUE7QUFDQSxJQUFNQyxnQkFBQUEsR0FBTiwyQkFBQTtBQUNBLElBQU1DLGVBQUFBLEdBQU4sMEJBQUE7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QUFnRDtBQUNyRCxNQUFNRCxPQUFBQSxHQUFVLEtBQUEsQ0FBQSxHQUFBLENBQVUsVUFBQSxDQUFBLEVBQUE7QUFBQSxXQUFPN0Isb0JBQUFBLENBQUFBLFFBQUFBLEVBQVAsQ0FBT0EsQ0FBUDtBQUExQixHQUFnQixDQUFoQjtBQUNBLFNBQU9YLE1BQUFBLENBQU8sQ0FBQSxHQUFBLGdCQUFBLENBQUEsU0FBQSxDQUFBLEVBQUEsT0FBQSxFQUFkLENBQWMsQ0FBUEEsQ0FBUDtBQUNELEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQYXJzZXIgfSBmcm9tICdyc3Qtc2VsZWN0b3ItcGFyc2VyJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnb2JqZWN0LnZhbHVlcyc7XG5pbXBvcnQgZmxhdCBmcm9tICdhcnJheS5wcm90b3R5cGUuZmxhdCc7XG5pbXBvcnQgaXMgZnJvbSAnb2JqZWN0LWlzJztcbmltcG9ydCBoYXMgZnJvbSAnaGFzJztcbmltcG9ydCBlbGVtZW50c0J5Q29uc3RydWN0b3IgZnJvbSAnaHRtbC1lbGVtZW50LW1hcC9ieUNvbnN0cnVjdG9yJztcbmltcG9ydCB7XG4gIHRyZWVGaWx0ZXIsXG4gIG5vZGVIYXNJZCxcbiAgZmluZFBhcmVudE5vZGUsXG4gIG5vZGVNYXRjaGVzT2JqZWN0UHJvcHMsXG4gIGNoaWxkcmVuT2ZOb2RlLFxuICBoYXNDbGFzc05hbWUsXG59IGZyb20gJy4vUlNUVHJhdmVyc2FsJztcbmltcG9ydCB7IG5vZGVIYXNUeXBlLCBwcm9wc09mTm9kZSB9IGZyb20gJy4vVXRpbHMnO1xuaW1wb3J0IGdldEFkYXB0ZXIgZnJvbSAnLi9nZXRBZGFwdGVyJztcbi8vIG91ciBDU1Mgc2VsZWN0b3IgcGFyc2VyIGluc3RhbmNlXG5jb25zdCBwYXJzZXIgPSBjcmVhdGVQYXJzZXIoKTtcblxuLy8gQ29tYmluYXRvcnMgdGhhdCBhbGxvdyB5b3UgdG8gY2hhbmNlIHNlbGVjdG9yc1xuY29uc3QgQ0hJTEQgPSAnY2hpbGRDb21iaW5hdG9yJztcbmNvbnN0IEFESkFDRU5UX1NJQkxJTkcgPSAnYWRqYWNlbnRTaWJsaW5nQ29tYmluYXRvcic7XG5jb25zdCBHRU5FUkFMX1NJQkxJTkcgPSAnZ2VuZXJhbFNpYmxpbmdDb21iaW5hdG9yJztcbmNvbnN0IERFU0NFTkRBTlQgPSAnZGVzY2VuZGFudENvbWJpbmF0b3InO1xuXG4vLyBTZWxlY3RvcnMgZm9yIHRhcmdldGluZyBlbGVtZW50c1xuY29uc3QgU0VMRUNUT1IgPSAnc2VsZWN0b3InO1xuY29uc3QgVFlQRV9TRUxFQ1RPUiA9ICd0eXBlU2VsZWN0b3InO1xuY29uc3QgQ0xBU1NfU0VMRUNUT1IgPSAnY2xhc3NTZWxlY3Rvcic7XG5jb25zdCBJRF9TRUxFQ1RPUiA9ICdpZFNlbGVjdG9yJztcbmNvbnN0IFVOSVZFUlNBTF9TRUxFQ1RPUiA9ICd1bml2ZXJzYWxTZWxlY3Rvcic7XG5jb25zdCBBVFRSSUJVVEVfUFJFU0VOQ0UgPSAnYXR0cmlidXRlUHJlc2VuY2VTZWxlY3Rvcic7XG5jb25zdCBBVFRSSUJVVEVfVkFMVUUgPSAnYXR0cmlidXRlVmFsdWVTZWxlY3Rvcic7XG4vLyBAVE9ETyB3ZSBkb250IHN1cHBvcnQgdGhlc2UsIHRocm93IGlmIHRoZXkgYXJlIHVzZWRcbmNvbnN0IFBTRVVET19DTEFTUyA9ICdwc2V1ZG9DbGFzc1NlbGVjdG9yJztcbmNvbnN0IFBTRVVET19FTEVNRU5UID0gJ3BzZXVkb0VsZW1lbnRTZWxlY3Rvcic7XG5cbmNvbnN0IEVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUiA9ICc9JztcbmNvbnN0IFdISVRFTElTVF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnfj0nO1xuY29uc3QgSFlQSEVOQVRFRF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnfD0nO1xuY29uc3QgUFJFRklYX0FUVFJJQlVURV9PUEVSQVRPUiA9ICdePSc7XG5jb25zdCBTVUZGSVhfQVRUUklCVVRFX09QRVJBVE9SID0gJyQ9JztcbmNvbnN0IFNVQlNUUklOR19BVFRSSUJVVEVfT1BFUkFUT1IgPSAnKj0nO1xuXG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChhcnIpXTtcbn1cblxuLyoqXG4gKiBDYWxscyByZWR1Y2Ugb24gYSBhcnJheSBvZiBub2RlcyB3aXRoIHRoZSBwYXNzZWRcbiAqIGZ1bmN0aW9uLCByZXR1cm5pbmcgb25seSB1bmlxdWUgcmVzdWx0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICovXG5mdW5jdGlvbiB1bmlxdWVSZWR1Y2UoZm4sIG5vZGVzKSB7XG4gIHJldHVybiB1bmlxdWUobm9kZXMucmVkdWNlKGZuLCBbXSkpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgQ1NTIHNlbGVjdG9yIGFuZCByZXR1cm5zIGEgc2V0IG9mIHRva2VucyBwYXJzZWRcbiAqIGJ5IHNjYWxwZWwuXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqL1xuZnVuY3Rpb24gc2FmZWx5R2VuZXJhdGVUb2tlbnMoc2VsZWN0b3IpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHNlbGVjdG9yKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc2VsZWN0b3I6ICR7c2VsZWN0b3J9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hBdHRyaWJ1dGVTZWxlY3Rvcihub2RlLCB0b2tlbikge1xuICBjb25zdCB7IG9wZXJhdG9yLCB2YWx1ZSwgbmFtZSB9ID0gdG9rZW47XG4gIGNvbnN0IG5vZGVQcm9wcyA9IHByb3BzT2ZOb2RlKG5vZGUpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlUHJvcHMsIG5hbWUpO1xuICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlUHJvcFZhbHVlID0gbm9kZVByb3BzW25hbWVdO1xuICBpZiAodHlwZW9mIG5vZGVQcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBBVFRSSUJVVEVfUFJFU0VOQ0UpIHtcbiAgICByZXR1cm4gaGFzKG5vZGVQcm9wcywgdG9rZW4ubmFtZSk7XG4gIH1cbiAgLy8gT25seSB0aGUgZXhhY3QgdmFsdWUgb3BlcmF0b3IgKFwiPVwiKSBjYW4gbWF0Y2ggbm9uLXN0cmluZ3NcbiAgaWYgKHR5cGVvZiBub2RlUHJvcFZhbHVlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKG9wZXJhdG9yICE9PSBFWEFDVF9BVFRSSUJVVEVfT1BFUkFUT1IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlIHdob3NlIHZhbHVlIGlzIGV4YWN0bHkgXCJ2YWxcIi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFthdHRyPVwidmFsXCJdIG1hdGNoZXMgYXR0cj1cInZhbFwiXG4gICAgICovXG4gICAgY2FzZSBFWEFDVF9BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gaXMobm9kZVByb3BWYWx1ZSwgdmFsdWUpO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlIHdob3NlIHZhbHVlIGlzIGEgd2hpdGVzcGFjZS1zZXBhcmF0ZWRcbiAgICAgKiBsaXN0IG9mIHdvcmRzLCBvbmUgb2Ygd2hpY2ggaXMgZXhhY3RseVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIFtyZWx+PVwiY29weXJpZ2h0XCJdIG1hdGNoZXMgcmVsPVwiY29weXJpZ2h0IG90aGVyXCJcbiAgICAgKi9cbiAgICBjYXNlIFdISVRFTElTVF9BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gbm9kZVByb3BWYWx1ZS5zcGxpdCgnICcpLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSwgaXRzIHZhbHVlIGVpdGhlciBiZWluZyBleGFjdGx5IHRoZVxuICAgICAqIHZhbHVlIG9yIGJlZ2lubmluZyB3aXRoIHRoZSB2YWx1ZSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW2hyZWZsYW5nfD1cImVuXCJdIG1hdGNoZXMgaHJlZmxhbmc9XCJlbi1VU1wiXG4gICAgICovXG4gICAgY2FzZSBIWVBIRU5BVEVEX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiBub2RlUHJvcFZhbHVlID09PSB2YWx1ZSB8fCBub2RlUHJvcFZhbHVlLnN0YXJ0c1dpdGgoYCR7dmFsdWV9LWApO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlIHdob3NlIHZhbHVlIGJlZ2lucyB3aXRoIHRoZSBwcmVmaXggdmFsdWUuXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcgdGhlbiB0aGUgc2VsZWN0b3IgZG9lcyBub3QgcmVwcmVzZW50IGFueXRoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW3R5cGVePVwiaW1hZ2VcIl0gbWF0Y2hlcyB0eXBlPVwiaW1hZ2VvYmplY3RcIlxuICAgICAqL1xuICAgIGNhc2UgUFJFRklYX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBmYWxzZSA6IG5vZGVQcm9wVmFsdWUuc2xpY2UoMCwgdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWU7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgZW5kcyB3aXRoIHRoZSBzdWZmaXggdmFsdWUuXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcgdGhlbiB0aGUgc2VsZWN0b3IgZG9lcyBub3QgcmVwcmVzZW50IGFueXRoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW3R5cGUkPVwiaW1hZ2VcIl0gbWF0Y2hlcyB0eXBlPVwiaW1hZ2VvYmplY3RcIlxuICAgICAqL1xuICAgIGNhc2UgU1VGRklYX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBmYWxzZSA6IG5vZGVQcm9wVmFsdWUuc2xpY2UoLXZhbHVlLmxlbmd0aCkgPT09IHZhbHVlO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlIHdob3NlIHZhbHVlIGNvbnRhaW5zIGF0IGxlYXN0IG9uZVxuICAgICAqIGluc3RhbmNlIG9mIHRoZSB2YWx1ZS4gSWYgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZyB0aGVuIHRoZVxuICAgICAqIHNlbGVjdG9yIGRvZXMgbm90IHJlcHJlc2VudCBhbnl0aGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFt0aXRsZSo9XCJoZWxsb1wiXSBtYXRjaGVzIHRpdGxlPVwid2VsbCBoZWxsbyB0aGVyZVwiXG4gICAgICovXG4gICAgY2FzZSBTVUJTVFJJTkdfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGZhbHNlIDogbm9kZVByb3BWYWx1ZS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lOjpTZWxlY3RvcjogVW5rbm93biBhdHRyaWJ1dGUgc2VsZWN0b3Igb3BlcmF0b3IgXCIke29wZXJhdG9yfVwiYCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBtYXRjaFBzZXVkb1NlbGVjdG9yKG5vZGUsIHRva2VuLCByb290KSB7XG4gIGNvbnN0IHsgbmFtZSwgcGFyYW1ldGVycyB9ID0gdG9rZW47XG4gIGlmIChuYW1lID09PSAnbm90Jykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgIHJldHVybiBwYXJhbWV0ZXJzLmV2ZXJ5KChzZWxlY3RvcikgPT4gcmVkdWNlVHJlZUJ5U2VsZWN0b3Ioc2VsZWN0b3IsIG5vZGUpLmxlbmd0aCA9PT0gMCk7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdlbXB0eScpIHtcbiAgICByZXR1cm4gdHJlZUZpbHRlcihub2RlLCAobikgPT4gbiAhPT0gbm9kZSkubGVuZ3RoID09PSAwO1xuICB9XG4gIGlmIChuYW1lID09PSAnZmlyc3QtY2hpbGQnKSB7XG4gICAgY29uc3QgeyByZW5kZXJlZCB9ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgY29uc3QgW2ZpcnN0Q2hpbGRdID0gcmVuZGVyZWQ7XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQgPT09IG5vZGU7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdsYXN0LWNoaWxkJykge1xuICAgIGNvbnN0IHsgcmVuZGVyZWQgfSA9IGZpbmRQYXJlbnROb2RlKHJvb3QsIG5vZGUpO1xuICAgIHJldHVybiByZW5kZXJlZFtyZW5kZXJlZC5sZW5ndGggLSAxXSA9PT0gbm9kZTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2ZvY3VzJykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCI6Zm9jdXNcIiBwc2V1ZG8tZWxlbWVudCB3aXRob3V0IGEgZ2xvYmFsIGBkb2N1bWVudGAuJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKCk7XG4gICAgLyogZXNsaW50LWVudiBicm93c2VyICovXG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgYWRhcHRlci5ub2RlVG9Ib3N0Tm9kZShub2RlKSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEVuenltZTo6U2VsZWN0b3IgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCIke3Rva2VuLm5hbWV9XCIgcHNldWRvLWVsZW1lbnQgb3IgcHNldWRvLWNsYXNzIHNlbGVjdG9ycy5gKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIG5vZGUgYW5kIGEgdG9rZW4gYW5kIGRldGVybWluZXMgaWYgdGhlIG5vZGVcbiAqIG1hdGNoZXMgdGhlIHByZWRpY2F0ZSBkZWZpbmVkIGJ5IHRoZSB0b2tlbi5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAqL1xuZnVuY3Rpb24gbm9kZU1hdGNoZXNUb2tlbihub2RlLCB0b2tlbiwgcm9vdCkge1xuICBpZiAobm9kZSA9PT0gbnVsbCB8fCB0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggZXZlcnkgbm9kZVxuICAgICAqIEBleGFtcGxlICcqJyBtYXRjaGVzIGV2ZXJ5IG5vZGVcbiAgICAgKi9cbiAgICBjYXNlIFVOSVZFUlNBTF9TRUxFQ1RPUjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIC8qKlxuICAgICAqIE1hdGNoIGFnYWluc3QgdGhlIGNsYXNzTmFtZSBwcm9wXG4gICAgICogQGV4YW1wbGUgJy5hY3RpdmUnIG1hdGNoZXMgPGRpdiBjbGFzc05hbWU9J2FjdGl2ZScgLz5cbiAgICAgKi9cbiAgICBjYXNlIENMQVNTX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIGhhc0NsYXNzTmFtZShub2RlLCB0b2tlbi5uYW1lKTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgdHlwZSBtYXRjaGluZ1xuICAgICAqIEBleGFtcGxlICdkaXYnIG1hdGNoZXMgPGRpdiAvPlxuICAgICAqL1xuICAgIGNhc2UgVFlQRV9TRUxFQ1RPUjpcbiAgICAgIHJldHVybiBub2RlSGFzVHlwZShub2RlLCB0b2tlbi5uYW1lKTtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBhZ2FpbnN0IHRoZSBgaWRgIHByb3BcbiAgICAgKiBAZXhhbXBsZSAnI25hdicgbWF0Y2hlcyA8dWwgaWQ9XCJuYXZcIiAvPlxuICAgICAqL1xuICAgIGNhc2UgSURfU0VMRUNUT1I6XG4gICAgICByZXR1cm4gbm9kZUhhc0lkKG5vZGUsIHRva2VuLm5hbWUpO1xuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgaWYgYW4gYXR0cmlidXRlIGlzIHByZXNlbnQsIHJlZ2FyZGxlc3NcbiAgICAgKiBvZiBpdHMgdmFsdWVcbiAgICAgKiBAZXhhbXBsZSAnW2Rpc2FibGVkXScgbWF0Y2hlcyA8YSBkaXNhYmxlZCAvPlxuICAgICAqL1xuICAgIGNhc2UgQVRUUklCVVRFX1BSRVNFTkNFOlxuICAgICAgcmV0dXJuIG1hdGNoQXR0cmlidXRlU2VsZWN0b3Iobm9kZSwgdG9rZW4pO1xuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgaWYgYW4gYXR0cmlidXRlIGlzIHByZXNlbnQgd2l0aCB0aGVcbiAgICAgKiBwcm92aWRlZCB2YWx1ZVxuICAgICAqIEBleGFtcGxlICdbZGF0YS1mb289Zm9vXScgbWF0Y2hlcyA8ZGl2IGRhdGEtZm9vPVwiZm9vXCIgLz5cbiAgICAgKi9cbiAgICBjYXNlIEFUVFJJQlVURV9WQUxVRTpcbiAgICAgIHJldHVybiBtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yKG5vZGUsIHRva2VuKTtcbiAgICBjYXNlIFBTRVVET19FTEVNRU5UOlxuICAgIGNhc2UgUFNFVURPX0NMQVNTOlxuICAgICAgcmV0dXJuIG1hdGNoUHNldWRvU2VsZWN0b3Iobm9kZSwgdG9rZW4sIHJvb3QpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdG9rZW4gdHlwZTogJHt0b2tlbi50eXBlfWApO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhXG4gKiBub2RlIG1hdGNoZXMgZXZlcnkgdG9rZW4gaW4gdGhlIGJvZHkgb2YgYSBzZWxlY3RvclxuICogdG9rZW4uXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICovXG5mdW5jdGlvbiBidWlsZFByZWRpY2F0ZUZyb21Ub2tlbih0b2tlbiwgcm9vdCkge1xuICByZXR1cm4gKG5vZGUpID0+IHRva2VuLmJvZHkuZXZlcnkoKGJvZHlUb2tlbikgPT4gbm9kZU1hdGNoZXNUb2tlbihub2RlLCBib2R5VG9rZW4sIHJvb3QpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBwYXJzZWQgc2VsZWN0b3IgaXMgYSBjb21wbGV4IHNlbGVjdG9yLCB3aGljaFxuICogaXMgZGVmaW5lZCBhcyBhIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgY29tYmluYXRvcnMuXG4gKiBAcGFyYW0ge0FycmF5PFRva2VuPn0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGlzQ29tcGxleFNlbGVjdG9yKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiB0b2tlbi50eXBlICE9PSBTRUxFQ1RPUik7XG59XG5cblxuLyoqXG4gKiBUYWtlcyBhIGNvbXBvbmVudCBjb25zdHJ1Y3Rvciwgb2JqZWN0LCBvciBzdHJpbmcgcmVwcmVzZW50aW5nXG4gKiBhIHNpbXBsZSBzZWxlY3RvciBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IGNhblxuICogYmUgYXBwbGllZCB0byBhIHNpbmdsZSBub2RlLlxuICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKSB7XG4gIC8vIElmIHRoZSBzZWxlY3RvciBpcyBhIHN0cmluZywgcGFyc2UgaXQgYXMgYSBzaW1wbGUgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdG9rZW5zID0gc2FmZWx5R2VuZXJhdGVUb2tlbnMoc2VsZWN0b3IpO1xuICAgIGlmIChpc0NvbXBsZXhTZWxlY3Rvcih0b2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXggQ1NTIHNlbGVjdG9ycycpO1xuICAgIH1cbiAgICAvLyBTaW1wbGUgc2VsZWN0b3JzIG9ubHkgaGF2ZSBhIHNpbmdsZSBzZWxlY3RvciB0b2tlblxuICAgIHJldHVybiBidWlsZFByZWRpY2F0ZUZyb21Ub2tlbih0b2tlbnNbMF0pO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIGFuIGVsZW1lbnQgdHlwZSwgY2hlY2sgaWYgdGhlIG5vZGUncyB0eXBlIG1hdGNoZXNcbiAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIoKTtcbiAgY29uc3QgaXNFbGVtZW50VHlwZSA9IGFkYXB0ZXIuaXNWYWxpZEVsZW1lbnRUeXBlXG4gICAgPyBhZGFwdGVyLmlzVmFsaWRFbGVtZW50VHlwZShzZWxlY3RvcilcbiAgICA6IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gKG5vZGUpID0+IGFkYXB0ZXIubWF0Y2hlc0VsZW1lbnRUeXBlKG5vZGUsIHNlbGVjdG9yKTtcbiAgfVxuICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgYW4gbm9uLWVtcHR5IG9iamVjdCwgdHJlYXQgdGhlIGtleXMvdmFsdWVzIGFzIHByb3BzXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGVjdG9yKSAmJiBzZWxlY3RvciAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhzZWxlY3RvcikubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaGFzVW5kZWZpbmVkVmFsdWVzID0gdmFsdWVzKHNlbGVjdG9yKS5zb21lKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyk7XG4gICAgICBpZiAoaGFzVW5kZWZpbmVkVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6UHJvcHMgY2Fu4oCZdCBoYXZlIGB1bmRlZmluZWRgIHZhbHVlcy4gVHJ5IHVzaW5nIOKAmGZpbmRXaGVyZSgp4oCZIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG5vZGUpID0+IG5vZGVNYXRjaGVzT2JqZWN0UHJvcHMobm9kZSwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbnp5bWU6OlNlbGVjdG9yIGRvZXMgbm90IHN1cHBvcnQgYW4gYXJyYXksIG51bGwsIG9yIGVtcHR5IG9iamVjdCBhcyBhIHNlbGVjdG9yJyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbnp5bWU6OlNlbGVjdG9yIGV4cGVjdHMgYSBzdHJpbmcsIG9iamVjdCwgb3IgdmFsaWQgZWxlbWVudCB0eXBlIChDb21wb25lbnQgQ29uc3RydWN0b3IpJyk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyBvbmx5IG5vZGVzIHdoaWNoIGFyZSBhZGphY2VudCBzaWJsaW5ncyAoZGlyZWN0IG5leHQgc2libGluZylcbiAqIGFnYWluc3QgYSBwcmVkaWNhdGUsIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICogQHBhcmFtIHtOb2RlfSByb290XG4gKi9cbmZ1bmN0aW9uIG1hdGNoQWRqYWNlbnRTaWJsaW5ncyhub2RlcywgcHJlZGljYXRlLCByb290KSB7XG4gIHJldHVybiBub2Rlcy5yZWR1Y2UoKG1hdGNoZXMsIG5vZGUpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBmaW5kUGFyZW50Tm9kZShyb290LCBub2RlKTtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgdGhlcmUncyBubyBzaWJsaW5nc1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbk9mTm9kZShwYXJlbnQpO1xuICAgIGNvbnN0IG5vZGVJbmRleCA9IHBhcmVudENoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgY29uc3QgYWRqYWNlbnRTaWJsaW5nID0gcGFyZW50Q2hpbGRyZW5bbm9kZUluZGV4ICsgMV07XG4gICAgLy8gTm8gc2libGluZ1xuICAgIGlmICghYWRqYWNlbnRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG4gICAgaWYgKHByZWRpY2F0ZShhZGphY2VudFNpYmxpbmcpKSB7XG4gICAgICBtYXRjaGVzLnB1c2goYWRqYWNlbnRTaWJsaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIG9ubHkgbm9kZXMgd2hpY2ggYXJlIGdlbmVyYWwgc2libGluZ3MgKGFueSBzaWJsaW5nICphZnRlciopXG4gKiBhZ2FpbnN0IGEgcHJlZGljYXRlLCByZXR1cm5pbmcgdGhvc2UgdGhhdCBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdFxuICovXG5mdW5jdGlvbiBtYXRjaEdlbmVyYWxTaWJsaW5nKG5vZGVzLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgcmV0dXJuIHVuaXF1ZVJlZHVjZSgobWF0Y2hlcywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnROb2RlKHJvb3QsIG5vZGUpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbk9mTm9kZShwYXJlbnQpO1xuICAgIGNvbnN0IG5vZGVJbmRleCA9IHBhcmVudENoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgY29uc3QgeW91bmdlclNpYmxpbmdzID0gcGFyZW50Q2hpbGRyZW4uc2xpY2Uobm9kZUluZGV4ICsgMSk7XG4gICAgcmV0dXJuIG1hdGNoZXMuY29uY2F0KHlvdW5nZXJTaWJsaW5ncy5maWx0ZXIocHJlZGljYXRlKSk7XG4gIH0sIG5vZGVzKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIG9ubHkgbm9kZXMgd2hpY2ggYXJlIGRpcmVjdCBjaGlsZHJlbiAobm90IGdyYW5kY2hpbGRyZW4sIGV0Yy4pXG4gKiBhZ2FpbnN0IGEgcHJlZGljYXRlLCByZXR1cm5pbmcgdGhvc2UgdGhhdCBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hEaXJlY3RDaGlsZChub2RlcywgcHJlZGljYXRlKSB7XG4gIHJldHVybiB1bmlxdWVSZWR1Y2UoXG4gICAgKG1hdGNoZXMsIG5vZGUpID0+IG1hdGNoZXMuY29uY2F0KGNoaWxkcmVuT2ZOb2RlKG5vZGUpLmZpbHRlcihwcmVkaWNhdGUpKSxcbiAgICBub2RlcyxcbiAgKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIGFsbCBkZXNjZW5kYW50IG5vZGVzIGFnYWluc3QgYSBwcmVkaWNhdGUsXG4gKiByZXR1cm5pbmcgdGhvc2UgdGhhdCBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hEZXNjZW5kYW50KG5vZGVzLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHVuaXF1ZVJlZHVjZShcbiAgICAobWF0Y2hlcywgbm9kZSkgPT4gbWF0Y2hlcy5jb25jYXQodHJlZUZpbHRlcihub2RlLCBwcmVkaWNhdGUpKSxcbiAgICBmbGF0KG5vZGVzLm1hcChjaGlsZHJlbk9mTm9kZSkpLFxuICApO1xufVxuXG4vKipcbiAqIFRha2VzIGFuIFJTVCBhbmQgcmVkdWNlcyBpdCB0byBhIHNldCBvZiBub2RlcyBtYXRjaGluZ1xuICogdGhlIHNlbGVjdG9yLiBUaGUgc2VsZWN0b3IgY2FuIGJlIGEgc2ltcGxlIHNlbGVjdG9yLCB3aGljaFxuICogaXMgaGFuZGxlZCBieSBgYnVpbGRQcmVkaWNhdGVgLCBvciBhIGNvbXBsZXggQ1NTIHNlbGVjdG9yIHdoaWNoXG4gKiByZWR1Y2VUcmVlQnlTZWxlY3RvciBwYXJzZXMgYW5kIHJlZHVjZXMgdGhlIHRyZWUgYmFzZWQgb24gdGhlIGNvbWJpbmF0b3JzLlxuICpcbiAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1JTVE5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVRyZWVCeVNlbGVjdG9yKHNlbGVjdG9yLCByb290KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBlbGVtZW50c0J5Q29uc3RydWN0b3Ioc2VsZWN0b3IpO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmxhdChlbGVtZW50cy5tYXAoKHgpID0+IHJlZHVjZVRyZWVCeVNlbGVjdG9yKHgudGFnLCByb290KSkpO1xuXG4gICAgICAvLyB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9hd2VhcnkvcnN0LXNlbGVjdG9yLXBhcnNlci9pc3N1ZXMvMTUgaXMgcmVzb2x2ZWRcbiAgICAgIC8vIGNvbnN0IGh0bWxUYWdOYW1lcyA9IGVsZW1lbnRzLm1hcCh4ID0+IHgudGFnKS5qb2luKCcsICcpO1xuICAgICAgLy8gcmV0dXJuIHJlZHVjZVRyZWVCeVNlbGVjdG9yKGh0bWxUYWdOYW1lcywgcm9vdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRyZWVGaWx0ZXIocm9vdCwgYnVpbGRQcmVkaWNhdGUoc2VsZWN0b3IpKTtcbiAgfVxuXG4gIGxldCByZXN1bHRzID0gW107XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdG9rZW5zID0gc2FmZWx5R2VuZXJhdGVUb2tlbnMoc2VsZWN0b3IpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHRva2VucyBpbiBhIENTUyBzZWxlY3RvcjpcbiAgICAgICAqXG4gICAgICAgKiAxLiBTZWxlY3RvciB0b2tlbnMuIFRoZXNlIHRhcmdldCBub2RlcyBkaXJlY3RseSwgbGlrZVxuICAgICAgICogICAgdHlwZSBvciBhdHRyaWJ1dGUgc2VsZWN0b3JzLiBUaGVzZSBhcmUgZWFzeSB0byBhcHBseVxuICAgICAgICogICAgYmVjYXVzZSB3ZSBjYW4gdHJhdmVyc2UgdGhlIHRyZWUgYW5kIHJldHVybiBvbmx5XG4gICAgICAgKiAgICB0aGUgbm9kZXMgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlLlxuICAgICAgICpcbiAgICAgICAqIDIuIENvbWJpbmF0b3IgdG9rZW5zLiBUaGVzZSB0b2tlbnMgY2hhaW4gdG9nZXRoZXJcbiAgICAgICAqICAgIHNlbGVjdG9yIG5vZGVzLiBGb3IgZXhhbXBsZSA+IGZvciBjaGlsZHJlbiwgb3IgK1xuICAgICAgICogICAgZm9yIGFkamFjZW50IHNpYmxpbmdzLiBUaGVzZSBhcmUgaGFyZGVyIHRvIG1hdGNoXG4gICAgICAgKiAgICBhcyB3ZSBoYXZlIHRvIHRyYWNrIHdoZXJlIGluIHRoZSB0cmVlIHdlIGFyZVxuICAgICAgICogICAgdG8gZGV0ZXJtaW5lIGlmIGEgc2VsZWN0b3Igbm9kZSBhcHBsaWVzIG9yIG5vdC5cbiAgICAgICAqL1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFNFTEVDVE9SKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2VuLCByb290KTtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHRyZWVGaWx0ZXIocm9vdCwgcHJlZGljYXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBjYW4gYXNzdW1lIHRoZXJlIGFsd2F5cyBhbGwgcHJldmlvdXNseSBtYXRjaGVkIHRva2VucyBzaW5jZSBzZWxlY3RvcnNcbiAgICAgICAgLy8gY2Fubm90IHN0YXJ0IHdpdGggY29tYmluYXRvcnMuXG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gdG9rZW47XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgbmV4dCB0b2tlbiBpcyBhIHNlbGVjdG9yLCBzbyBtb3ZlIHRoZSBpbmRleFxuICAgICAgICAvLyBmb3J3YXJkIGFuZCBidWlsZCB0aGUgcHJlZGljYXRlLlxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZUZyb21Ub2tlbih0b2tlbnNbaW5kZXhdLCByb290KTtcbiAgICAgICAgLy8gV2UgbWF0Y2ggYWdhaW5zdCBvbmx5IHRoZSBub2RlcyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBtYXRjaGVkLFxuICAgICAgICAvLyBzaW5jZSBhIGNvbWJpbmF0b3IgaXMgbWVhbnQgdG8gcmVmaW5lIGEgcHJldmlvdXMgc2VsZWN0b3IuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIC8vIFRoZSArIGNvbWJpbmF0b3JcbiAgICAgICAgICBjYXNlIEFESkFDRU5UX1NJQkxJTkc6XG4gICAgICAgICAgICByZXN1bHRzID0gbWF0Y2hBZGphY2VudFNpYmxpbmdzKHJlc3VsdHMsIHByZWRpY2F0ZSwgcm9vdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBUaGUgfiBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBHRU5FUkFMX1NJQkxJTkc6XG4gICAgICAgICAgICByZXN1bHRzID0gbWF0Y2hHZW5lcmFsU2libGluZyhyZXN1bHRzLCBwcmVkaWNhdGUsIHJvb3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVGhlID4gY29tYmluYXRvclxuICAgICAgICAgIGNhc2UgQ0hJTEQ6XG4gICAgICAgICAgICByZXN1bHRzID0gbWF0Y2hEaXJlY3RDaGlsZChyZXN1bHRzLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVGhlICcgJyAod2hpdGVzcGFjZSkgY29tYmluYXRvclxuICAgICAgICAgIGNhc2UgREVTQ0VOREFOVDoge1xuICAgICAgICAgICAgcmVzdWx0cyA9IG1hdGNoRGVzY2VuZGFudChyZXN1bHRzLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tYmluYXRvciBzZWxlY3RvcjogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbnp5bWU6OlNlbGVjdG9yIGV4cGVjdHMgYSBzdHJpbmcsIG9iamVjdCwgb3IgQ29tcG9uZW50IENvbnN0cnVjdG9yJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VUcmVlc0J5U2VsZWN0b3Ioc2VsZWN0b3IsIHJvb3RzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSByb290cy5tYXAoKG4pID0+IHJlZHVjZVRyZWVCeVNlbGVjdG9yKHNlbGVjdG9yLCBuKSk7XG4gIHJldHVybiB1bmlxdWUoZmxhdChyZXN1bHRzLCAxKSk7XG59XG4iXX0=